diff -urN wine-1.5.30/configure wine-multimedia/configure
--- wine-1.5.30/configure	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/configure	2013-05-17 10:44:20.426237026 +0300
@@ -648,6 +648,8 @@
 ALSALIBS
 GSTREAMER_LIBS
 GSTREAMER_CFLAGS
+PULSEINCL
+PULSELIBS
 LIBGETTEXTPO
 ZLIB
 FREETYPE_LIBS
@@ -828,6 +830,7 @@
 with_oss
 with_png
 with_pthread
+with_pulse
 with_sane
 with_tiff
 with_v4l
@@ -1539,6 +1542,7 @@
   --without-oss           do not use the OSS sound support
   --without-png           do not use PNG
   --without-pthread       do not use the pthread library
+  --without-pulse         do not use PulseAudio sound support
   --without-sane          do not use SANE (scanner support)
   --without-tiff          do not use TIFF
   --without-v4l           do not use v4l1 (v4l support)
@@ -2755,6 +2759,12 @@
 fi
 
 
+# Check whether --with-pulse was given.
+if test "${with_pulse+set}" = set; then :
+  withval=$with_pulse;
+fi
+
+
 # Check whether --with-sane was given.
 if test "${with_sane+set}" = set; then :
   withval=$with_sane;
@@ -11157,6 +11167,87 @@
 fi
 fi
 
+PULSELIBS=""
+
+PULSEINCL=""
+
+if test "x$with_pulse" != "xno";
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false";
+    then
+        ac_pulse_libs="`$PKG_CONFIG --libs libpulse 2>/dev/null`"
+        ac_pulse_cflags="`$PKG_CONFIG --cflags-only-I libpulse 2>/dev/null`"
+
+        CPPFLAGS="$CPPFLAGS $ac_pulse_cflags"
+        for ac_header in pulse/pulseaudio.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "pulse/pulseaudio.h" "ac_cv_header_pulse_pulseaudio_h" "$ac_includes_default"
+if test "x$ac_cv_header_pulse_pulseaudio_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PULSE_PULSEAUDIO_H 1
+_ACEOF
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pa_stream_is_corked in -lpulse" >&5
+$as_echo_n "checking for pa_stream_is_corked in -lpulse... " >&6; }
+if ${ac_cv_lib_pulse_pa_stream_is_corked+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpulse $ac_pulse_libs $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pa_stream_is_corked ();
+int
+main ()
+{
+return pa_stream_is_corked ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pulse_pa_stream_is_corked=yes
+else
+  ac_cv_lib_pulse_pa_stream_is_corked=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pulse_pa_stream_is_corked" >&5
+$as_echo "$ac_cv_lib_pulse_pa_stream_is_corked" >&6; }
+if test "x$ac_cv_lib_pulse_pa_stream_is_corked" = xyes; then :
+
+$as_echo "#define HAVE_PULSEAUDIO 1" >>confdefs.h
+
+                 PULSELIBS="$ac_pulse_libs"
+                 PULSEINCL="$ac_pulse_cflags"
+fi
+
+
+fi
+
+done
+
+    fi
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+if test "$ac_cv_lib_pulse_pa_stream_is_corked" != "yes"; then :
+  case "x$with_pulse" in
+  x)   as_fn_append wine_warnings "|libpulse ${notice_platform}development files not found or too old, Pulse won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.
+This is an error since --with-pulse was requested." "$LINENO" 5 ;;
+esac
+fi
+
 if test "x$with_gstreamer" != "xno"
 then
     ac_save_CPPFLAGS="$CPPFLAGS"
@@ -12348,12 +12439,13 @@
 
 test -n "$ALSALIBS" || enable_winealsa_drv=${enable_winealsa_drv:-no}
 test -n "$COREAUDIO" || enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+test -n "$PULSELIBS" || enable_winepulse_drv=${enable_winepulse_drv:-no}
 test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes || enable_wineoss_drv=${enable_wineoss_drv:-no}
 test "$ac_cv_header_linux_joystick_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
-if test "x$ALSALIBS$COREAUDIO" = "x" -a \
+if test "x$ALSALIBS$COREAUDIO$PULSELIBS" = "x" -a \
         "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes -a \
-        "x$with_alsa$with_coreaudio$with_oss" != xnonono
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
 then
     as_fn_append wine_warnings "|No sound system was found. Windows applications will be silent."
 fi
@@ -16324,6 +16416,7 @@
 wine_fn_config_dll wineoss.drv enable_wineoss_drv
 wine_fn_config_dll wineps.drv enable_wineps_drv install-lib,po
 wine_fn_config_dll wineps16.drv16 enable_win16
+wine_fn_config_dll winepulse.drv enable_winepulse_drv
 wine_fn_config_dll wineqtdecoder enable_wineqtdecoder
 wine_fn_config_dll winex11.drv enable_winex11_drv
 wine_fn_config_dll wing.dll16 enable_win16
@@ -16379,7 +16472,7 @@
 wine_fn_config_makefile fonts enable_fonts install-lib
 wine_fn_config_makefile include enable_include install-dev
 wine_fn_config_makefile libs/port enable_libs_port
-wine_fn_config_makefile libs/wine enable_libs_wine
+wine_fn_config_makefile libs/wine enable_libs_wine install-dev,install-lib
 wine_fn_config_makefile libs/wpp enable_libs_wpp
 wine_fn_config_makefile loader enable_loader install-lib,manpage
 wine_fn_config_program aspnet_regiis enable_aspnet_regiis install
diff -urN wine-1.5.30/configure.ac wine-multimedia/configure.ac
--- wine-1.5.30/configure.ac	2013-05-17 10:29:37.002281345 +0300
+++ wine-multimedia/configure.ac	2013-05-17 10:44:20.427237014 +0300
@@ -71,6 +71,7 @@
             [if test "x$withval" = "xno"; then ac_cv_header_png_h=no; fi])
 AC_ARG_WITH(pthread,   AS_HELP_STRING([--without-pthread],[do not use the pthread library]),
             [if test "x$withval" = "xno"; then ac_cv_header_pthread_h=no; fi])
+AC_ARG_WITH(pulse,     AC_HELP_STRING([--without-pulse],[do not use PulseAudio sound support]))
 AC_ARG_WITH(sane,      AS_HELP_STRING([--without-sane],[do not use SANE (scanner support)]))
 AC_ARG_WITH(tiff,       AS_HELP_STRING([--without-tiff],[do not use TIFF]),
             [if test "x$withval" = "xno"; then ac_cv_header_tiffio_h=no; fi])
@@ -1543,6 +1544,30 @@
           [GetText ${notice_platform}development files not found (or too old), po files can't be rebuilt.])
 fi
 
+dnl **** Check for PulseAudio ****
+AC_SUBST(PULSELIBS,"")
+AC_SUBST(PULSEINCL,"")
+if test "x$with_pulse" != "xno";
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false";
+    then
+        ac_pulse_libs="`$PKG_CONFIG --libs libpulse 2>/dev/null`"
+        ac_pulse_cflags="`$PKG_CONFIG --cflags-only-I libpulse 2>/dev/null`"
+
+        CPPFLAGS="$CPPFLAGS $ac_pulse_cflags"
+        AC_CHECK_HEADERS(pulse/pulseaudio.h,
+            [AC_CHECK_LIB(pulse, pa_stream_is_corked,
+                [AC_DEFINE(HAVE_PULSEAUDIO, 1, [Define if you have pulseaudio])
+                 PULSELIBS="$ac_pulse_libs"
+                 PULSEINCL="$ac_pulse_cflags"],,$ac_pulse_libs)
+        ])
+    fi
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+WINE_WARNING_WITH(pulse, [test "$ac_cv_lib_pulse_pa_stream_is_corked" != "yes"],
+        [libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.])
+
 dnl **** Check for gstreamer ****
 if test "x$with_gstreamer" != "xno"
 then
@@ -1738,13 +1763,14 @@
 dnl **** Disable unsupported winmm drivers ****
 test -n "$ALSALIBS" || enable_winealsa_drv=${enable_winealsa_drv:-no}
 test -n "$COREAUDIO" || enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+test -n "$PULSELIBS" || enable_winepulse_drv=${enable_winepulse_drv:-no}
 test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes || enable_wineoss_drv=${enable_wineoss_drv:-no}
 test "$ac_cv_header_linux_joystick_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
 dnl **** Check for any sound system ****
-if test "x$ALSALIBS$COREAUDIO" = "x" -a \
+if test "x$ALSALIBS$COREAUDIO$PULSELIBS" = "x" -a \
         "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes -a \
-        "x$with_alsa$with_coreaudio$with_oss" != xnonono
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
 then
     WINE_WARNING([No sound system was found. Windows applications will be silent.])
 fi
@@ -3118,6 +3144,7 @@
 WINE_CONFIG_DLL(wineoss.drv)
 WINE_CONFIG_DLL(wineps.drv,,[install-lib,po])
 WINE_CONFIG_DLL(wineps16.drv16,enable_win16)
+WINE_CONFIG_DLL(winepulse.drv)
 WINE_CONFIG_DLL(wineqtdecoder)
 WINE_CONFIG_DLL(winex11.drv)
 WINE_CONFIG_DLL(wing.dll16,enable_win16)
@@ -3173,7 +3200,7 @@
 WINE_CONFIG_MAKEFILE([fonts],,[install-lib])
 WINE_CONFIG_MAKEFILE([include],,[install-dev])
 WINE_CONFIG_MAKEFILE([libs/port])
-WINE_CONFIG_MAKEFILE([libs/wine])
+WINE_CONFIG_MAKEFILE([libs/wine],,[install-dev,install-lib])
 WINE_CONFIG_MAKEFILE([libs/wpp])
 WINE_CONFIG_MAKEFILE([loader],,[install-lib,manpage])
 WINE_CONFIG_PROGRAM(aspnet_regiis,,[install])
diff -urN wine-1.5.30/dlls/avrt/main.c wine-multimedia/dlls/avrt/main.c
--- wine-1.5.30/dlls/avrt/main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/avrt/main.c	2013-05-17 10:44:20.459236614 +0300
@@ -80,6 +80,7 @@
         SetLastError(ERROR_INVALID_HANDLE);
         return NULL;
     }
+    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL-1);
     return (HANDLE)0x12345678;
 }
 
diff -urN wine-1.5.30/dlls/comctl32/comboex.c wine-multimedia/dlls/comctl32/comboex.c
--- wine-1.5.30/dlls/comctl32/comboex.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comctl32/comboex.c	2013-05-17 10:44:20.472236451 +0300
@@ -75,7 +75,7 @@
     INT          nb_items;         /* Number of items */
     BOOL         unicode;          /* TRUE if this window is Unicode   */
     BOOL         NtfUnicode;       /* TRUE if parent wants notify in Unicode */
-    CBE_ITEMDATA *edit;            /* item data for edit item */
+    CBE_ITEMDATA edit;             /* item data for edit item */
     CBE_ITEMDATA *items;           /* Array of items */
 } COMBOEX_INFO;
 
@@ -273,9 +273,9 @@
 static void COMBOEX_FreeText (CBE_ITEMDATA *item)
 {
     if (is_textW(item->pszText)) Free(item->pszText);
-    item->pszText = 0;
+    item->pszText = NULL;
     Free(item->pszTemp);
-    item->pszTemp = 0;
+    item->pszTemp = NULL;
 }
 
 
@@ -455,15 +455,15 @@
 }
 
 
-static CBE_ITEMDATA * COMBOEX_FindItem(const COMBOEX_INFO *infoPtr, INT_PTR index)
+static CBE_ITEMDATA *COMBOEX_FindItem(COMBOEX_INFO *infoPtr, INT_PTR index)
 {
     CBE_ITEMDATA *item;
     INT i;
 
     if ((index >= infoPtr->nb_items) || (index < -1))
-	return 0;
+	return NULL;
     if (index == -1)
-	return infoPtr->edit;
+	return &infoPtr->edit;
     item = infoPtr->items;
     i = infoPtr->nb_items - 1;
 
@@ -481,7 +481,7 @@
 
 /* ***  CBEM_xxx message support  *** */
 
-static UINT COMBOEX_GetListboxText(const COMBOEX_INFO *infoPtr, INT_PTR n, LPWSTR buf)
+static UINT COMBOEX_GetListboxText(COMBOEX_INFO *infoPtr, INT_PTR n, LPWSTR buf)
 {
     CBE_ITEMDATA *item;
     LPCWSTR str;
@@ -519,7 +519,7 @@
 }
 
 
-static INT COMBOEX_DeleteItem (const COMBOEX_INFO *infoPtr, INT_PTR index)
+static INT COMBOEX_DeleteItem (COMBOEX_INFO *infoPtr, INT_PTR index)
 {
     TRACE("(index=%ld)\n", index);
 
@@ -534,7 +534,7 @@
 }
 
 
-static BOOL COMBOEX_GetItemW (const COMBOEX_INFO *infoPtr, COMBOBOXEXITEMW *cit)
+static BOOL COMBOEX_GetItemW (COMBOEX_INFO *infoPtr, COMBOBOXEXITEMW *cit)
 {
     INT_PTR index = cit->iItem;
     CBE_ITEMDATA *item;
@@ -555,7 +555,7 @@
 }
 
 
-static BOOL COMBOEX_GetItemA (const COMBOEX_INFO *infoPtr, COMBOBOXEXITEMA *cit)
+static BOOL COMBOEX_GetItemA (COMBOEX_INFO *infoPtr, COMBOBOXEXITEMA *cit)
 {
     COMBOBOXEXITEMW tmpcit;
 
@@ -754,7 +754,7 @@
     return himlTemp;
 }
 
-static BOOL COMBOEX_SetItemW (const COMBOEX_INFO *infoPtr, const COMBOBOXEXITEMW *cit)
+static BOOL COMBOEX_SetItemW (COMBOEX_INFO *infoPtr, const COMBOBOXEXITEMW *cit)
 {
     INT_PTR index = cit->iItem;
     CBE_ITEMDATA *item;
@@ -805,7 +805,7 @@
     return TRUE;
 }
 
-static BOOL COMBOEX_SetItemA (const COMBOEX_INFO *infoPtr, COMBOBOXEXITEMA const *cit)
+static BOOL COMBOEX_SetItemA (COMBOEX_INFO *infoPtr, COMBOBOXEXITEMA const *cit)
 {
     COMBOBOXEXITEMW citW;
     LPWSTR wstr = NULL;
@@ -863,7 +863,7 @@
 }
 
 
-static DWORD_PTR COMBOEX_GetItemData (const COMBOEX_INFO *infoPtr, INT_PTR index)
+static DWORD_PTR COMBOEX_GetItemData (COMBOEX_INFO *infoPtr, INT_PTR index)
 {
     CBE_ITEMDATA const *item1;
     CBE_ITEMDATA const *item2;
@@ -903,7 +903,7 @@
 }
 
 
-static DWORD_PTR COMBOEX_SetItemData (const COMBOEX_INFO *infoPtr, INT_PTR index, DWORD_PTR data)
+static DWORD_PTR COMBOEX_SetItemData (COMBOEX_INFO *infoPtr, INT_PTR index, DWORD_PTR data)
 {
     CBE_ITEMDATA *item1;
     CBE_ITEMDATA const *item2;
@@ -1090,16 +1090,6 @@
 
     COMBOEX_AdjustEditPos (infoPtr);
 
-    /*
-     * Create an item structure to represent the data in the
-     * EDIT control. It is allocated zero-filled.
-     */
-    infoPtr->edit = Alloc (sizeof (CBE_ITEMDATA));
-    if (!infoPtr->edit) {
-	COMBOEX_Destroy(infoPtr);
-	return -1;
-    }
-
     return 0;
 }
 
@@ -1316,17 +1306,17 @@
 }
 
 
-static LRESULT COMBOEX_DrawItem (const COMBOEX_INFO *infoPtr, DRAWITEMSTRUCT const *dis)
+static LRESULT COMBOEX_DrawItem (COMBOEX_INFO *infoPtr, DRAWITEMSTRUCT const *dis)
 {
     static const WCHAR nil[] = { 0 };
-    CBE_ITEMDATA *item = 0;
+    CBE_ITEMDATA *item = NULL;
     SIZE txtsize;
     RECT rect;
     LPCWSTR str = nil;
     UINT xbase, x, y;
     INT len;
     COLORREF nbkc, ntxc, bkc, txc;
-    int drawimage, drawstate, xioff;
+    int drawimage, drawstate, xioff, selected;
 
     TRACE("DRAWITEMSTRUCT: CtlType=0x%08x CtlID=0x%08x\n",
 	  dis->CtlType, dis->CtlID);
@@ -1378,7 +1368,7 @@
 
     /* If draw item is -1 (edit control) setup the item pointer */
     if (dis->itemID == 0xffffffff) {
-	item = infoPtr->edit;
+        item = &infoPtr->edit;
 
 	if (infoPtr->hwndEdit) {
 	    /* free previous text of edit item */
@@ -1427,36 +1417,30 @@
 
     drawimage = -2;
     drawstate = ILD_NORMAL;
+    selected = infoPtr->selected == dis->itemID;
+
     if (item->mask & CBEIF_IMAGE)
 	drawimage = item->iImage;
+    if (item->mask & CBEIF_SELECTEDIMAGE && selected)
+        drawimage = item->iSelectedImage;
     if (dis->itemState & ODS_COMBOEXLBOX) {
 	/* drawing listbox entry */
-	if (dis->itemState & ODS_SELECTED) {
-	    if (item->mask & CBEIF_SELECTEDIMAGE)
-	        drawimage = item->iSelectedImage;
+	if (dis->itemState & ODS_SELECTED)
 	    drawstate = ILD_SELECTED;
-	}
     } else {
 	/* drawing combo/edit entry */
 	if (IsWindowVisible(infoPtr->hwndEdit)) {
 	    /* if we have an edit control, the slave the
              * selection state to the Edit focus state
 	     */
-	    if (infoPtr->flags & WCBE_EDITFOCUSED) {
-	        if (item->mask & CBEIF_SELECTEDIMAGE)
-		    drawimage = item->iSelectedImage;
+	    if (infoPtr->flags & WCBE_EDITFOCUSED)
 		drawstate = ILD_SELECTED;
-	    }
-	} else {
+	} else
 	    /* if we don't have an edit control, use
 	     * the requested state.
 	     */
-	    if (dis->itemState & ODS_SELECTED) {
-		if (item->mask & CBEIF_SELECTEDIMAGE)
-		    drawimage = item->iSelectedImage;
+	    if (dis->itemState & ODS_SELECTED)
 		drawstate = ILD_SELECTED;
-	    }
-	}
     }
 
     if (infoPtr->himl && !(infoPtr->dwExtStyle & CBES_EX_NOEDITIMAGEINDENT)) {
@@ -1479,17 +1463,17 @@
     	if (drawimage == I_IMAGECALLBACK) {
 	    NMCOMBOBOXEXW nmce;
 	    ZeroMemory(&nmce, sizeof(nmce));
-	    nmce.ceItem.mask = (drawstate == ILD_NORMAL) ? CBEIF_IMAGE : CBEIF_SELECTEDIMAGE;
+	    nmce.ceItem.mask = selected ? CBEIF_SELECTEDIMAGE : CBEIF_IMAGE;
 	    nmce.ceItem.lParam = item->lParam;
 	    nmce.ceItem.iItem = dis->itemID;
 	    COMBOEX_NotifyItem(infoPtr, CBEN_GETDISPINFOW, &nmce);
-	    if (drawstate == ILD_NORMAL) {
+	    if (!selected) {
 	    	if (nmce.ceItem.mask & CBEIF_DI_SETITEM) item->iImage = nmce.ceItem.iImage;
 	    	drawimage = nmce.ceItem.iImage;
-	    } else if (drawstate == ILD_SELECTED) {
+	    } else {
 	        if (nmce.ceItem.mask & CBEIF_DI_SETITEM) item->iSelectedImage = nmce.ceItem.iSelectedImage;
-	        drawimage =  nmce.ceItem.iSelectedImage;
-	    } else ERR("Bad draw state = %d\n", drawstate);
+                drawimage = nmce.ceItem.iSelectedImage;
+	    }
         }
 
 	if (overlay == I_IMAGECALLBACK) {
@@ -1576,10 +1560,7 @@
     if (infoPtr->hwndEdit)
         RemoveWindowSubclass(infoPtr->hwndEdit, COMBOEX_EditWndProc, EDIT_SUBCLASSID);
 
-    COMBOEX_FreeText (infoPtr->edit);
-    Free (infoPtr->edit);
-    infoPtr->edit = 0;
-
+    COMBOEX_FreeText (&infoPtr->edit);
     COMBOEX_ResetContent (infoPtr);
 
     if (infoPtr->defaultFont)
@@ -1850,7 +1831,7 @@
 		if (COMBOEX_NotifyEndEdit (infoPtr, &cbeend, edit_text)) {
 		    /* abort the change, restore previous */
 		    TRACE("Notify requested abort of change\n");
-		    COMBOEX_SetEditText (infoPtr, infoPtr->edit);
+                    COMBOEX_SetEditText (infoPtr, &infoPtr->edit);
 		    RedrawWindow (infoPtr->hwndCombo, 0, 0, RDW_ERASE |
 				  RDW_INVALIDATE);
 		    return 0;
@@ -2084,7 +2065,7 @@
 
 		GetWindowTextW (infoPtr->hwndEdit, edit_text, 260);
 		if (selected == -1) {
-		    lastwrk = infoPtr->edit->pszText;
+                    lastwrk = infoPtr->edit.pszText;
 		}
 		else {
 		    CBE_ITEMDATA *item = COMBOEX_FindItem (infoPtr, selected);
diff -urN wine-1.5.30/dlls/comctl32/comctl32.h wine-multimedia/dlls/comctl32/comctl32.h
--- wine-1.5.30/dlls/comctl32/comctl32.h	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comctl32/comctl32.h	2013-05-17 10:44:20.472236451 +0300
@@ -38,9 +38,6 @@
 extern HMODULE COMCTL32_hModule DECLSPEC_HIDDEN;
 extern HBRUSH  COMCTL32_hPattern55AABrush DECLSPEC_HIDDEN;
 
-/* has a value of: 0, CCS_TOP, CCS_NOMOVEY, CCS_BOTTOM */
-#define CCS_LAYOUT_MASK 0x3
-
 /* Property sheet / Wizard */
 #define IDD_PROPSHEET 1006
 #define IDD_WIZARD    1020
@@ -76,23 +73,6 @@
 #define IDB_HIST_SMALL      130
 #define IDB_HIST_LARGE      131
 
-
-/* Month calendar month menu popup */
-#define IDD_MCMONTHMENU     300
-
-#define IDM_JAN				301
-#define IDM_FEB				302
-#define IDM_MAR				303
-#define IDM_APR				304
-#define IDM_MAY				305
-#define IDM_JUN				306
-#define IDM_JUL				307
-#define IDM_AUG				308
-#define IDM_SEP				309
-#define IDM_OCT				310
-#define IDM_NOV				311
-#define IDM_DEC				312
-
 #define IDM_TODAY                      4163
 #define IDM_GOTODAY                    4164
 
diff -urN wine-1.5.30/dlls/comctl32/commctrl.c wine-multimedia/dlls/comctl32/commctrl.c
--- wine-1.5.30/dlls/comctl32/commctrl.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comctl32/commctrl.c	2013-05-17 10:44:20.474236426 +0300
@@ -157,7 +157,8 @@
             break;
 
 	case DLL_PROCESS_DETACH:
-            /* clean up subclassing */ 
+            if (lpvReserved) break;
+            /* clean up subclassing */
             THEMING_Uninitialize();
 
             /* unregister all common control classes */
@@ -185,14 +186,11 @@
 
             /* delete local pattern brush */
             DeleteObject (COMCTL32_hPattern55AABrush);
-            COMCTL32_hPattern55AABrush = NULL;
             DeleteObject (COMCTL32_hPattern55AABitmap);
-            COMCTL32_hPattern55AABitmap = NULL;
 
             /* delete global subclassing atom */
             GlobalDeleteAtom (LOWORD(COMCTL32_wSubclass));
             TRACE("Subclassing atom deleted: %p\n", COMCTL32_wSubclass);
-            COMCTL32_wSubclass = NULL;
             break;
     }
 
diff -urN wine-1.5.30/dlls/comctl32/rebar.c wine-multimedia/dlls/comctl32/rebar.c
--- wine-1.5.30/dlls/comctl32/rebar.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comctl32/rebar.c	2013-05-17 10:44:20.492236201 +0300
@@ -138,6 +138,9 @@
     HWND    hwndPrevParent;
 } REBAR_BAND;
 
+/* has a value of: 0, CCS_TOP, CCS_NOMOVEY, CCS_BOTTOM */
+#define CCS_LAYOUT_MASK 0x3
+
 /* fStatus flags */
 #define HAS_GRIPPER    0x00000001
 #define HAS_IMAGE      0x00000002
diff -urN wine-1.5.30/dlls/comctl32/trackbar.c wine-multimedia/dlls/comctl32/trackbar.c
--- wine-1.5.30/dlls/comctl32/trackbar.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comctl32/trackbar.c	2013-05-17 10:44:20.513235939 +0300
@@ -499,12 +499,12 @@
         offsetthumb = (infoPtr->rcThumb.bottom - infoPtr->rcThumb.top)/2;
 	rcTics.left = infoPtr->rcThumb.left - 2;
 	rcTics.right = infoPtr->rcThumb.right + 2;
-	rcTics.top    = infoPtr->rcChannel.top + offsetthumb + 1;
-	rcTics.bottom = infoPtr->rcChannel.bottom - offsetthumb;
+	rcTics.top    = infoPtr->rcChannel.top + offsetthumb;
+	rcTics.bottom = infoPtr->rcChannel.bottom - offsetthumb - 1;
     } else {
         offsetthumb = (infoPtr->rcThumb.right - infoPtr->rcThumb.left)/2;
-	rcTics.left   = infoPtr->rcChannel.left + offsetthumb + 1;
-	rcTics.right  = infoPtr->rcChannel.right - offsetthumb;
+	rcTics.left   = infoPtr->rcChannel.left + offsetthumb;
+	rcTics.right  = infoPtr->rcChannel.right - offsetthumb - 1;
 	rcTics.top = infoPtr->rcThumb.top - 2;
 	rcTics.bottom = infoPtr->rcThumb.bottom + 2;
     }
@@ -612,10 +612,103 @@
     }
 }
 
+static int
+TRACKBAR_FillThumb (const TRACKBAR_INFO *infoPtr, HDC hdc, HBRUSH hbrush)
+{
+    const RECT *thumb = &infoPtr->rcThumb;
+    const int PointCount = 6;
+    POINT points[PointCount];
+    int PointDepth;
+    HBRUSH oldbr;
+
+    if (infoPtr->dwStyle & TBS_BOTH)
+    {
+        FillRect(hdc, thumb, hbrush);
+        return 0;
+    }
+
+    if (infoPtr->dwStyle & TBS_VERT)
+    {
+        PointDepth = (thumb->bottom - thumb->top) / 2;
+        if (infoPtr->dwStyle & TBS_LEFT)
+        {
+            points[0].x = thumb->right-1;
+            points[0].y = thumb->top;
+            points[1].x = thumb->right-1;
+            points[1].y = thumb->bottom-1;
+            points[2].x = thumb->left + PointDepth;
+            points[2].y = thumb->bottom-1;
+            points[3].x = thumb->left;
+            points[3].y = thumb->top + PointDepth;
+            points[4].x = thumb->left + PointDepth;
+            points[4].y = thumb->top;
+            points[5].x = points[0].x;
+            points[5].y = points[0].y;
+        }
+        else
+        {
+            points[0].x = thumb->right;
+            points[0].y = thumb->top + PointDepth;
+            points[1].x = thumb->right - PointDepth;
+            points[1].y = thumb->bottom-1;
+            points[2].x = thumb->left;
+            points[2].y = thumb->bottom-1;
+            points[3].x = thumb->left;
+            points[3].y = thumb->top;
+            points[4].x = thumb->right - PointDepth;
+            points[4].y = thumb->top;
+            points[5].x = points[0].x;
+            points[5].y = points[0].y;
+        }
+    }
+    else
+    {
+        PointDepth = (thumb->right - thumb->left) / 2;
+        if (infoPtr->dwStyle & TBS_TOP)
+        {
+            points[0].x = thumb->left + PointDepth;
+            points[0].y = thumb->top+1;
+            points[1].x = thumb->right-1;
+            points[1].y = thumb->top + PointDepth + 1;
+            points[2].x = thumb->right-1;
+            points[2].y = thumb->bottom-1;
+            points[3].x = thumb->left;
+            points[3].y = thumb->bottom-1;
+            points[4].x = thumb->left;
+            points[4].y = thumb->top + PointDepth + 1;
+            points[5].x = points[0].x;
+            points[5].y = points[0].y;
+        }
+        else
+        {
+            points[0].x = thumb->right-1;
+            points[0].y = thumb->top;
+            points[1].x = thumb->right-1;
+            points[1].y = thumb->bottom - PointDepth - 1;
+            points[2].x = thumb->left + PointDepth;
+            points[2].y = thumb->bottom-1;
+            points[3].x = thumb->left;
+            points[3].y = thumb->bottom - PointDepth - 1;
+            points[4].x = thumb->left;
+            points[4].y = thumb->top;
+            points[5].x = points[0].x;
+            points[5].y = points[0].y;
+        }
+    }
+
+    oldbr = SelectObject(hdc, hbrush);
+    SetPolyFillMode(hdc, WINDING);
+    Polygon(hdc, points, PointCount);
+    SelectObject(hdc, oldbr);
+
+    return PointDepth;
+}
+
 static void
 TRACKBAR_DrawThumb (TRACKBAR_INFO *infoPtr, HDC hdc)
 {
     HTHEME theme = GetWindowTheme (infoPtr->hwndSelf);
+    int PointDepth;
     HBRUSH brush;
 
     if (theme)
@@ -643,7 +736,7 @@
         return;
     }
 
-    if (infoPtr->dwStyle & WS_DISABLED)
+    if (infoPtr->dwStyle & WS_DISABLED || infoPtr->flags & TB_DRAG_MODE)
     {
         if (comctl32_color.clr3dHilight == comctl32_color.clrWindow)
             brush = COMCTL32_hPattern55AABrush;
@@ -654,105 +747,98 @@
         SetBkColor(hdc, comctl32_color.clr3dHilight);
     }
     else
-        brush = GetSysColorBrush(infoPtr->flags & TB_DRAG_MODE ? COLOR_BTNHILIGHT : COLOR_BTNFACE);
+        brush = GetSysColorBrush(COLOR_BTNFACE);
+
+    PointDepth = TRACKBAR_FillThumb(infoPtr, hdc, brush);
 
     if (infoPtr->dwStyle & TBS_BOTH)
     {
-       FillRect(hdc, &infoPtr->rcThumb, brush);
        DrawEdge(hdc, &infoPtr->rcThumb, EDGE_RAISED, BF_RECT | BF_SOFT);
        return;
     }
     else
     {
-        HBRUSH oldbr = SelectObject(hdc, brush);
         RECT thumb = infoPtr->rcThumb;
-        int BlackUntil = 3;
-        int PointCount = 6;
-        POINT points[6];
-        int PointDepth;
-        HPEN oldpen;
-
-        SetPolyFillMode (hdc, WINDING);
 
         if (infoPtr->dwStyle & TBS_VERT)
         {
-          PointDepth = (thumb.bottom - thumb.top) / 2;
           if (infoPtr->dwStyle & TBS_LEFT)
           {
-            points[0].x=thumb.right;
-            points[0].y=thumb.top;
-            points[1].x=thumb.right;
-            points[1].y=thumb.bottom;
-            points[2].x=thumb.left + PointDepth;
-            points[2].y=thumb.bottom;
-            points[3].x=thumb.left;
-            points[3].y=(thumb.bottom - thumb.top) / 2 + thumb.top + 1;
-            points[4].x=thumb.left + PointDepth;
-            points[4].y=thumb.top;
-            points[5].x=points[0].x;
-            points[5].y=points[0].y;
-            BlackUntil = 4;
+            /* rectangular part */
+            thumb.left += PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_TOP | BF_RIGHT | BF_BOTTOM | BF_SOFT);
+
+            /* light edge */
+            thumb.left -= PointDepth;
+            thumb.right = thumb.left + PointDepth;
+            thumb.bottom = infoPtr->rcThumb.top + PointDepth + 1;
+            thumb.top = infoPtr->rcThumb.top;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_DIAGONAL_ENDTOPRIGHT | BF_SOFT);
+
+            /* shadowed edge */
+            thumb.top += PointDepth;
+            thumb.bottom += PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_SUNKEN, BF_DIAGONAL_ENDTOPLEFT | BF_SOFT);
+            return;
           }
           else
           {
-            points[0].x=thumb.right;
-            points[0].y=(thumb.bottom - thumb.top) / 2 + thumb.top + 1;
-            points[1].x=thumb.right - PointDepth;
-            points[1].y=thumb.bottom;
-            points[2].x=thumb.left;
-            points[2].y=thumb.bottom;
-            points[3].x=thumb.left;
-            points[3].y=thumb.top;
-            points[4].x=thumb.right - PointDepth;
-            points[4].y=thumb.top;
-            points[5].x=points[0].x;
-            points[5].y=points[0].y;
+            /* rectangular part */
+            thumb.right -= PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_TOP | BF_LEFT | BF_BOTTOM | BF_SOFT);
+
+            /* light edge */
+            thumb.left = thumb.right;
+            thumb.right += PointDepth + 1;
+            thumb.bottom = infoPtr->rcThumb.top + PointDepth + 1;
+            thumb.top = infoPtr->rcThumb.top;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_DIAGONAL_ENDTOPLEFT | BF_SOFT);
+
+            /* shadowed edge */
+            thumb.top += PointDepth;
+            thumb.bottom += PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_DIAGONAL_ENDBOTTOMLEFT | BF_SOFT);
           }
         }
         else
         {
-          PointDepth = (thumb.right - thumb.left) / 2;
           if (infoPtr->dwStyle & TBS_TOP)
           {
-            points[0].x=(thumb.right - thumb.left) / 2 + thumb.left + 1;
-            points[0].y=thumb.top;
-            points[1].x=thumb.right;
-            points[1].y=thumb.top + PointDepth;
-            points[2].x=thumb.right;
-            points[2].y=thumb.bottom;
-            points[3].x=thumb.left;
-            points[3].y=thumb.bottom;
-            points[4].x=thumb.left;
-            points[4].y=thumb.top + PointDepth;
-            points[5].x=points[0].x;
-            points[5].y=points[0].y;
-            BlackUntil = 4;
+            /* rectangular part */
+            thumb.top += PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_LEFT | BF_BOTTOM | BF_RIGHT | BF_SOFT);
+
+            /* light edge */
+            thumb.left = infoPtr->rcThumb.left;
+            thumb.right = thumb.left + PointDepth;
+            thumb.bottom = infoPtr->rcThumb.top + PointDepth + 1;
+            thumb.top -= PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_DIAGONAL_ENDTOPRIGHT | BF_SOFT);
+
+            /* shadowed edge */
+            thumb.left += PointDepth;
+            thumb.right += PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_DIAGONAL_ENDBOTTOMRIGHT | BF_SOFT);
           }
           else
           {
-            points[0].x=thumb.right;
-            points[0].y=thumb.top;
-            points[1].x=thumb.right;
-            points[1].y=thumb.bottom - PointDepth;
-            points[2].x=(thumb.right - thumb.left) / 2 + thumb.left + 1;
-            points[2].y=thumb.bottom;
-            points[3].x=thumb.left;
-            points[3].y=thumb.bottom - PointDepth;
-            points[4].x=thumb.left;
-            points[4].y=thumb.top;
-            points[5].x=points[0].x;
-            points[5].y=points[0].y;
+            /* rectangular part */
+            thumb.bottom -= PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT);
+
+            /* light edge */
+            thumb.left = infoPtr->rcThumb.left;
+            thumb.right = thumb.left + PointDepth;
+            thumb.top = infoPtr->rcThumb.bottom - PointDepth - 1;
+            thumb.bottom += PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_DIAGONAL_ENDTOPLEFT | BF_SOFT);
+
+            /* shadowed edge */
+            thumb.left += PointDepth;
+            thumb.right += PointDepth;
+            DrawEdge(hdc, &thumb, EDGE_RAISED, BF_DIAGONAL_ENDBOTTOMLEFT | BF_SOFT);
           }
         }
-
-        /* Draw the thumb now */
-        Polygon (hdc, points, PointCount);
-        oldpen = SelectObject(hdc, GetStockObject(BLACK_PEN));
-        Polyline(hdc,points, BlackUntil);
-        SelectObject(hdc, GetStockObject(WHITE_PEN));
-        Polyline(hdc, &points[BlackUntil-1], PointCount+1-BlackUntil);
-        SelectObject(hdc, oldpen);
-        SelectObject(hdc, oldbr);
     }
 }
 
@@ -1297,9 +1383,11 @@
 TRACKBAR_SetThumbLength (TRACKBAR_INFO *infoPtr, UINT iLength)
 {
     if (infoPtr->dwStyle & TBS_FIXEDLENGTH) {
+        /* We're not supposed to check if it's really changed or not,
+           just repaint in any case. */
         infoPtr->uThumbLen = iLength;
 	infoPtr->flags |= TB_THUMBSIZECHANGED;
-	InvalidateRect (infoPtr->hwndSelf, &infoPtr->rcThumb, FALSE);
+	TRACKBAR_InvalidateAll(infoPtr);
     }
 
     return 0;
@@ -1573,9 +1661,15 @@
 static LRESULT
 TRACKBAR_Size (TRACKBAR_INFO *infoPtr)
 {
-    TRACKBAR_CalcChannel (infoPtr);
-    TRACKBAR_UpdateThumb (infoPtr);
+    if (infoPtr->dwStyle & TBS_FIXEDLENGTH)
+    {
+        TRACKBAR_CalcChannel(infoPtr);
+        TRACKBAR_UpdateThumb(infoPtr);
+    }
+    else
+        TRACKBAR_InitializeThumb(infoPtr);
     TRACKBAR_AlignBuddies (infoPtr);
+    TRACKBAR_InvalidateAll(infoPtr);
 
     return 0;
 }
diff -urN wine-1.5.30/dlls/comdlg32/cdlg.h wine-multimedia/dlls/comdlg32/cdlg.h
--- wine-1.5.30/dlls/comdlg32/cdlg.h	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comdlg32/cdlg.h	2013-05-17 10:44:20.515235914 +0300
@@ -148,6 +148,28 @@
 #define IDS_COLOR_AQUA                  1054
 #define IDS_COLOR_WHITE                 1055
 
+/* Color dialog controls */
+#define IDC_COLOR_LUMBAR 702
+#define IDC_COLOR_EDIT_H 703
+#define IDC_COLOR_EDIT_S 704
+#define IDC_COLOR_EDIT_L 705
+#define IDC_COLOR_EDIT_R 706
+#define IDC_COLOR_EDIT_G 707
+#define IDC_COLOR_EDIT_B 708
+#define IDC_COLOR_RESULT 709
+#define IDC_COLOR_GRAPH  710
+#define IDC_COLOR_ADD    712
+#define IDC_COLOR_RES    713
+#define IDC_COLOR_DEFINE 719
+#define IDC_COLOR_PREDEF 720
+#define IDC_COLOR_USRDEF 721
+#define IDC_COLOR_HL     723
+#define IDC_COLOR_SL     724
+#define IDC_COLOR_LL     725
+#define IDC_COLOR_RL     726
+#define IDC_COLOR_GL     727
+#define IDC_COLOR_BL     728
+
 #define IDS_FONT_SIZE    1200
 #define IDS_SAVE_BUTTON  1201
 #define IDS_SAVE_IN      1202
diff -urN wine-1.5.30/dlls/comdlg32/colordlg.c wine-multimedia/dlls/comdlg32/colordlg.c
--- wine-1.5.30/dlls/comdlg32/colordlg.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comdlg32/colordlg.c	2013-05-17 10:44:20.516235901 +0300
@@ -23,11 +23,8 @@
    sometimes, especially when 2 instances of the
    dialog are loaded at the same time */
 
-#include <ctype.h>
-#include <stdlib.h>
 #include <stdarg.h>
 #include <stdio.h>
-#include <string.h>
 #include "windef.h"
 #include "winbase.h"
 #include "wingdi.h"
@@ -74,6 +71,7 @@
 typedef struct CCPRIVATE
 {
     LPCHOOSECOLORW lpcc; /* points to public known data structure */
+    HWND hwndSelf;       /* dialog window */
     int nextuserdef;     /* next free place in user defined color array */
     HDC hdcMem;          /* color graph used for BitBlt() */
     HBITMAP hbmMem;      /* color graph bitmap */
@@ -88,23 +86,12 @@
     int capturedGraph;   /* control mouse captured */
     RECT focusRect;      /* rectangle last focused item */
     HWND hwndFocus;      /* handle last focused item */
-} CCPRIV, *LPCCPRIV;
+} CCPRIV;
 
-/***********************************************************************
- *                             CC_HSLtoRGB                    [internal]
- */
-static int CC_HSLtoRGB(char c, int hue, int sat, int lum)
+static int hsl_to_x(int hue, int sat, int lum)
 {
  int res = 0, maxrgb;
 
- /* hue */
- switch(c)
- {
-  case 'R': if (hue > 80)  hue -= 80; else hue += 160; break;
-  case 'G': if (hue > 160) hue -= 160; else hue += 80; break;
-  case 'B': break;
- }
-
  /* l below 120 */
  maxrgb = (256 * min(120,lum)) / 120;  /* 0 .. 256 */
  if (hue < 80)
@@ -136,12 +123,35 @@
 }
 
 /***********************************************************************
+ *                             CC_HSLtoRGB                    [internal]
+ */
+static COLORREF CC_HSLtoRGB(int hue, int sat, int lum)
+{
+ int h, r, g, b;
+
+ /* r */
+ h = hue > 80 ? hue-80 : hue+160;
+ r = hsl_to_x(h, sat, lum);
+ /* g */
+ h = hue > 160 ? hue-160 : hue+80;
+ g = hsl_to_x(h, sat, lum);
+ /* b */
+ b = hsl_to_x(hue, sat, lum);
+
+ return RGB(r, g, b);
+}
+
+/***********************************************************************
  *                             CC_RGBtoHSL                    [internal]
  */
-static int CC_RGBtoHSL(char c, int r, int g, int b)
+static int CC_RGBtoHSL(char c, COLORREF rgb)
 {
  WORD maxi, mini, mmsum, mmdif, result = 0;
- int iresult = 0;
+ int iresult = 0, r, g, b;
+
+ r = GetRValue(rgb);
+ g = GetGValue(rgb);
+ b = GetBValue(rgb);
 
  maxi = max(r, b);
  maxi = max(maxi, g);
@@ -219,7 +229,7 @@
 /***********************************************************************
  *                  CC_DrawFocusRect                       [internal]
  */
-static void CC_DrawFocusRect( LPCCPRIV lpp, HWND hwnd, int x, int y, int rows, int cols)
+static void CC_DrawFocusRect(CCPRIV *lpp, HWND hwnd, int x, int y, int rows, int cols)
 {
   RECT rect;
   int dx, dy;
@@ -248,8 +258,7 @@
  *                CC_MouseCheckPredefColorArray               [internal]
  *                returns 1 if one of the predefined colors is clicked
  */
-static int CC_MouseCheckPredefColorArray( LPCCPRIV lpp, HWND hDlg, int dlgitem, int rows, int cols,
-	    LPARAM lParam )
+static int CC_MouseCheckPredefColorArray(CCPRIV *lpp, int rows, int cols, LPARAM lParam)
 {
  HWND hwnd;
  POINT point;
@@ -257,8 +266,8 @@
  int dx, dy, x, y;
 
  CONV_LPARAMTOPOINT(lParam, &point);
- ClientToScreen(hDlg, &point);
- hwnd = GetDlgItem(hDlg, dlgitem);
+ ClientToScreen(lpp->hwndSelf, &point);
+ hwnd = GetDlgItem(lpp->hwndSelf, IDC_COLOR_PREDEF);
  GetWindowRect(hwnd, &rect);
  if (PtInRect(&rect, point))
  {
@@ -282,8 +291,7 @@
  *                  CC_MouseCheckUserColorArray               [internal]
  *                  return 1 if the user clicked a color
  */
-static int CC_MouseCheckUserColorArray( LPCCPRIV lpp, HWND hDlg, int dlgitem, int rows, int cols,
-	    LPARAM lParam )
+static int CC_MouseCheckUserColorArray(CCPRIV *lpp, int rows, int cols, LPARAM lParam)
 {
  HWND hwnd;
  POINT point;
@@ -292,8 +300,8 @@
  COLORREF *crarr = lpp->lpcc->lpCustColors;
 
  CONV_LPARAMTOPOINT(lParam, &point);
- ClientToScreen(hDlg, &point);
- hwnd = GetDlgItem(hDlg, dlgitem);
+ ClientToScreen(lpp->hwndSelf, &point);
+ hwnd = GetDlgItem(lpp->hwndSelf, IDC_COLOR_USRDEF);
  GetWindowRect(hwnd, &rect);
  if (PtInRect(&rect, point))
  {
@@ -373,11 +381,11 @@
 
  CONV_LPARAMTOPOINT(lParam, &point);
  ClientToScreen(hDlg, &point);
- hwnd = GetDlgItem(hDlg, 0x2c5);
+ hwnd = GetDlgItem(hDlg, IDC_COLOR_RESULT);
  GetWindowRect(hwnd, &rect);
  if (PtInRect(&rect, point))
  {
-  PostMessageA(hDlg, WM_COMMAND, 0x2c9, 0);
+  PostMessageA(hDlg, WM_COMMAND, IDC_COLOR_RES, 0);
   return 1;
  }
  return 0;
@@ -428,17 +436,18 @@
 /***********************************************************************
  *                    CC_PaintSelectedColor                   [internal]
  */
-static void CC_PaintSelectedColor( HWND hDlg, COLORREF cr )
+static void CC_PaintSelectedColor(const CCPRIV *infoPtr)
 {
- RECT rect;
- HDC  hdc;
- HBRUSH hBrush;
- HWND hwnd = GetDlgItem(hDlg, 0x2c5);
- if (IsWindowVisible( GetDlgItem(hDlg, 0x2c6) ))   /* if full size */
+ if (IsWindowVisible( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_GRAPH) ))   /* if full size */
  {
+  RECT rect;
+  HDC  hdc;
+  HBRUSH hBrush;
+  HWND hwnd = GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_RESULT);
+
   hdc = GetDC(hwnd);
   GetClientRect(hwnd, &rect) ;
-  hBrush = CreateSolidBrush(cr);
+  hBrush = CreateSolidBrush(infoPtr->lpcc->rgbResult);
   if (hBrush)
   {
    FillRect(hdc, &rect, hBrush);
@@ -452,7 +461,7 @@
 /***********************************************************************
  *                    CC_PaintTriangle                        [internal]
  */
-static void CC_PaintTriangle( HWND hDlg, int y)
+static void CC_PaintTriangle(CCPRIV *infoPtr)
 {
  HDC hDC;
  long temp;
@@ -462,21 +471,20 @@
  int oben;
  RECT rect;
  HBRUSH hbr;
- HWND hwnd = GetDlgItem(hDlg, 0x2be);
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
+ HWND hwnd = GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_LUMBAR);
 
- if (IsWindowVisible( GetDlgItem(hDlg, 0x2c6)))   /* if full size */
+ if (IsWindowVisible( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_GRAPH)))   /* if full size */
  {
    GetClientRect(hwnd, &rect);
    height = rect.bottom;
-   hDC = GetDC(hDlg);
+   hDC = GetDC(infoPtr->hwndSelf);
    points[0].y = rect.top;
-   points[0].x = rect.right;     /*  |  /|  */
-   ClientToScreen(hwnd, points); /*  | / |  */
-   ScreenToClient(hDlg, points); /*  |<  |  */
-   oben = points[0].y;           /*  | \ |  */
-                                 /*  |  \|  */
-   temp = (long)height * (long)y;
+   points[0].x = rect.right;                  /*  |  /|  */
+   ClientToScreen(hwnd, points);              /*  | / |  */
+   ScreenToClient(infoPtr->hwndSelf, points); /*  |<  |  */
+   oben = points[0].y;                        /*  | \ |  */
+                                              /*  |  \|  */
+   temp = (long)height * (long)infoPtr->l;
    points[0].x += 1;
    points[0].y = oben + height - temp / (long)MAXVERT;
    points[1].y = points[0].y + w;
@@ -485,17 +493,17 @@
 
    hbr = (HBRUSH)GetClassLongPtrW( hwnd, GCLP_HBRBACKGROUND);
    if (!hbr) hbr = GetSysColorBrush(COLOR_BTNFACE);
-   FillRect(hDC, &lpp->old3angle, hbr);
-   lpp->old3angle.left  = points[0].x;
-   lpp->old3angle.right = points[1].x + 1;
-   lpp->old3angle.top   = points[2].y - 1;
-   lpp->old3angle.bottom= points[1].y + 1;
+   FillRect(hDC, &infoPtr->old3angle, hbr);
+   infoPtr->old3angle.left  = points[0].x;
+   infoPtr->old3angle.right = points[1].x + 1;
+   infoPtr->old3angle.top   = points[2].y - 1;
+   infoPtr->old3angle.bottom= points[1].y + 1;
 
    hbr = SelectObject(hDC, GetStockObject(BLACK_BRUSH));
    Polygon(hDC, points, 3);
    SelectObject(hDC, hbr);
 
-   ReleaseDC(hDlg, hDC);
+   ReleaseDC(infoPtr->hwndSelf, hDC);
  }
 }
 
@@ -503,36 +511,40 @@
 /***********************************************************************
  *                    CC_PaintCross                           [internal]
  */
-static void CC_PaintCross( HWND hDlg, int x, int y)
+static void CC_PaintCross(CCPRIV *infoPtr)
 {
- HDC hDC;
- int w = GetDialogBaseUnits() - 1;
- int wc = GetDialogBaseUnits() * 3 / 4;
- HWND hwnd = GetDlgItem(hDlg, 0x2c6);
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
- RECT rect;
- POINT point, p;
- HPEN hPen;
+ HWND hwnd = GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_GRAPH);
 
- if (IsWindowVisible( GetDlgItem(hDlg, 0x2c6) ))   /* if full size */
+ if (IsWindowVisible(hwnd))   /* if full size */
  {
+   HDC hDC;
+   int w = GetDialogBaseUnits() - 1;
+   int wc = GetDialogBaseUnits() * 3 / 4;
+   RECT rect;
+   POINT point, p;
+   HPEN hPen;
+   int x, y;
+
+   x = infoPtr->h;
+   y = infoPtr->s;
+
    GetClientRect(hwnd, &rect);
    hDC = GetDC(hwnd);
    SelectClipRgn( hDC, CreateRectRgnIndirect(&rect));
 
    point.x = ((long)rect.right * (long)x) / (long)MAXHORI;
    point.y = rect.bottom - ((long)rect.bottom * (long)y) / (long)MAXVERT;
-   if ( lpp->oldcross.left != lpp->oldcross.right )
-     BitBlt(hDC, lpp->oldcross.left, lpp->oldcross.top,
-              lpp->oldcross.right - lpp->oldcross.left,
-              lpp->oldcross.bottom - lpp->oldcross.top,
-              lpp->hdcMem, lpp->oldcross.left, lpp->oldcross.top, SRCCOPY);
-   lpp->oldcross.left   = point.x - w - 1;
-   lpp->oldcross.right  = point.x + w + 1;
-   lpp->oldcross.top    = point.y - w - 1;
-   lpp->oldcross.bottom = point.y + w + 1;
+   if ( infoPtr->oldcross.left != infoPtr->oldcross.right )
+     BitBlt(hDC, infoPtr->oldcross.left, infoPtr->oldcross.top,
+              infoPtr->oldcross.right - infoPtr->oldcross.left,
+              infoPtr->oldcross.bottom - infoPtr->oldcross.top,
+              infoPtr->hdcMem, infoPtr->oldcross.left, infoPtr->oldcross.top, SRCCOPY);
+   infoPtr->oldcross.left   = point.x - w - 1;
+   infoPtr->oldcross.right  = point.x + w + 1;
+   infoPtr->oldcross.top    = point.y - w - 1;
+   infoPtr->oldcross.bottom = point.y + w + 1;
 
-   hPen = CreatePen(PS_SOLID, 3, 0x000000); /* -black- color */
+   hPen = CreatePen(PS_SOLID, 3, RGB(0, 0, 0)); /* -black- color */
    hPen = SelectObject(hDC, hPen);
    MoveToEx(hDC, point.x - w, point.y, &p);
    LineTo(hDC, point.x - wc, point.y);
@@ -556,11 +568,10 @@
 /***********************************************************************
  *                    CC_PrepareColorGraph                    [internal]
  */
-static void CC_PrepareColorGraph( HWND hDlg )
+static void CC_PrepareColorGraph(CCPRIV *infoPtr)
 {
- int sdif, hdif, xdif, ydif, r, g, b, hue, sat;
- HWND hwnd = GetDlgItem(hDlg, 0x2c6);
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
+ int sdif, hdif, xdif, ydif, hue, sat;
+ HWND hwnd = GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_GRAPH);
  HBRUSH hbrush;
  HDC hdc ;
  RECT rect, client;
@@ -568,9 +579,9 @@
 
  GetClientRect(hwnd, &client);
  hdc = GetDC(hwnd);
- lpp->hdcMem = CreateCompatibleDC(hdc);
- lpp->hbmMem = CreateCompatibleBitmap(hdc, client.right, client.bottom);
- SelectObject(lpp->hdcMem, lpp->hbmMem);
+ infoPtr->hdcMem = CreateCompatibleDC(hdc);
+ infoPtr->hbmMem = CreateCompatibleBitmap(hdc, client.right, client.bottom);
+ SelectObject(infoPtr->hdcMem, infoPtr->hbmMem);
 
  xdif = client.right / XSTEPS;
  ydif = client.bottom / YSTEPS+1;
@@ -583,11 +594,8 @@
   for(sat = 0; sat < 240 + sdif; sat += sdif)
   {
    rect.top = rect.bottom - ydif;
-   r = CC_HSLtoRGB('R', hue, sat, 120);
-   g = CC_HSLtoRGB('G', hue, sat, 120);
-   b = CC_HSLtoRGB('B', hue, sat, 120);
-   hbrush = CreateSolidBrush( RGB(r, g, b));
-   FillRect(lpp->hdcMem, &rect, hbrush);
+   hbrush = CreateSolidBrush(CC_HSLtoRGB(hue, sat, 120));
+   FillRect(infoPtr->hdcMem, &rect, hbrush);
    DeleteObject(hbrush);
    rect.bottom = rect.top;
   }
@@ -600,21 +608,21 @@
 /***********************************************************************
  *                          CC_PaintColorGraph                [internal]
  */
-static void CC_PaintColorGraph( HWND hDlg )
+static void CC_PaintColorGraph(CCPRIV *infoPtr)
 {
- HWND hwnd = GetDlgItem( hDlg, 0x2c6 );
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
+ HWND hwnd = GetDlgItem( infoPtr->hwndSelf, IDC_COLOR_GRAPH );
  HDC  hDC;
  RECT rect;
+
  if (IsWindowVisible(hwnd))   /* if full size */
  {
-  if (!lpp->hdcMem)
-   CC_PrepareColorGraph(hDlg);   /* should not be necessary */
+  if (!infoPtr->hdcMem)
+   CC_PrepareColorGraph(infoPtr);   /* should not be necessary */
 
   hDC = GetDC(hwnd);
   GetClientRect(hwnd, &rect);
-  if (lpp->hdcMem)
-      BitBlt(hDC, 0, 0, rect.right, rect.bottom, lpp->hdcMem, 0, 0, SRCCOPY);
+  if (infoPtr->hdcMem)
+      BitBlt(hDC, 0, 0, rect.right, rect.bottom, infoPtr->hdcMem, 0, 0, SRCCOPY);
   else
       WARN("choose color: hdcMem is not defined\n");
   ReleaseDC(hwnd, hDC);
@@ -624,11 +632,11 @@
 /***********************************************************************
  *                           CC_PaintLumBar                   [internal]
  */
-static void CC_PaintLumBar( HWND hDlg, int hue, int sat )
+static void CC_PaintLumBar(const CCPRIV *infoPtr)
 {
- HWND hwnd = GetDlgItem(hDlg, 0x2be);
+ HWND hwnd = GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_LUMBAR);
  RECT rect, client;
- int lum, ldif, ydif, r, g, b;
+ int lum, ldif, ydif;
  HBRUSH hbrush;
  HDC hDC;
 
@@ -643,10 +651,7 @@
   for (lum = 0; lum < 240 + ldif; lum += ldif)
   {
    rect.top = max(0, rect.bottom - ydif);
-   r = CC_HSLtoRGB('R', hue, sat, lum);
-   g = CC_HSLtoRGB('G', hue, sat, lum);
-   b = CC_HSLtoRGB('B', hue, sat, lum);
-   hbrush = CreateSolidBrush( RGB(r, g, b) );
+   hbrush = CreateSolidBrush(CC_HSLtoRGB(infoPtr->h, infoPtr->s, lum));
    FillRect(hDC, &rect, hbrush);
    DeleteObject(hbrush);
    rect.bottom = rect.top;
@@ -660,91 +665,89 @@
 /***********************************************************************
  *                             CC_EditSetRGB                  [internal]
  */
-static void CC_EditSetRGB( HWND hDlg, COLORREF cr )
+static void CC_EditSetRGB( CCPRIV *infoPtr )
 {
- char buffer[10];
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
- int r = GetRValue(cr);
- int g = GetGValue(cr);
- int b = GetBValue(cr);
- if (IsWindowVisible( GetDlgItem(hDlg, 0x2c6) ))   /* if full size */
+ if (IsWindowVisible( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_GRAPH) ))   /* if full size */
  {
-   lpp->updating = TRUE;
+   COLORREF cr = infoPtr->lpcc->rgbResult;
+   int r = GetRValue(cr);
+   int g = GetGValue(cr);
+   int b = GetBValue(cr);
+   char buffer[10];
+
+   infoPtr->updating = TRUE;
    sprintf(buffer, "%d", r);
-   SetWindowTextA( GetDlgItem(hDlg, 0x2c2), buffer);
+   SetWindowTextA( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_EDIT_R), buffer);
    sprintf(buffer, "%d", g);
-   SetWindowTextA( GetDlgItem(hDlg, 0x2c3), buffer);
+   SetWindowTextA( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_EDIT_G), buffer);
    sprintf( buffer, "%d", b );
-   SetWindowTextA( GetDlgItem(hDlg, 0x2c4),buffer);
-   lpp->updating = FALSE;
+   SetWindowTextA( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_EDIT_B), buffer);
+   infoPtr->updating = FALSE;
  }
 }
 
 /***********************************************************************
  *                             CC_EditSetHSL                  [internal]
  */
-static void CC_EditSetHSL( HWND hDlg, int h, int s, int l )
+static void CC_EditSetHSL( CCPRIV *infoPtr )
 {
- char buffer[10];
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
-
- if (IsWindowVisible( GetDlgItem(hDlg, 0x2c6) ))   /* if full size */
+ if (IsWindowVisible( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_GRAPH) ))   /* if full size */
  {
-   lpp->updating = TRUE;
-   sprintf(buffer, "%d", h);
-   SetWindowTextA( GetDlgItem(hDlg, 0x2bf), buffer);
-   sprintf(buffer, "%d", s);
-   SetWindowTextA( GetDlgItem(hDlg, 0x2c0), buffer);
-   sprintf(buffer, "%d", l);
-   SetWindowTextA( GetDlgItem(hDlg, 0x2c1), buffer);
-   lpp->updating = FALSE;
+   char buffer[10];
+
+   infoPtr->updating = TRUE;
+   sprintf(buffer, "%d", infoPtr->h);
+   SetWindowTextA( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_EDIT_H), buffer);
+   sprintf(buffer, "%d", infoPtr->s);
+   SetWindowTextA( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_EDIT_S), buffer);
+   sprintf(buffer, "%d", infoPtr->l);
+   SetWindowTextA( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_EDIT_L), buffer);
+   infoPtr->updating = FALSE;
  }
- CC_PaintLumBar(hDlg, h, s);
+ CC_PaintLumBar(infoPtr);
 }
 
 /***********************************************************************
  *                       CC_SwitchToFullSize                  [internal]
  */
-static void CC_SwitchToFullSize( HWND hDlg, COLORREF result, LPCRECT lprect )
+static void CC_SwitchToFullSize( CCPRIV *infoPtr, const RECT *lprect )
 {
  int i;
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
 
- EnableWindow( GetDlgItem(hDlg, 0x2cf), FALSE);
- CC_PrepareColorGraph(hDlg);
- for (i = 0x2bf; i < 0x2c5; i++)
-   ShowWindow( GetDlgItem(hDlg, i), SW_SHOW);
- for (i = 0x2d3; i < 0x2d9; i++)
-   ShowWindow( GetDlgItem(hDlg, i), SW_SHOW);
- ShowWindow( GetDlgItem(hDlg, 0x2c9), SW_SHOW);
- ShowWindow( GetDlgItem(hDlg, 0x2c8), SW_SHOW);
- ShowWindow( GetDlgItem(hDlg, 1090), SW_SHOW);
+ EnableWindow( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_DEFINE), FALSE);
+ CC_PrepareColorGraph(infoPtr);
+ for (i = IDC_COLOR_EDIT_H; i <= IDC_COLOR_EDIT_B; i++)
+   ShowWindow( GetDlgItem(infoPtr->hwndSelf, i), SW_SHOW);
+ for (i = IDC_COLOR_HL; i <= IDC_COLOR_BL; i++)
+   ShowWindow( GetDlgItem(infoPtr->hwndSelf, i), SW_SHOW);
+ ShowWindow( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_RES), SW_SHOW);
+ ShowWindow( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_ADD), SW_SHOW);
+ ShowWindow( GetDlgItem(infoPtr->hwndSelf, 1090), SW_SHOW);
 
  if (lprect)
-  SetWindowPos(hDlg, 0, 0, 0, lprect->right-lprect->left,
+  SetWindowPos(infoPtr->hwndSelf, 0, 0, 0, lprect->right-lprect->left,
    lprect->bottom-lprect->top, SWP_NOMOVE|SWP_NOZORDER);
 
- ShowWindow( GetDlgItem(hDlg, 0x2be), SW_SHOW);
- ShowWindow( GetDlgItem(hDlg, 0x2c5), SW_SHOW);
+ ShowWindow( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_LUMBAR), SW_SHOW);
+ ShowWindow( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_RESULT), SW_SHOW);
 
- CC_EditSetRGB(hDlg, result);
- CC_EditSetHSL(hDlg, lpp->h, lpp->s, lpp->l);
- ShowWindow( GetDlgItem( hDlg, 0x2c6), SW_SHOW);
- UpdateWindow( GetDlgItem(hDlg, 0x2c6) );
+ CC_EditSetRGB(infoPtr);
+ CC_EditSetHSL(infoPtr);
+ ShowWindow( GetDlgItem( infoPtr->hwndSelf, IDC_COLOR_GRAPH), SW_SHOW);
+ UpdateWindow( GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_GRAPH) );
 }
 
 /***********************************************************************
  *                           CC_PaintPredefColorArray         [internal]
  *                Paints the default standard 48 colors
  */
-static void CC_PaintPredefColorArray( HWND hDlg, int rows, int cols)
+static void CC_PaintPredefColorArray(const CCPRIV *infoPtr, int rows, int cols)
 {
- HWND hwnd = GetDlgItem(hDlg, 0x2d0);
+ HWND hwnd = GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_PREDEF);
  RECT rect, blockrect;
  HDC  hdc;
  HBRUSH hBrush;
  int dx, dy, i, j, k;
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
 
  GetClientRect(hwnd, &rect);
  dx = rect.right / cols;
@@ -777,21 +780,20 @@
   rect.left = k;
  }
  ReleaseDC(hwnd, hdc);
- if (lpp->hwndFocus == hwnd)
-   CC_DrawCurrentFocusRect(lpp);
+ if (infoPtr->hwndFocus == hwnd)
+   CC_DrawCurrentFocusRect(infoPtr);
 }
 /***********************************************************************
  *                             CC_PaintUserColorArray         [internal]
  *               Paint the 16 user-selected colors
  */
-static void CC_PaintUserColorArray( HWND hDlg, int rows, int cols, const COLORREF *lpcr )
+static void CC_PaintUserColorArray(const CCPRIV *infoPtr, int rows, int cols)
 {
- HWND hwnd = GetDlgItem(hDlg, 0x2d1);
+ HWND hwnd = GetDlgItem(infoPtr->hwndSelf, IDC_COLOR_USRDEF);
  RECT rect, blockrect;
  HDC  hdc;
  HBRUSH hBrush;
  int dx, dy, i, j, k;
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
 
  GetClientRect(hwnd, &rect);
 
@@ -809,7 +811,7 @@
   {
    for (i = 0; i < cols; i++)
    {
-    hBrush = CreateSolidBrush(lpcr[i+j*cols]);
+    hBrush = CreateSolidBrush(infoPtr->lpcc->lpCustColors[i+j*cols]);
     if (hBrush)
     {
      blockrect.left = rect.left;
@@ -827,8 +829,8 @@
   }
   ReleaseDC(hwnd, hdc);
  }
- if (lpp->hwndFocus == hwnd)
-   CC_DrawCurrentFocusRect(lpp);
+ if (infoPtr->hwndFocus == hwnd)
+   CC_DrawCurrentFocusRect(infoPtr);
 }
 
 
@@ -849,24 +851,26 @@
  */
 static LRESULT CC_WMInitDialog( HWND hDlg, WPARAM wParam, LPARAM lParam )
 {
+   CHOOSECOLORW *cc = (CHOOSECOLORW*)lParam;
    int i, res;
    int r, g, b;
    HWND hwnd;
    RECT rect;
    POINT point;
-   LPCCPRIV lpp;
+   CCPRIV *lpp;
 
    TRACE("WM_INITDIALOG lParam=%08lX\n", lParam);
-   lpp = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct CCPRIVATE) );
 
-   lpp->lpcc = (LPCHOOSECOLORW) lParam;
-   if (lpp->lpcc->lStructSize != sizeof(CHOOSECOLORW) )
+   if (cc->lStructSize != sizeof(CHOOSECOLORW))
    {
-       HeapFree(GetProcessHeap(), 0, lpp);
-       EndDialog (hDlg, 0) ;
+       EndDialog(hDlg, 0);
        return FALSE;
    }
 
+   lpp = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct CCPRIVATE) );
+   lpp->lpcc = cc;
+   lpp->hwndSelf = hDlg;
+
    SetPropW( hDlg, szColourDialogProp, lpp );
 
    if (!(lpp->lpcc->Flags & CC_SHOWHELP))
@@ -892,14 +896,14 @@
    GetWindowRect(hDlg, &lpp->fullsize);
    if (lpp->lpcc->Flags & CC_FULLOPEN || lpp->lpcc->Flags & CC_PREVENTFULLOPEN)
    {
-      hwnd = GetDlgItem(hDlg, 0x2cf);
+      hwnd = GetDlgItem(hDlg, IDC_COLOR_DEFINE);
       EnableWindow(hwnd, FALSE);
    }
    if (!(lpp->lpcc->Flags & CC_FULLOPEN ) || lpp->lpcc->Flags & CC_PREVENTFULLOPEN)
    {
       rect = lpp->fullsize;
       res = rect.bottom - rect.top;
-      hwnd = GetDlgItem(hDlg, 0x2c6); /* cut at left border */
+      hwnd = GetDlgItem(hDlg, IDC_COLOR_GRAPH); /* cut at left border */
       point.x = point.y = 0;
       ClientToScreen(hwnd, &point);
       ScreenToClient(hDlg,&point);
@@ -907,20 +911,20 @@
       point.x += GetSystemMetrics(SM_CXDLGFRAME);
       SetWindowPos(hDlg, 0, 0, 0, point.x, res, SWP_NOMOVE|SWP_NOZORDER);
 
-      for (i = 0x2bf; i < 0x2c5; i++)
+      for (i = IDC_COLOR_EDIT_H; i <= IDC_COLOR_EDIT_B; i++)
          ShowWindow( GetDlgItem(hDlg, i), SW_HIDE);
-      for (i = 0x2d3; i < 0x2d9; i++)
+      for (i = IDC_COLOR_HL; i <= IDC_COLOR_BL; i++)
          ShowWindow( GetDlgItem(hDlg, i), SW_HIDE);
-      ShowWindow( GetDlgItem(hDlg, 0x2c9), SW_HIDE);
-      ShowWindow( GetDlgItem(hDlg, 0x2c8), SW_HIDE);
-      ShowWindow( GetDlgItem(hDlg, 0x2c6), SW_HIDE);
-      ShowWindow( GetDlgItem(hDlg, 0x2c5), SW_HIDE);
+      ShowWindow( GetDlgItem(hDlg, IDC_COLOR_RES), SW_HIDE);
+      ShowWindow( GetDlgItem(hDlg, IDC_COLOR_ADD), SW_HIDE);
+      ShowWindow( GetDlgItem(hDlg, IDC_COLOR_GRAPH), SW_HIDE);
+      ShowWindow( GetDlgItem(hDlg, IDC_COLOR_RESULT), SW_HIDE);
       ShowWindow( GetDlgItem(hDlg, 1090 ), SW_HIDE);
    }
    else
-      CC_SwitchToFullSize(hDlg, lpp->lpcc->rgbResult, NULL);
+      CC_SwitchToFullSize(lpp, NULL);
    res = TRUE;
-   for (i = 0x2bf; i < 0x2c5; i++)
+   for (i = IDC_COLOR_EDIT_H; i <= IDC_COLOR_EDIT_B; i++)
      SendMessageA( GetDlgItem(hDlg, i), EM_LIMITTEXT, 3, 0);  /* max 3 digits:  xyz  */
    if (CC_HookCallChk(lpp->lpcc))
    {
@@ -932,21 +936,21 @@
    g = GetGValue(lpp->lpcc->rgbResult);
    b = GetBValue(lpp->lpcc->rgbResult);
 
-   CC_PaintSelectedColor(hDlg, lpp->lpcc->rgbResult);
-   lpp->h = CC_RGBtoHSL('H', r, g, b);
-   lpp->s = CC_RGBtoHSL('S', r, g, b);
-   lpp->l = CC_RGBtoHSL('L', r, g, b);
+   CC_PaintSelectedColor(lpp);
+   lpp->h = CC_RGBtoHSL('H', lpp->lpcc->rgbResult);
+   lpp->s = CC_RGBtoHSL('S', lpp->lpcc->rgbResult);
+   lpp->l = CC_RGBtoHSL('L', lpp->lpcc->rgbResult);
 
    /* Doing it the long way because CC_EditSetRGB/HSL doesn't seem to work */
-   SetDlgItemInt(hDlg, 703, lpp->h, TRUE);
-   SetDlgItemInt(hDlg, 704, lpp->s, TRUE);
-   SetDlgItemInt(hDlg, 705, lpp->l, TRUE);
-   SetDlgItemInt(hDlg, 706, r, TRUE);
-   SetDlgItemInt(hDlg, 707, g, TRUE);
-   SetDlgItemInt(hDlg, 708, b, TRUE);
+   SetDlgItemInt(hDlg, IDC_COLOR_EDIT_H, lpp->h, TRUE);
+   SetDlgItemInt(hDlg, IDC_COLOR_EDIT_S, lpp->s, TRUE);
+   SetDlgItemInt(hDlg, IDC_COLOR_EDIT_L, lpp->l, TRUE);
+   SetDlgItemInt(hDlg, IDC_COLOR_EDIT_R, r, TRUE);
+   SetDlgItemInt(hDlg, IDC_COLOR_EDIT_G, g, TRUE);
+   SetDlgItemInt(hDlg, IDC_COLOR_EDIT_B, b, TRUE);
 
-   CC_PaintCross(hDlg, lpp->h, lpp->s);
-   CC_PaintTriangle(hDlg, lpp->l);
+   CC_PaintCross(lpp);
+   CC_PaintTriangle(lpp);
 
    return res;
 }
@@ -955,20 +959,19 @@
 /***********************************************************************
  *                              CC_WMCommand                  [internal]
  */
-static LRESULT CC_WMCommand( HWND hDlg, WPARAM wParam, LPARAM lParam, WORD notifyCode, HWND hwndCtl )
+static LRESULT CC_WMCommand(CCPRIV *lpp, WPARAM wParam, LPARAM lParam, WORD notifyCode, HWND hwndCtl)
 {
     int  r, g, b, i, xx;
     UINT cokmsg;
     HDC hdc;
     COLORREF *cr;
-    LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
 
     TRACE("CC_WMCommand wParam=%lx lParam=%lx\n", wParam, lParam);
     switch (LOWORD(wParam))
     {
-          case 0x2c2:  /* edit notify RGB */
-	  case 0x2c3:
-	  case 0x2c4:
+        case IDC_COLOR_EDIT_R:  /* edit notify RGB */
+        case IDC_COLOR_EDIT_G:
+        case IDC_COLOR_EDIT_B:
 	       if (notifyCode == EN_UPDATE && !lpp->updating)
 			 {
 			   i = CC_CheckDigitsInEdit(hwndCtl, 255);
@@ -978,79 +981,73 @@
 			   xx = 0;
 			   switch (LOWORD(wParam))
 			   {
-			    case 0x2c2: if ((xx = (i != r))) r = i; break;
-			    case 0x2c3: if ((xx = (i != g))) g = i; break;
-			    case 0x2c4: if ((xx = (i != b))) b = i; break;
+			    case IDC_COLOR_EDIT_R: if ((xx = (i != r))) r = i; break;
+			    case IDC_COLOR_EDIT_G: if ((xx = (i != g))) g = i; break;
+			    case IDC_COLOR_EDIT_B: if ((xx = (i != b))) b = i; break;
 			   }
 			   if (xx) /* something has changed */
 			   {
 			    lpp->lpcc->rgbResult = RGB(r, g, b);
-			    CC_PaintSelectedColor(hDlg, lpp->lpcc->rgbResult);
-			    lpp->h = CC_RGBtoHSL('H', r, g, b);
-			    lpp->s = CC_RGBtoHSL('S', r, g, b);
-			    lpp->l = CC_RGBtoHSL('L', r, g, b);
-			    CC_EditSetHSL(hDlg, lpp->h, lpp->s, lpp->l);
-			    CC_PaintCross(hDlg, lpp->h, lpp->s);
-			    CC_PaintTriangle(hDlg, lpp->l);
+			    CC_PaintSelectedColor(lpp);
+			    lpp->h = CC_RGBtoHSL('H', lpp->lpcc->rgbResult);
+			    lpp->s = CC_RGBtoHSL('S', lpp->lpcc->rgbResult);
+			    lpp->l = CC_RGBtoHSL('L', lpp->lpcc->rgbResult);
+			    CC_EditSetHSL(lpp);
+			    CC_PaintCross(lpp);
+			    CC_PaintTriangle(lpp);
 			   }
 			 }
 		 break;
 
-	  case 0x2bf:  /* edit notify HSL */
-	  case 0x2c0:
-	  case 0x2c1:
+        case IDC_COLOR_EDIT_H:  /* edit notify HSL */
+        case IDC_COLOR_EDIT_S:
+        case IDC_COLOR_EDIT_L:
 	       if (notifyCode == EN_UPDATE && !lpp->updating)
 			 {
-			   i = CC_CheckDigitsInEdit(hwndCtl , LOWORD(wParam) == 0x2bf ? 239:240);
+			   i = CC_CheckDigitsInEdit(hwndCtl , LOWORD(wParam) == IDC_COLOR_EDIT_H ? 239 : 240);
 			   xx = 0;
 			   switch (LOWORD(wParam))
 			   {
-			    case 0x2bf: if ((xx = ( i != lpp->h))) lpp->h = i; break;
-			    case 0x2c0: if ((xx = ( i != lpp->s))) lpp->s = i; break;
-			    case 0x2c1: if ((xx = ( i != lpp->l))) lpp->l = i; break;
+			    case IDC_COLOR_EDIT_H: if ((xx = ( i != lpp->h))) lpp->h = i; break;
+			    case IDC_COLOR_EDIT_S: if ((xx = ( i != lpp->s))) lpp->s = i; break;
+			    case IDC_COLOR_EDIT_L: if ((xx = ( i != lpp->l))) lpp->l = i; break;
 			   }
 			   if (xx) /* something has changed */
 			   {
-			    r = CC_HSLtoRGB('R', lpp->h, lpp->s, lpp->l);
-			    g = CC_HSLtoRGB('G', lpp->h, lpp->s, lpp->l);
-			    b = CC_HSLtoRGB('B', lpp->h, lpp->s, lpp->l);
-			    lpp->lpcc->rgbResult = RGB(r, g, b);
-			    CC_PaintSelectedColor(hDlg, lpp->lpcc->rgbResult);
-			    CC_EditSetRGB(hDlg, lpp->lpcc->rgbResult);
-			    CC_PaintCross(hDlg, lpp->h, lpp->s);
-			    CC_PaintTriangle(hDlg, lpp->l);
+			    lpp->lpcc->rgbResult = CC_HSLtoRGB(lpp->h, lpp->s, lpp->l);
+			    CC_PaintSelectedColor(lpp);
+			    CC_EditSetRGB(lpp);
+			    CC_PaintCross(lpp);
+			    CC_PaintTriangle(lpp);
 			   }
 			 }
 	       break;
 
-          case 0x2cf:
-               CC_SwitchToFullSize(hDlg, lpp->lpcc->rgbResult, &lpp->fullsize);
-	       SetFocus( GetDlgItem(hDlg, 0x2bf));
+        case IDC_COLOR_DEFINE:
+               CC_SwitchToFullSize(lpp, &lpp->fullsize);
+	       SetFocus( GetDlgItem(lpp->hwndSelf, IDC_COLOR_EDIT_H));
 	       break;
 
-          case 0x2c8:    /* add colors ... column by column */
+        case IDC_COLOR_ADD:    /* add colors ... column by column */
                cr = lpp->lpcc->lpCustColors;
                cr[(lpp->nextuserdef % 2) * 8 + lpp->nextuserdef / 2] = lpp->lpcc->rgbResult;
                if (++lpp->nextuserdef == 16)
 		   lpp->nextuserdef = 0;
-	       CC_PaintUserColorArray(hDlg, 2, 8, lpp->lpcc->lpCustColors);
+	       CC_PaintUserColorArray(lpp, 2, 8);
 	       break;
 
-          case 0x2c9:              /* resulting color */
-	       hdc = GetDC(hDlg);
+        case IDC_COLOR_RES:              /* resulting color */
+	       hdc = GetDC(lpp->hwndSelf);
 	       lpp->lpcc->rgbResult = GetNearestColor(hdc, lpp->lpcc->rgbResult);
-	       ReleaseDC(hDlg, hdc);
-	       CC_EditSetRGB(hDlg, lpp->lpcc->rgbResult);
-	       CC_PaintSelectedColor(hDlg, lpp->lpcc->rgbResult);
-	       r = GetRValue(lpp->lpcc->rgbResult);
-	       g = GetGValue(lpp->lpcc->rgbResult);
-	       b = GetBValue(lpp->lpcc->rgbResult);
-	       lpp->h = CC_RGBtoHSL('H', r, g, b);
-	       lpp->s = CC_RGBtoHSL('S', r, g, b);
-	       lpp->l = CC_RGBtoHSL('L', r, g, b);
-	       CC_EditSetHSL(hDlg, lpp->h, lpp->s, lpp->l);
-	       CC_PaintCross(hDlg, lpp->h, lpp->s);
-	       CC_PaintTriangle(hDlg, lpp->l);
+	       ReleaseDC(lpp->hwndSelf, hdc);
+	       CC_EditSetRGB(lpp);
+	       CC_PaintSelectedColor(lpp);
+	       lpp->h = CC_RGBtoHSL('H', lpp->lpcc->rgbResult);
+	       lpp->s = CC_RGBtoHSL('S', lpp->lpcc->rgbResult);
+	       lpp->l = CC_RGBtoHSL('L', lpp->lpcc->rgbResult);
+	       CC_EditSetHSL(lpp);
+	       CC_PaintCross(lpp);
+	       CC_PaintTriangle(lpp);
 	       break;
 
 	  case 0x40e:           /* Help! */ /* The Beatles, 1965  ;-) */
@@ -1058,7 +1055,7 @@
                    if (lpp->lpcc->hwndOwner)
 		       SendMessageA(lpp->lpcc->hwndOwner, i, 0, (LPARAM)lpp->lpcc);
                    if ( CC_HookCallChk(lpp->lpcc))
-		       CallWindowProcA( (WNDPROC) lpp->lpcc->lpfnHook, hDlg,
+		       CallWindowProcA( (WNDPROC) lpp->lpcc->lpfnHook, lpp->hwndSelf,
 		          WM_COMMAND, psh15, (LPARAM)lpp->lpcc);
 	       break;
 
@@ -1067,11 +1064,11 @@
 		    if (lpp->lpcc->hwndOwner)
 			if (SendMessageA(lpp->lpcc->hwndOwner, cokmsg, 0, (LPARAM)lpp->lpcc))
 			break;    /* do NOT close */
-		EndDialog(hDlg, 1) ;
+		EndDialog(lpp->hwndSelf, 1) ;
 		return TRUE ;
 
 	  case IDCANCEL :
-		EndDialog(hDlg, 0) ;
+		EndDialog(lpp->hwndSelf, 0) ;
 		return TRUE ;
 
        }
@@ -1081,21 +1078,20 @@
 /***********************************************************************
  *                              CC_WMPaint                    [internal]
  */
-static LRESULT CC_WMPaint( HWND hDlg )
+static LRESULT CC_WMPaint( CCPRIV *lpp )
 {
     PAINTSTRUCT ps;
-    LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
 
-    BeginPaint(hDlg, &ps);
+    BeginPaint(lpp->hwndSelf, &ps);
     /* we have to paint dialog children except text and buttons */
-    CC_PaintPredefColorArray(hDlg, 6, 8);
-    CC_PaintUserColorArray(hDlg, 2, 8, lpp->lpcc->lpCustColors);
-    CC_PaintLumBar(hDlg, lpp->h, lpp->s);
-    CC_PaintTriangle(hDlg, lpp->l);
-    CC_PaintSelectedColor(hDlg, lpp->lpcc->rgbResult);
-    CC_PaintColorGraph(hDlg);
-    CC_PaintCross(hDlg, lpp->h, lpp->s);
-    EndPaint(hDlg, &ps);
+    CC_PaintPredefColorArray(lpp, 6, 8);
+    CC_PaintUserColorArray(lpp, 2, 8);
+    CC_PaintLumBar(lpp);
+    CC_PaintTriangle(lpp);
+    CC_PaintSelectedColor(lpp);
+    CC_PaintColorGraph(lpp);
+    CC_PaintCross(lpp);
+    EndPaint(lpp->hwndSelf, &ps);
 
     return TRUE;
 }
@@ -1103,15 +1099,13 @@
 /***********************************************************************
  *                              CC_WMLButtonUp              [internal]
  */
-static LRESULT CC_WMLButtonUp( HWND hDlg )
+static LRESULT CC_WMLButtonUp( CCPRIV *infoPtr )
 {
-   LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
-
-   if (lpp->capturedGraph)
+   if (infoPtr->capturedGraph)
    {
-       lpp->capturedGraph = 0;
+       infoPtr->capturedGraph = 0;
        ReleaseCapture();
-       CC_PaintCross(hDlg, lpp->h, lpp->s);
+       CC_PaintCross(infoPtr);
        return 1;
    }
    return 0;
@@ -1120,35 +1114,29 @@
 /***********************************************************************
  *                              CC_WMMouseMove              [internal]
  */
-static LRESULT CC_WMMouseMove( HWND hDlg, LPARAM lParam )
+static LRESULT CC_WMMouseMove( CCPRIV *infoPtr, LPARAM lParam )
 {
-   LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
-   int r, g, b;
-
-   if (lpp->capturedGraph)
+   if (infoPtr->capturedGraph)
    {
-      int *ptrh = NULL, *ptrs = &lpp->l;
-      if (lpp->capturedGraph == 0x2c6)
+      int *ptrh = NULL, *ptrs = &infoPtr->l;
+      if (infoPtr->capturedGraph == IDC_COLOR_GRAPH)
       {
-          ptrh = &lpp->h;
-          ptrs = &lpp->s;
+          ptrh = &infoPtr->h;
+          ptrs = &infoPtr->s;
       }
-      if (CC_MouseCheckColorGraph( hDlg, lpp->capturedGraph, ptrh, ptrs, lParam))
+      if (CC_MouseCheckColorGraph( infoPtr->hwndSelf, infoPtr->capturedGraph, ptrh, ptrs, lParam))
       {
-          r = CC_HSLtoRGB('R', lpp->h, lpp->s, lpp->l);
-          g = CC_HSLtoRGB('G', lpp->h, lpp->s, lpp->l);
-          b = CC_HSLtoRGB('B', lpp->h, lpp->s, lpp->l);
-          lpp->lpcc->rgbResult = RGB(r, g, b);
-          CC_EditSetRGB(hDlg, lpp->lpcc->rgbResult);
-          CC_EditSetHSL(hDlg,lpp->h, lpp->s, lpp->l);
-          CC_PaintCross(hDlg, lpp->h, lpp->s);
-          CC_PaintTriangle(hDlg, lpp->l);
-          CC_PaintSelectedColor(hDlg, lpp->lpcc->rgbResult);
+          infoPtr->lpcc->rgbResult = CC_HSLtoRGB(infoPtr->h, infoPtr->s, infoPtr->l);
+          CC_EditSetRGB(infoPtr);
+          CC_EditSetHSL(infoPtr);
+          CC_PaintCross(infoPtr);
+          CC_PaintTriangle(infoPtr);
+          CC_PaintSelectedColor(infoPtr);
       }
       else
       {
           ReleaseCapture();
-          lpp->capturedGraph = 0;
+          infoPtr->capturedGraph = 0;
       }
       return 1;
    }
@@ -1158,53 +1146,45 @@
 /***********************************************************************
  *                              CC_WMLButtonDown              [internal]
  */
-static LRESULT CC_WMLButtonDown( HWND hDlg, LPARAM lParam )
+static LRESULT CC_WMLButtonDown( CCPRIV *infoPtr, LPARAM lParam )
 {
-   LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
-   int r, g, b, i;
-   i = 0;
+   int i = 0;
 
-   if (CC_MouseCheckPredefColorArray(lpp, hDlg, 0x2d0, 6, 8, lParam))
+   if (CC_MouseCheckPredefColorArray(infoPtr, 6, 8, lParam))
       i = 1;
    else
-      if (CC_MouseCheckUserColorArray(lpp, hDlg, 0x2d1, 2, 8, lParam))
+      if (CC_MouseCheckUserColorArray(infoPtr, 2, 8, lParam))
          i = 1;
       else
-	 if (CC_MouseCheckColorGraph(hDlg, 0x2c6, &lpp->h, &lpp->s, lParam))
+	 if (CC_MouseCheckColorGraph(infoPtr->hwndSelf, IDC_COLOR_GRAPH, &infoPtr->h, &infoPtr->s, lParam))
          {
 	    i = 2;
-            lpp->capturedGraph = 0x2c6;
+            infoPtr->capturedGraph = IDC_COLOR_GRAPH;
          }
 	 else
-	    if (CC_MouseCheckColorGraph(hDlg, 0x2be, NULL, &lpp->l, lParam))
+	    if (CC_MouseCheckColorGraph(infoPtr->hwndSelf, IDC_COLOR_LUMBAR, NULL, &infoPtr->l, lParam))
             {
 	       i = 2;
-               lpp->capturedGraph = 0x2be;
+               infoPtr->capturedGraph = IDC_COLOR_LUMBAR;
             }
    if ( i == 2 )
    {
-      SetCapture(hDlg);
-      r = CC_HSLtoRGB('R', lpp->h, lpp->s, lpp->l);
-      g = CC_HSLtoRGB('G', lpp->h, lpp->s, lpp->l);
-      b = CC_HSLtoRGB('B', lpp->h, lpp->s, lpp->l);
-      lpp->lpcc->rgbResult = RGB(r, g, b);
+      SetCapture(infoPtr->hwndSelf);
+      infoPtr->lpcc->rgbResult = CC_HSLtoRGB(infoPtr->h, infoPtr->s, infoPtr->l);
    }
    if ( i == 1 )
    {
-      r = GetRValue(lpp->lpcc->rgbResult);
-      g = GetGValue(lpp->lpcc->rgbResult);
-      b = GetBValue(lpp->lpcc->rgbResult);
-      lpp->h = CC_RGBtoHSL('H', r, g, b);
-      lpp->s = CC_RGBtoHSL('S', r, g, b);
-      lpp->l = CC_RGBtoHSL('L', r, g, b);
+      infoPtr->h = CC_RGBtoHSL('H', infoPtr->lpcc->rgbResult);
+      infoPtr->s = CC_RGBtoHSL('S', infoPtr->lpcc->rgbResult);
+      infoPtr->l = CC_RGBtoHSL('L', infoPtr->lpcc->rgbResult);
    }
    if (i)
    {
-      CC_EditSetRGB(hDlg, lpp->lpcc->rgbResult);
-      CC_EditSetHSL(hDlg,lpp->h, lpp->s, lpp->l);
-      CC_PaintCross(hDlg, lpp->h, lpp->s);
-      CC_PaintTriangle(hDlg, lpp->l);
-      CC_PaintSelectedColor(hDlg, lpp->lpcc->rgbResult);
+      CC_EditSetRGB(infoPtr);
+      CC_EditSetHSL(infoPtr);
+      CC_PaintCross(infoPtr);
+      CC_PaintTriangle(infoPtr);
+      CC_PaintSelectedColor(infoPtr);
       return TRUE;
    }
    return FALSE;
@@ -1219,7 +1199,7 @@
 {
 
  int res;
- LPCCPRIV lpp = GetPropW( hDlg, szColourDialogProp );
+ CCPRIV *lpp = GetPropW( hDlg, szColourDialogProp );
 
  if (message != WM_INITDIALOG)
  {
@@ -1248,11 +1228,11 @@
                         RemovePropW( hDlg, szColourDialogProp );
 	                break;
 	  case WM_COMMAND:
-	                if (CC_WMCommand( hDlg, wParam, lParam, HIWORD(wParam), (HWND) lParam))
+	                if (CC_WMCommand(lpp, wParam, lParam, HIWORD(wParam), (HWND) lParam))
 	                   return TRUE;
 	                break;
 	  case WM_PAINT:
-	                if (CC_WMPaint(hDlg))
+	                if (CC_WMPaint(lpp))
 	                   return TRUE;
 	                break;
 	  case WM_LBUTTONDBLCLK:
@@ -1260,15 +1240,15 @@
 			  return TRUE;
 			break;
 	  case WM_MOUSEMOVE:
-	                if (CC_WMMouseMove(hDlg, lParam))
+	                if (CC_WMMouseMove(lpp, lParam))
 			  return TRUE;
 			break;
 	  case WM_LBUTTONUP:  /* FIXME: ClipCursor off (if in color graph)*/
-                        if (CC_WMLButtonUp(hDlg))
+                        if (CC_WMLButtonUp(lpp))
                            return TRUE;
 			break;
 	  case WM_LBUTTONDOWN:/* FIXME: ClipCursor on  (if in color graph)*/
-	                if (CC_WMLButtonDown(hDlg, lParam))
+	                if (CC_WMLButtonDown(lpp, lParam))
 	                   return TRUE;
 	                break;
 	}
@@ -1288,13 +1268,13 @@
  *  TRUE:  Ok button clicked.
  *  FALSE: Cancel button clicked, or error.
  */
-BOOL WINAPI ChooseColorW( LPCHOOSECOLORW lpChCol )
+BOOL WINAPI ChooseColorW( CHOOSECOLORW *lpChCol )
 {
     HANDLE hDlgTmpl = 0;
-    BOOL bRet = FALSE;
-    LPCVOID template;
+    const void *template;
+
+    TRACE("(%p)\n", lpChCol);
 
-    TRACE("ChooseColor\n");
     if (!lpChCol) return FALSE;
 
     if (lpChCol->Flags & CC_ENABLETEMPLATEHANDLE)
@@ -1340,9 +1320,8 @@
 	}
     }
 
-    bRet = DialogBoxIndirectParamW(COMDLG32_hInstance, template, lpChCol->hwndOwner,
+    return DialogBoxIndirectParamW(COMDLG32_hInstance, template, lpChCol->hwndOwner,
                      ColorDlgProc, (LPARAM)lpChCol);
-    return bRet;
 }
 
 /***********************************************************************
diff -urN wine-1.5.30/dlls/comdlg32/comdlg32.rc wine-multimedia/dlls/comdlg32/comdlg32.rc
--- wine-1.5.30/dlls/comdlg32/comdlg32.rc	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comdlg32/comdlg32.rc	2013-05-17 10:44:20.517235889 +0300
@@ -279,29 +279,29 @@
  LTEXT "&Basic Colors:",   stc1, 4,    4,  140, 10
  LTEXT "&Custom Colors:",  stc2, 4,   106, 140, 10
  LTEXT "Color |  Sol&id",  stc3, 150, 151,  48, 10
- LTEXT   "&Red:", 726 /*1094*/,247,126,27,10
- EDITTEXT 706, 275,124,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
- LTEXT   "&Green:",727/*1095*/,247,140,27,10
- EDITTEXT 707, 275,138,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
- LTEXT   "&Blue:",728 /*1096*/,247,154,27,10
- EDITTEXT 708, 275,152,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
- LTEXT  "&Hue:" ,723 /*1091*/,200,126,24,10
- EDITTEXT 703, 224,124,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
- LTEXT  "#msgctxt#Saturation#&Sat:" ,724 /*1092*/,200,140,24,10
- EDITTEXT 704, 224,138,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
- LTEXT  "#msgctxt#Luminance#&Lum:" ,725 /*1093*/,200,154,24,10
- EDITTEXT 705, 224,152,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
- CONTROL "" ,720,"STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP,4,14,140,86
- CONTROL "" ,721,"STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP,4,116,140,28
- CONTROL "" ,710,"STATIC",WS_BORDER|SS_SIMPLE|WS_TABSTOP|WS_GROUP, 152,4,118,116
- CONTROL "" ,702,"STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP, 278,4,8,116
- CONTROL "" ,709,"STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP, 152,124,40,26
+ LTEXT   "&Red:", IDC_COLOR_RL /*1094*/,247,126,27,10
+ EDITTEXT IDC_COLOR_EDIT_R, 275,124,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
+ LTEXT   "&Green:", IDC_COLOR_GL /*1095*/,247,140,27,10
+ EDITTEXT IDC_COLOR_EDIT_G, 275,138,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
+ LTEXT   "&Blue:", IDC_COLOR_BL /*1096*/,247,154,27,10
+ EDITTEXT IDC_COLOR_EDIT_B, 275,152,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
+ LTEXT  "&Hue:" , IDC_COLOR_HL /*1091*/,200,126,24,10
+ EDITTEXT IDC_COLOR_EDIT_H, 224,124,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
+ LTEXT  "#msgctxt#Saturation#&Sat:", IDC_COLOR_SL /*1092*/,200,140,24,10
+ EDITTEXT IDC_COLOR_EDIT_S, 224,138,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
+ LTEXT  "#msgctxt#Luminance#&Lum:", IDC_COLOR_LL /*1093*/,200,154,24,10
+ EDITTEXT IDC_COLOR_EDIT_L, 224,152,21,12, WS_BORDER | WS_GROUP | WS_TABSTOP
+ CONTROL "" , IDC_COLOR_PREDEF, "STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP,4,14,140,86
+ CONTROL "" , IDC_COLOR_USRDEF, "STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP,4,116,140,28
+ CONTROL "" , IDC_COLOR_GRAPH, "STATIC",WS_BORDER|SS_SIMPLE|WS_TABSTOP|WS_GROUP, 152,4,118,116
+ CONTROL "" , IDC_COLOR_LUMBAR, "STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP, 278,4,8,116
+ CONTROL "" , IDC_COLOR_RESULT, "STATIC",SS_SIMPLE|WS_TABSTOP|WS_GROUP, 152,124,40,26
  DEFPUSHBUTTON "OK",  IDOK,  4, 167, 50, 14, BS_DEFPUSHBUTTON | WS_GROUP | WS_TABSTOP
  PUSHBUTTON "Cancel", IDCANCEL, 58, 167, 50, 14, WS_GROUP | WS_TABSTOP
  PUSHBUTTON "Help", pshHelp,100,166, 44, 14
- PUSHBUTTON "&Add to Custom Colors",    712/*1024*/, 152, 167, 144, 14, WS_GROUP | WS_TABSTOP
- PUSHBUTTON "&Define Custom Colors >>", 719/*1025*/,   4, 149, 142, 14, WS_GROUP | WS_TABSTOP
- PUSHBUTTON "Color |  Sol&id",713,300,200,4,14   /* just a dummy */
+ PUSHBUTTON "&Add to Custom Colors",    IDC_COLOR_ADD /*1024*/, 152, 167, 144, 14, WS_GROUP | WS_TABSTOP
+ PUSHBUTTON "&Define Custom Colors >>", IDC_COLOR_DEFINE /*1025*/,   4, 149, 142, 14, WS_GROUP | WS_TABSTOP
+ PUSHBUTTON "Color |  Sol&id", IDC_COLOR_RES, 300,200,4,14   /* just a dummy */
 }
 
 
diff -urN wine-1.5.30/dlls/comdlg32/tests/printdlg.c wine-multimedia/dlls/comdlg32/tests/printdlg.c
--- wine-1.5.30/dlls/comdlg32/tests/printdlg.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/comdlg32/tests/printdlg.c	2013-05-17 10:44:20.527235764 +0300
@@ -255,7 +255,7 @@
         ok(pDlg->nCopies == 1234 || broken(pDlg->nCopies == 1), "expected nCopies 1234, got %d\n", pDlg->nCopies);
         ok(pDlg->hDevMode != 0, "hDevMode should not be 0\n");
         dm = GlobalLock(pDlg->hDevMode);
-        ok(dm->dmCopies == 1, "expected dm->dmCopies 1, got %d\n", dm->dmCopies);
+        ok(S1(U1(*dm)).dmCopies == 1, "expected dm->dmCopies 1, got %d\n", S1(U1(*dm)).dmCopies);
         GlobalUnlock(pDlg->hDevMode);
         GlobalFree(pDlg->hDevMode);
         GlobalFree(pDlg->hDevNames);
@@ -269,7 +269,7 @@
         ok(pDlg->nCopies == 1, "expected nCopies 1, got %d\n", pDlg->nCopies);
         ok(pDlg->hDevMode != 0, "hDevMode should not be 0\n");
         dm = GlobalLock(pDlg->hDevMode);
-        ok(dm->dmCopies == 1234, "expected dm->dmCopies 1234, got %d\n", dm->dmCopies);
+        ok(S1(U1(*dm)).dmCopies == 1234, "expected dm->dmCopies 1234, got %d\n", S1(U1(*dm)).dmCopies);
         GlobalUnlock(pDlg->hDevMode);
         GlobalFree(pDlg->hDevMode);
         GlobalFree(pDlg->hDevNames);
diff -urN wine-1.5.30/dlls/credui/credui_main.c wine-multimedia/dlls/credui/credui_main.c
--- wine-1.5.30/dlls/credui/credui_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/credui/credui_main.c	2013-05-17 10:44:20.531235713 +0300
@@ -80,6 +80,7 @@
         break;
 
     case DLL_PROCESS_DETACH:
+        if (lpvReserved) break;
         LIST_FOR_EACH_ENTRY_SAFE(entry, cursor2, &pending_credentials_list, struct pending_credentials, entry)
         {
             list_remove(&entry->entry);
diff -urN wine-1.5.30/dlls/crypt32/main.c wine-multimedia/dlls/crypt32/main.c
--- wine-1.5.30/dlls/crypt32/main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/crypt32/main.c	2013-05-17 10:44:20.540235601 +0300
@@ -45,14 +45,12 @@
             crypt_oid_init();
             break;
         case DLL_PROCESS_DETACH:
+            if (pvReserved) break;
             crypt_oid_free();
             crypt_sip_free();
             root_store_free();
             default_chain_engine_free();
-            /* Don't release the default provider on process shutdown, there's
-             * no guarantee the provider dll hasn't already been unloaded.
-             */
-            if (hDefProv && !pvReserved) CryptReleaseContext(hDefProv, 0);
+            if (hDefProv) CryptReleaseContext(hDefProv, 0);
             break;
     }
     return TRUE;
diff -urN wine-1.5.30/dlls/d3dcompiler_43/compiler.c wine-multimedia/dlls/d3dcompiler_43/compiler.c
--- wine-1.5.30/dlls/d3dcompiler_43/compiler.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3dcompiler_43/compiler.c	2013-05-17 10:44:20.601234838 +0300
@@ -490,6 +490,103 @@
     return hr;
 }
 
+struct target_info {
+    const char *name;
+    enum shader_type type;
+    DWORD sm_major;
+    DWORD sm_minor;
+    DWORD level_major;
+    DWORD level_minor;
+    BOOL sw;
+    BOOL support;
+};
+
+/* Must be kept sorted for binary search */
+static const struct target_info targets_info[] = {
+    { "cs_4_0",            ST_UNKNOWN, 4, 0, 0, 0, FALSE, FALSE },
+    { "cs_4_1",            ST_UNKNOWN, 4, 1, 0, 0, FALSE, FALSE },
+    { "cs_5_0",            ST_UNKNOWN, 5, 0, 0, 0, FALSE, FALSE },
+    { "ds_5_0",            ST_UNKNOWN, 5, 0, 0, 0, FALSE, FALSE },
+    { "fx_2_0",            ST_UNKNOWN, 2, 0, 0, 0, FALSE, FALSE },
+    { "fx_4_0",            ST_UNKNOWN, 4, 0, 0, 0, FALSE, FALSE },
+    { "fx_4_1",            ST_UNKNOWN, 4, 1, 0, 0, FALSE, FALSE },
+    { "fx_5_0",            ST_UNKNOWN, 5, 0, 0, 0, FALSE, FALSE },
+    { "gs_4_0",            ST_UNKNOWN, 4, 0, 0, 0, FALSE, FALSE },
+    { "gs_4_1",            ST_UNKNOWN, 4, 1, 0, 0, FALSE, FALSE },
+    { "gs_5_0",            ST_UNKNOWN, 5, 0, 0, 0, FALSE, FALSE },
+    { "hs_5_0",            ST_UNKNOWN, 5, 0, 0, 0, FALSE, FALSE },
+    { "ps.1.0",            ST_PIXEL,   1, 0, 0, 0, FALSE, TRUE  },
+    { "ps.1.1",            ST_PIXEL,   1, 1, 0, 0, FALSE, FALSE },
+    { "ps.1.2",            ST_PIXEL,   1, 2, 0, 0, FALSE, FALSE },
+    { "ps.1.3",            ST_PIXEL,   1, 3, 0, 0, FALSE, FALSE },
+    { "ps.1.4",            ST_PIXEL,   1, 4, 0, 0, FALSE, FALSE },
+    { "ps.2.0",            ST_PIXEL,   2, 0, 0, 0, FALSE, TRUE  },
+    { "ps.2.a",            ST_PIXEL,   2, 1, 0, 0, FALSE, FALSE },
+    { "ps.2.b",            ST_PIXEL,   2, 2, 0, 0, FALSE, FALSE },
+    { "ps.2.sw",           ST_PIXEL,   2, 0, 0, 0, TRUE,  FALSE },
+    { "ps.3.0",            ST_PIXEL,   3, 0, 0, 0, FALSE, TRUE  },
+    { "ps_1_0",            ST_PIXEL,   1, 0, 0, 0, FALSE, TRUE  },
+    { "ps_1_1",            ST_PIXEL,   1, 1, 0, 0, FALSE, FALSE },
+    { "ps_1_2",            ST_PIXEL,   1, 2, 0, 0, FALSE, FALSE },
+    { "ps_1_3",            ST_PIXEL,   1, 3, 0, 0, FALSE, FALSE },
+    { "ps_1_4",            ST_PIXEL,   1, 4, 0, 0, FALSE, FALSE },
+    { "ps_2_0",            ST_PIXEL,   2, 0, 0, 0, FALSE, TRUE  },
+    { "ps_2_a",            ST_PIXEL,   2, 1, 0, 0, FALSE, FALSE },
+    { "ps_2_b",            ST_PIXEL,   2, 2, 0, 0, FALSE, FALSE },
+    { "ps_2_sw",           ST_PIXEL,   2, 0, 0, 0, TRUE,  FALSE },
+    { "ps_3_0",            ST_PIXEL,   3, 0, 0, 0, FALSE, TRUE  },
+    { "ps_3_sw",           ST_PIXEL,   3, 0, 0, 0, TRUE,  FALSE },
+    { "ps_4_0",            ST_PIXEL,   4, 0, 0, 0, FALSE, TRUE  },
+    { "ps_4_0_level_9_0",  ST_PIXEL,   4, 0, 9, 0, FALSE, FALSE },
+    { "ps_4_0_level_9_1",  ST_PIXEL,   4, 0, 9, 1, FALSE, FALSE },
+    { "ps_4_0_level_9_3",  ST_PIXEL,   4, 0, 9, 3, FALSE, FALSE },
+    { "ps_4_1",            ST_PIXEL,   4, 1, 0, 0, FALSE, TRUE  },
+    { "ps_5_0",            ST_PIXEL,   5, 0, 0, 0, FALSE, TRUE  },
+    { "tx_1_0",            ST_UNKNOWN, 1, 0, 0, 0, FALSE, FALSE },
+    { "vs.1.0",            ST_VERTEX,  1, 0, 0, 0, FALSE, TRUE  },
+    { "vs.1.1",            ST_VERTEX,  1, 1, 0, 0, FALSE, TRUE  },
+    { "vs.2.0",            ST_VERTEX,  2, 0, 0, 0, FALSE, TRUE  },
+    { "vs.2.a",            ST_VERTEX,  2, 1, 0, 0, FALSE, FALSE },
+    { "vs.2.sw",           ST_VERTEX,  2, 0, 0, 0, TRUE,  FALSE },
+    { "vs.3.0",            ST_VERTEX,  3, 0, 0, 0, FALSE, TRUE  },
+    { "vs.3.sw",           ST_VERTEX,  3, 0, 0, 0, TRUE,  FALSE },
+    { "vs_1_0",            ST_VERTEX,  1, 0, 0, 0, FALSE, TRUE  },
+    { "vs_1_1",            ST_VERTEX,  1, 1, 0, 0, FALSE, TRUE  },
+    { "vs_2_0",            ST_VERTEX,  2, 0, 0, 0, FALSE, TRUE  },
+    { "vs_2_a",            ST_VERTEX,  2, 1, 0, 0, FALSE, FALSE },
+    { "vs_2_sw",           ST_VERTEX,  2, 0, 0, 0, TRUE,  FALSE },
+    { "vs_3_0",            ST_VERTEX,  3, 0, 0, 0, FALSE, TRUE  },
+    { "vs_3_sw",           ST_VERTEX,  3, 0, 0, 0, TRUE,  FALSE },
+    { "vs_4_0",            ST_VERTEX,  4, 0, 0, 0, FALSE, TRUE  },
+    { "vs_4_0_level_9_0",  ST_VERTEX,  4, 0, 9, 0, FALSE, FALSE },
+    { "vs_4_0_level_9_1",  ST_VERTEX,  4, 0, 9, 1, FALSE, FALSE },
+    { "vs_4_0_level_9_3",  ST_VERTEX,  4, 0, 9, 3, FALSE, FALSE },
+    { "vs_4_1",            ST_VERTEX,  4, 1, 0, 0, FALSE, TRUE  },
+    { "vs_5_0",            ST_VERTEX,  5, 0, 0, 0, FALSE, TRUE  },
+};
+
+static const struct target_info * get_target_info(const char *target)
+{
+    LONG min = 0;
+    LONG max = sizeof(targets_info) / sizeof(targets_info[0]) - 1;
+    LONG cur;
+    int res;
+
+    while (min <= max)
+    {
+        cur = (min + max) / 2;
+        res = strcmp(target, targets_info[cur].name);
+        if (res < 0)
+            max = cur - 1;
+        else if (res > 0)
+            min = cur + 1;
+        else
+            return &targets_info[cur];
+    }
+
+    return NULL;
+}
+
 static HRESULT compile_shader(const char *preproc_shader, const char *target, const char *entrypoint,
         ID3DBlob **shader_blob, ID3DBlob **error_messages)
 {
@@ -500,38 +597,32 @@
     ID3DBlob *buffer;
     char *pos;
     enum shader_type shader_type;
+    const struct target_info *info;
 
     TRACE("Preprocessed shader source: %s\n", debugstr_a(preproc_shader));
 
-    TRACE("Parsing compilation target %s.\n", debugstr_a(target));
-    if (strlen(target) != 6 || target[1] != 's' || target[2] != '_' || target[4] != '_')
+    TRACE("Checking compilation target %s\n", debugstr_a(target));
+    info = get_target_info(target);
+    if (!info)
     {
-        FIXME("Unknown compilation target %s.\n", debugstr_a(target));
+        FIXME("Unknown compilation target %s\n", debugstr_a(target));
         return D3DERR_INVALIDCALL;
     }
-
-    if (target[0] == 'v')
-        shader_type = ST_VERTEX;
-    else if (target[0] == 'p')
-        shader_type = ST_PIXEL;
     else
     {
-        FIXME("Unsupported shader target type %s.\n", debugstr_a(target));
-        return D3DERR_INVALIDCALL;
+        if (!info->support)
+        {
+            FIXME("Compilation target %s not yet supported\n", debugstr_a(target));
+            return D3DERR_INVALIDCALL;
+        }
+        else
+        {
+            shader_type = info->type;
+            major = info->sm_major;
+            minor = info->sm_minor;
+        }
     }
 
-    major = target[3] - '0';
-    if (major == 0 || major > 5)
-    {
-        FIXME("Unsupported shader target major version %d.\n", major);
-        return D3DERR_INVALIDCALL;
-    }
-    minor = target[5] - '0';
-    if (minor > 1 || (minor == 1 && (shader_type != ST_VERTEX || major > 1)))
-    {
-        FIXME("Unsupported shader target minor version %d.\n", minor);
-        return D3DERR_INVALIDCALL;
-    }
     shader = parse_hlsl_shader(preproc_shader, shader_type, major, minor, entrypoint, &messages);
 
     if (messages)
@@ -631,6 +722,9 @@
     HRESULT hr;
     ID3DBlob *buffer;
 
+    TRACE("data %p, size %lu, filename %s, defines %p, include %p, shader %p, error_messages %p\n",
+          data, size, debugstr_a(filename), defines, include, shader, error_messages);
+
     if (!data)
         return E_INVALIDARG;
 
diff -urN wine-1.5.30/dlls/d3dcompiler_43/d3dcompiler_private.h wine-multimedia/dlls/d3dcompiler_43/d3dcompiler_private.h
--- wine-1.5.30/dlls/d3dcompiler_43/d3dcompiler_private.h	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3dcompiler_43/d3dcompiler_private.h	2013-05-17 10:44:20.601234838 +0300
@@ -49,8 +49,9 @@
 
 enum shader_type
 {
+    ST_UNKNOWN,
     ST_VERTEX,
-    ST_PIXEL,
+    ST_PIXEL
 };
 
 typedef enum BWRITER_COMPARISON_TYPE {
diff -urN wine-1.5.30/dlls/d3drm/meshbuilder.c wine-multimedia/dlls/d3drm/meshbuilder.c
--- wine-1.5.30/dlls/d3drm/meshbuilder.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3drm/meshbuilder.c	2013-05-17 10:44:20.610234726 +0300
@@ -2379,22 +2379,28 @@
 }
 
 static HRESULT WINAPI IDirect3DRMMeshBuilder3Impl_GetNormals(IDirect3DRMMeshBuilder3 *iface,
-        DWORD IndexFirst, DWORD *count, D3DVECTOR *vector)
+        DWORD IndexFirst, DWORD *ncount, D3DVECTOR *normals)
 {
     IDirect3DRMMeshBuilderImpl *This = impl_from_IDirect3DRMMeshBuilder3(iface);
+    DWORD count = This->nb_normals - IndexFirst;
 
-    FIXME("(%p)->(%u,%p,%p): stub\n", This, IndexFirst, count, vector);
+    TRACE("(%p)->(%u,%p,%p)\n", This, IndexFirst, ncount, normals);
 
-    return E_NOTIMPL;
+    if (ncount)
+        *ncount = count;
+    if (normals && This->nb_normals)
+        memcpy(normals, This->pNormals + IndexFirst, count * sizeof(D3DVECTOR));
+
+    return D3DRM_OK;
 }
 
 static int WINAPI IDirect3DRMMeshBuilder3Impl_GetNormalCount(IDirect3DRMMeshBuilder3* iface)
 {
     IDirect3DRMMeshBuilderImpl *This = impl_from_IDirect3DRMMeshBuilder3(iface);
 
-    FIXME("(%p)->(): stub\n", This);
+    TRACE("(%p)->()\n", This);
 
-    return E_NOTIMPL;
+    return This->nb_normals;
 }
 
 static const struct IDirect3DRMMeshBuilder3Vtbl Direct3DRMMeshBuilder3_Vtbl =
diff -urN wine-1.5.30/dlls/d3drm/tests/d3drm.c wine-multimedia/dlls/d3drm/tests/d3drm.c
--- wine-1.5.30/dlls/d3drm/tests/d3drm.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3drm/tests/d3drm.c	2013-05-17 10:44:20.611234713 +0300
@@ -677,6 +677,8 @@
     IDirect3DRMFace *face1;
     IDirect3DRMFace2 *face2;
     IDirect3DRMFaceArray *array1;
+    D3DRMLOADMEMORY info;
+    D3DVECTOR v1[4], n1[4], v2[4], n2[4];
     DWORD count;
     CHAR cname[64] = {0};
     int icount;
@@ -812,6 +814,88 @@
     icount = IDirect3DRMFace2_GetVertexCount(face2);
     ok(!icount, "wrong VertexCount: %i\n", icount);
 
+    info.lpMemory = data_ok;
+    info.dSize = strlen(data_ok);
+    hr = IDirect3DRMMeshBuilder3_Load(MeshBuilder3, &info, NULL, D3DRMLOAD_FROMMEMORY, NULL, NULL);
+    ok(hr == D3DRM_OK, "Cannot load mesh data (hr = %x)\n", hr);
+
+    icount = IDirect3DRMMeshBuilder3_GetVertexCount(MeshBuilder3);
+    ok(icount == 4, "Wrong number of vertices %d (must be 4)\n", icount);
+
+    icount = IDirect3DRMMeshBuilder3_GetNormalCount(MeshBuilder3);
+    ok(icount == 4, "Wrong number of normals %d (must be 4)\n", icount);
+
+    icount = IDirect3DRMMeshBuilder3_GetFaceCount(MeshBuilder3);
+    todo_wine
+    ok(icount == 4, "Wrong number of faces %d (must be 4)\n", icount);
+
+    count = 4;
+    hr = IDirect3DRMMeshBuilder3_GetVertices(MeshBuilder3, 0, &count, v1);
+    ok(hr == D3DRM_OK, "Cannot get vertices information (hr = %x)\n", hr);
+    ok(count == 4, "Wrong number of vertices %d (must be 4)\n", count);
+
+    hr = IDirect3DRMMeshBuilder3_GetNormals(MeshBuilder3, 0, &count, n1);
+    ok(hr == D3DRM_OK, "Cannot get normals information (hr = %x)\n", hr);
+    ok(count == 4, "Wrong number of normals %d (must be 4)\n", count);
+
+    array1 = NULL;
+    hr = IDirect3DRMMeshBuilder3_GetFaces(MeshBuilder3, &array1);
+    todo_wine
+    ok(hr == D3DRM_OK, "Cannot get FaceArray (hr = %x)\n", hr);
+    todo_wine
+    ok(array1 != NULL, "pArray = %p\n", array1);
+    if (array1)
+    {
+        IDirect3DRMFace *face;
+        count = IDirect3DRMFaceArray_GetSize(array1);
+        ok(count == 4, "count = %u\n", count);
+        hr = IDirect3DRMFaceArray_GetElement(array1, 1, &face);
+        ok(hr == D3DRM_OK, "Cannot get face (hr = %x)\n", hr);
+        IDirect3DRMFace_GetVertices(face, &count, v2, n2);
+        ok(hr == D3DRM_OK, "Cannot get vertices information (hr = %x)\n", hr);
+        ok(count == 3, "Wrong number of vertices %d (must be 3)\n", count);
+        ok(U1(v2[0]).x == U1(v1[0]).x, "Wrong component v2[0].x = %f (expected %f)\n",
+           U1(v2[0]).x, U1(v1[0]).x);
+        ok(U1(v2[0]).y == U1(v1[0]).y, "Wrong component v2[0].y = %f (expected %f)\n",
+           U1(v2[0]).y, U1(v1[0]).y);
+        ok(U1(v2[0]).z == U1(v1[0]).z, "Wrong component v2[0].z = %f (expected %f)\n",
+           U1(v2[0]).z, U1(v1[0]).z);
+        ok(U1(v2[1]).x == U1(v1[1]).x, "Wrong component v2[1].x = %f (expected %f)\n",
+           U1(v2[1]).x, U1(v1[1]).x);
+        ok(U1(v2[1]).y == U1(v1[1]).y, "Wrong component v2[1].y = %f (expected %f)\n",
+           U1(v2[1]).y, U1(v1[1]).y);
+        ok(U1(v2[1]).z == U1(v1[1]).z, "Wrong component v2[1].z = %f (expected %f)\n",
+           U1(v2[1]).z, U1(v1[1]).z);
+        ok(U1(v2[2]).x == U1(v1[2]).x, "Wrong component v2[2].x = %f (expected %f)\n",
+           U1(v2[2]).x, U1(v1[2]).x);
+        ok(U1(v2[2]).y == U1(v1[2]).y, "Wrong component v2[2].y = %f (expected %f)\n",
+           U1(v2[2]).y, U1(v1[2]).y);
+        ok(U1(v2[2]).z == U1(v1[2]).z, "Wrong component v2[2].z = %f (expected %f)\n",
+           U1(v2[2]).z, U1(v1[2]).z);
+
+        ok(U1(n2[0]).x == U1(n1[0]).x, "Wrong component n2[0].x = %f (expected %f)\n",
+           U1(n2[0]).x, U1(n1[0]).x);
+        ok(U1(n2[0]).y == U1(n1[0]).y, "Wrong component n2[0].y = %f (expected %f)\n",
+           U1(n2[0]).y, U1(n1[0]).y);
+        ok(U1(n2[0]).z == U1(n1[0]).z, "Wrong component n2[0].z = %f (expected %f)\n",
+           U1(n2[0]).z, U1(n1[0]).z);
+        ok(U1(n2[1]).x == U1(n1[1]).x, "Wrong component n2[1].x = %f (expected %f)\n",
+           U1(n2[1]).x, U1(n1[1]).x);
+        ok(U1(n2[1]).y == U1(n1[1]).y, "Wrong component n2[1].y = %f (expected %f)\n",
+           U1(n2[1]).y, U1(n1[1]).y);
+        ok(U1(n2[1]).z == U1(n1[1]).z, "Wrong component n2[1].z = %f (expected %f)\n",
+           U1(n2[1]).z, U1(n1[1]).z);
+        ok(U1(n2[2]).x == U1(n1[2]).x, "Wrong component n2[2].x = %f (expected %f)\n",
+           U1(n2[2]).x, U1(n1[2]).x);
+        ok(U1(n2[2]).y == U1(n1[2]).y, "Wrong component n2[2].y = %f (expected %f)\n",
+           U1(n2[2]).y, U1(n1[2]).y);
+        ok(U1(n2[2]).z == U1(n1[2]).z, "Wrong component n2[2].z = %f (expected %f)\n",
+           U1(n2[2]).z, U1(n1[2]).z);
+
+        IDirect3DRMFace_Release(face);
+        IDirect3DRMFaceArray_Release(array1);
+    }
+
     IDirect3DRMFace2_Release(face2);
     IDirect3DRMMeshBuilder3_Release(MeshBuilder3);
     IDirect3DRM3_Release(d3drm3);
diff -urN wine-1.5.30/dlls/d3dx9_36/surface.c wine-multimedia/dlls/d3dx9_36/surface.c
--- wine-1.5.30/dlls/d3dx9_36/surface.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3dx9_36/surface.c	2013-05-17 10:44:20.626234526 +0300
@@ -37,9 +37,9 @@
     const GUID *wic_guid;
     D3DFORMAT d3dformat;
 } wic_pixel_formats[] = {
-    { &GUID_WICPixelFormat8bppIndexed, D3DFMT_L8 },
-    { &GUID_WICPixelFormat1bppIndexed, D3DFMT_L8 },
-    { &GUID_WICPixelFormat4bppIndexed, D3DFMT_L8 },
+    { &GUID_WICPixelFormat8bppIndexed, D3DFMT_P8 },
+    { &GUID_WICPixelFormat1bppIndexed, D3DFMT_P8 },
+    { &GUID_WICPixelFormat4bppIndexed, D3DFMT_P8 },
     { &GUID_WICPixelFormat16bppBGR555, D3DFMT_X1R5G5B5 },
     { &GUID_WICPixelFormat16bppBGR565, D3DFMT_R5G6B5 },
     { &GUID_WICPixelFormat24bppBGR, D3DFMT_R8G8B8 },
diff -urN wine-1.5.30/dlls/d3dx9_36/tests/surface.c wine-multimedia/dlls/d3dx9_36/tests/surface.c
--- wine-1.5.30/dlls/d3dx9_36/tests/surface.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3dx9_36/tests/surface.c	2013-05-17 10:44:20.636234401 +0300
@@ -481,17 +481,17 @@
     hr = D3DXGetImageInfoFromFileInMemory(bmp_1bpp, sizeof(bmp_1bpp), &info);
     ok(hr == D3D_OK, "D3DXGetImageInfoFromFileInMemory returned %#x, expected %#x\n", hr, D3D_OK);
     ok(info.Depth == 1, "Got depth %u, expected 1\n", info.Depth);
-    todo_wine ok(info.Format == D3DFMT_P8, "Got format %u, expected %u\n", info.Format, D3DFMT_P8);
+    ok(info.Format == D3DFMT_P8, "Got format %u, expected %u\n", info.Format, D3DFMT_P8);
     hr = D3DXGetImageInfoFromFileInMemory(bmp_2bpp, sizeof(bmp_2bpp), &info);
     ok(hr == D3DXERR_INVALIDDATA, "D3DXGetImageInfoFromFileInMemory returned %#x, expected %#x\n", hr, D3DXERR_INVALIDDATA);
     hr = D3DXGetImageInfoFromFileInMemory(bmp_4bpp, sizeof(bmp_4bpp), &info);
     ok(hr == D3D_OK, "D3DXGetImageInfoFromFileInMemory returned %#x, expected %#x\n", hr, D3D_OK);
     ok(info.Depth == 1, "Got depth %u, expected 1\n", info.Depth);
-    todo_wine ok(info.Format == D3DFMT_P8, "Got format %u, expected %u\n", info.Format, D3DFMT_P8);
+    ok(info.Format == D3DFMT_P8, "Got format %u, expected %u\n", info.Format, D3DFMT_P8);
     hr = D3DXGetImageInfoFromFileInMemory(bmp_8bpp, sizeof(bmp_8bpp), &info);
     ok(hr == D3D_OK, "D3DXGetImageInfoFromFileInMemory returned %#x, expected %#x\n", hr, D3D_OK);
     ok(info.Depth == 1, "Got depth %u, expected 1\n", info.Depth);
-    todo_wine ok(info.Format == D3DFMT_P8, "Got format %u, expected %u\n", info.Format, D3DFMT_P8);
+    ok(info.Format == D3DFMT_P8, "Got format %u, expected %u\n", info.Format, D3DFMT_P8);
 
     /* test DDS support */
     hr = D3DXGetImageInfoFromFileInMemory(dds_24bit, sizeof(dds_24bit), &info);
@@ -646,7 +646,7 @@
     /* D3DXLoadSurfaceFromFile */
     if(testbitmap_ok) {
         hr = D3DXLoadSurfaceFromFileA(surf, NULL, NULL, "testbitmap.bmp", NULL, D3DX_DEFAULT, 0, NULL);
-        ok(hr == D3D_OK, "D3DXLoadSurfaceFromFile returned %#x, expected %#x\n", hr, D3D_OK);
+        todo_wine ok(hr == D3D_OK, "D3DXLoadSurfaceFromFile returned %#x, expected %#x\n", hr, D3D_OK);
 
         hr = D3DXLoadSurfaceFromFileA(NULL, NULL, NULL, "testbitmap.bmp", NULL, D3DX_DEFAULT, 0, NULL);
         ok(hr == D3DERR_INVALIDCALL, "D3DXLoadSurfaceFromFile returned %#x, expected %#x\n", hr, D3DERR_INVALIDCALL);
@@ -683,7 +683,7 @@
 
     /* D3DXLoadSurfaceFromFileInMemory */
     hr = D3DXLoadSurfaceFromFileInMemory(surf, NULL, NULL, bmp_1bpp, sizeof(bmp_1bpp), NULL, D3DX_DEFAULT, 0, NULL);
-    ok(hr == D3D_OK, "D3DXLoadSurfaceFromFileInMemory returned %#x, expected %#x\n", hr, D3D_OK);
+    todo_wine ok(hr == D3D_OK, "D3DXLoadSurfaceFromFileInMemory returned %#x, expected %#x\n", hr, D3D_OK);
 
     hr = D3DXLoadSurfaceFromFileInMemory(surf, NULL, NULL, noimage, sizeof(noimage), NULL, D3DX_DEFAULT, 0, NULL);
     ok(hr == D3DXERR_INVALIDDATA, "D3DXLoadSurfaceFromFileInMemory returned %#x, expected %#x\n", hr, D3DXERR_INVALIDDATA);
diff -urN wine-1.5.30/dlls/d3dx9_36/tests/texture.c wine-multimedia/dlls/d3dx9_36/tests/texture.c
--- wine-1.5.30/dlls/d3dx9_36/tests/texture.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3dx9_36/tests/texture.c	2013-05-17 10:44:20.636234401 +0300
@@ -329,6 +329,17 @@
     ok(hr == D3D_OK, "D3DXCheckTextureRequirements returned %#x, expected %#x\n", hr, D3D_OK);
     ok(format == expected, "Returned format %u, expected %u\n", format, expected);
 
+    if(SUCCEEDED(IDirect3D9_CheckDeviceFormat(d3d, params.AdapterOrdinal, params.DeviceType,
+                                              mode.Format, 0, D3DRTYPE_TEXTURE, D3DFMT_P8)))
+        expected = D3DFMT_P8;
+    else
+        expected = D3DFMT_A8R8G8B8;
+
+    format = D3DFMT_P8;
+    hr = D3DXCheckTextureRequirements(device, NULL, NULL, NULL, 0, &format, D3DPOOL_DEFAULT);
+    ok(hr == D3D_OK, "D3DXCheckTextureRequirements returned %#x, expected %#x\n", hr, D3D_OK);
+    ok(format == expected, "Returned format %u, expected %u\n", format, expected);
+
     IDirect3D9_Release(d3d);
 }
 
diff -urN wine-1.5.30/dlls/d3dx9_36/util.c wine-multimedia/dlls/d3dx9_36/util.c
--- wine-1.5.30/dlls/d3dx9_36/util.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/d3dx9_36/util.c	2013-05-17 10:44:20.638234376 +0300
@@ -73,6 +73,7 @@
     {D3DFMT_DXT5,          { 0,  0,  0,  0}, { 0,  0,  0,  0},  1, 4, 4, 16, FORMAT_DXT,     NULL,         NULL      },
     {D3DFMT_A16B16G16R16F, {16, 16, 16, 16}, {48,  0, 16, 32},  8, 1, 1,  8, FORMAT_ARGBF16, NULL,         NULL      },
     {D3DFMT_A32B32G32R32F, {32, 32, 32, 32}, {96,  0, 32, 64}, 16, 1, 1, 16, FORMAT_ARGBF,   NULL,         NULL      },
+    {D3DFMT_P8,            { 8,  8,  8,  8}, { 0,  0,  0,  0},  1, 1, 1,  1, FORMAT_UNKNOWN, NULL,         NULL      },
     /* marks last element */
     {D3DFMT_UNKNOWN,       { 0,  0,  0,  0}, { 0,  0,  0,  0},  0, 1, 1,  0, FORMAT_UNKNOWN, NULL,         NULL      },
 };
diff -urN wine-1.5.30/dlls/ddraw/main.c wine-multimedia/dlls/ddraw/main.c
--- wine-1.5.30/dlls/ddraw/main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/ddraw/main.c	2013-05-17 10:44:20.661234088 +0300
@@ -848,13 +848,12 @@
  * app didn't release them properly(Gothic 2, Diablo 2, Moto racer, ...)
  *
  ***********************************************************************/
-BOOL WINAPI
-DllMain(HINSTANCE hInstDLL,
-        DWORD Reason,
-        LPVOID lpv)
+BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD reason, LPVOID reserved)
 {
-    TRACE("(%p,%x,%p)\n", hInstDLL, Reason, lpv);
-    if (Reason == DLL_PROCESS_ATTACH)
+    TRACE("(%p,%x,%p)\n", hInstDLL, reason, reserved);
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
     {
         static HMODULE ddraw_self;
         char buffer[MAX_PATH+10];
@@ -968,9 +967,10 @@
 
         instance = hInstDLL;
         DisableThreadLibraryCalls(hInstDLL);
+        break;
     }
-    else if (Reason == DLL_PROCESS_DETACH)
-    {
+
+    case DLL_PROCESS_DETACH:
         if(!list_empty(&global_ddraw_list))
         {
             struct list *entry, *entry2;
@@ -1034,7 +1034,7 @@
             }
         }
 
-        /* Unregister the window class. */
+        if (reserved) break;
         UnregisterClassA(DDRAW_WINDOW_CLASS_NAME, hInstDLL);
     }
 
diff -urN wine-1.5.30/dlls/devenum/createdevenum.c wine-multimedia/dlls/devenum/createdevenum.c
--- wine-1.5.30/dlls/devenum/createdevenum.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/devenum/createdevenum.c	2013-05-17 10:44:20.676233901 +0300
@@ -52,6 +52,9 @@
 static const WCHAR wszDirection[] = {'D','i','r','e','c','t','i','o','n',0};
 static const WCHAR wszIsRendered[] = {'I','s','R','e','n','d','e','r','e','d',0};
 static const WCHAR wszTypes[] = {'T','y','p','e','s',0};
+static const WCHAR wszFriendlyName[] = {'F','r','i','e','n','d','l','y','N','a','m','e',0};
+static const WCHAR wszWaveInID[] = {'W','a','v','e','I','n','I','D',0};
+static const WCHAR wszWaveOutID[] = {'W','a','v','e','O','u','t','I','D',0};
 
 static ULONG WINAPI DEVENUM_ICreateDevEnum_AddRef(ICreateDevEnum * iface);
 static HRESULT DEVENUM_CreateSpecialCategories(void);
@@ -629,6 +632,7 @@
 	WAVEINCAPSW wicaps;
         MIDIOUTCAPSW mocaps;
         REGPINTYPES * pTypes;
+        IPropertyBag * pPropBag = NULL;
 
 	numDevs = waveOutGetNumDevs();
 
@@ -666,10 +670,24 @@
 					      wocaps.szPname,
 					      &rf2);
 
-                /* FIXME: do additional stuff with IMoniker here, depending on what RegisterFilter does */
-
                 if (pMoniker)
                 {
+                    VARIANT var;
+
+                    V_VT(&var) = VT_I4;
+                    V_UNION(&var, ulVal) = i;
+                    res = IMoniker_BindToStorage(pMoniker, NULL, NULL, &IID_IPropertyBag, (LPVOID)&pPropBag);
+                    if (SUCCEEDED(res))
+                        res = IPropertyBag_Write(pPropBag, wszWaveOutID, &var);
+                    else
+                        pPropBag = NULL;
+
+                    V_VT(&var) = VT_LPWSTR;
+                    V_UNION(&var, bstrVal) = wocaps.szPname;
+                    if (SUCCEEDED(res))
+                        res = IPropertyBag_Write(pPropBag, wszFriendlyName, &var);
+                    if (pPropBag)
+                        IPropertyBag_Release(pPropBag);
                     IMoniker_Release(pMoniker);
                     pMoniker = NULL;
                 }
@@ -725,7 +743,7 @@
 
                 rfp2.lpMediaType = pTypes;
 
-	        res = IFilterMapper2_RegisterFilter(pMapper,
+                res = IFilterMapper2_RegisterFilter(pMapper,
 		                              &CLSID_AudioRecord,
 					      wicaps.szPname,
 					      &pMoniker,
@@ -733,10 +751,27 @@
 					      wicaps.szPname,
 					      &rf2);
 
-                /* FIXME: do additional stuff with IMoniker here, depending on what RegisterFilter does */
 
-		if (pMoniker)
-		    IMoniker_Release(pMoniker);
+                if (pMoniker) {
+                    VARIANT var;
+
+                    V_VT(&var) = VT_I4;
+                    V_UNION(&var, ulVal) = i;
+                    res = IMoniker_BindToStorage(pMoniker, NULL, NULL, &IID_IPropertyBag, (LPVOID)&pPropBag);
+                    if (SUCCEEDED(res))
+                        res = IPropertyBag_Write(pPropBag, wszWaveInID, &var);
+                    else
+                        pPropBag = NULL;
+
+                    V_VT(&var) = VT_LPWSTR;
+                    V_UNION(&var, bstrVal) = wicaps.szPname;
+                    if (SUCCEEDED(res))
+                        res = IPropertyBag_Write(pPropBag, wszFriendlyName, &var);
+
+                    if (pPropBag)
+                        IPropertyBag_Release(pPropBag);
+                    IMoniker_Release(pMoniker);
+                }
 
                 CoTaskMemFree(pTypes);
 	    }
@@ -803,7 +838,6 @@
                                               szDeviceVersion, sizeof(szDeviceVersion)/sizeof(WCHAR)))
                 {
                     IMoniker * pMoniker = NULL;
-                    IPropertyBag * pPropBag = NULL;
                     WCHAR dprintf[] = { 'v','i','d','e','o','%','d',0 };
                     snprintfW(szDevicePath, sizeof(szDevicePath)/sizeof(WCHAR), dprintf, i);
                     /* The above code prevents 1 device with a different ID overwriting another */
@@ -834,8 +868,10 @@
                        V_VT(&var) = VT_I4;
                        V_UNION(&var, ulVal) = i;
                        res = IMoniker_BindToStorage(pMoniker, NULL, NULL, &IID_IPropertyBag, (LPVOID)&pPropBag);
-                       if (SUCCEEDED(res))
-                          res = IPropertyBag_Write(pPropBag, wszVfwIndex, &var);
+                       if (SUCCEEDED(res)) {
+                           res = IPropertyBag_Write(pPropBag, wszVfwIndex, &var);
+                           IPropertyBag_Release(pPropBag);
+                       }
                        IMoniker_Release(pMoniker);
                     }
 
diff -urN wine-1.5.30/dlls/devenum/mediacatenum.c wine-multimedia/dlls/devenum/mediacatenum.c
--- wine-1.5.30/dlls/devenum/mediacatenum.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/devenum/mediacatenum.c	2013-05-17 10:44:20.677233888 +0300
@@ -232,6 +232,7 @@
     switch (V_VT(pVar))
     {
     case VT_BSTR:
+    case VT_LPWSTR:
         TRACE("writing %s\n", debugstr_w(V_UNION(pVar, bstrVal)));
         lpData = V_UNION(pVar, bstrVal);
         dwType = REG_SZ;
diff -urN wine-1.5.30/dlls/dinput/keyboard.c wine-multimedia/dlls/dinput/keyboard.c
--- wine-1.5.30/dlls/dinput/keyboard.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dinput/keyboard.c	2013-05-17 10:44:20.683233813 +0300
@@ -439,7 +439,7 @@
     scan = DIDFT_GETINSTANCE(pdidoi->dwType);
     if (scan == DIK_PAUSE || scan == DIK_NUMLOCK) scan ^= 0x80;
     if (!GetKeyNameTextW((scan & 0x80) << 17 | (scan & 0x7f) << 16,
-                         pdidoi->tszName, sizeof(pdidoi->tszName)))
+                         pdidoi->tszName, sizeof(pdidoi->tszName)/sizeof(pdidoi->tszName[0])))
         return DIERR_OBJECTNOTFOUND;
 
     _dump_OBJECTINSTANCEW(pdidoi);
diff -urN wine-1.5.30/dlls/dsound/dsound.c wine-multimedia/dlls/dsound/dsound.c
--- wine-1.5.30/dlls/dsound/dsound.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dsound/dsound.c	2013-05-17 10:44:20.721233338 +0300
@@ -306,7 +306,6 @@
 {
     IDirectSoundImpl *This = impl_from_IDirectSound8(iface);
     DirectSoundDevice *device = This->device;
-    DWORD oldlevel;
     HRESULT hr = S_OK;
 
     TRACE("(%p,%p,%s)\n", This, hwnd, dumpCooperativeLevel(level));
@@ -323,15 +322,10 @@
 
     RtlAcquireResourceExclusive(&device->buffer_list_lock, TRUE);
     EnterCriticalSection(&device->mixlock);
-    oldlevel = device->priolevel;
-    device->priolevel = level;
-    if ((level == DSSCL_WRITEPRIMARY) != (oldlevel == DSSCL_WRITEPRIMARY)) {
+    if ((level == DSSCL_WRITEPRIMARY) != (device->priolevel == DSSCL_WRITEPRIMARY))
         hr = DSOUND_ReopenDevice(device, level == DSSCL_WRITEPRIMARY);
-        if (FAILED(hr))
-            device->priolevel = oldlevel;
-        else
-            DSOUND_PrimaryOpen(device);
-    }
+    if (SUCCEEDED(hr))
+        device->priolevel = level;
     LeaveCriticalSection(&device->mixlock);
     RtlReleaseResource(&device->buffer_list_lock);
     return hr;
@@ -602,7 +596,7 @@
 
     device->ref            = 1;
     device->priolevel      = DSSCL_NORMAL;
-    device->state          = STATE_STOPPED;
+    device->stopped = 1;
     device->speaker_config = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE);
 
     /* 3D listener initial parameters */
@@ -623,28 +617,23 @@
     device->ds3dl.flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
     device->ds3dl.flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;
 
-    device->prebuf = ds_snd_queue_max;
     device->guid = GUID_NULL;
 
     /* Set default wave format (may need it for waveOutOpen) */
-    device->pwfx = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(WAVEFORMATEXTENSIBLE));
     device->primary_pwfx = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(WAVEFORMATEXTENSIBLE));
-    if (!device->pwfx || !device->primary_pwfx) {
+    if (!device->primary_pwfx) {
         WARN("out of memory\n");
-        HeapFree(GetProcessHeap(),0,device->primary_pwfx);
-        HeapFree(GetProcessHeap(),0,device->pwfx);
         HeapFree(GetProcessHeap(),0,device);
         return DSERR_OUTOFMEMORY;
     }
 
-    device->pwfx->wFormatTag = WAVE_FORMAT_PCM;
-    device->pwfx->nSamplesPerSec = 22050;
-    device->pwfx->wBitsPerSample = 8;
-    device->pwfx->nChannels = 2;
-    device->pwfx->nBlockAlign = device->pwfx->wBitsPerSample * device->pwfx->nChannels / 8;
-    device->pwfx->nAvgBytesPerSec = device->pwfx->nSamplesPerSec * device->pwfx->nBlockAlign;
-    device->pwfx->cbSize = 0;
-    memcpy(device->primary_pwfx, device->pwfx, sizeof(*device->pwfx));
+    device->primary_pwfx->wFormatTag = WAVE_FORMAT_PCM;
+    device->primary_pwfx->nSamplesPerSec = 22050;
+    device->primary_pwfx->wBitsPerSample = 8;
+    device->primary_pwfx->nChannels = 2;
+    device->primary_pwfx->nBlockAlign = 2;
+    device->primary_pwfx->nAvgBytesPerSec = 44100;
+    device->primary_pwfx->cbSize = 0;
 
     InitializeCriticalSection(&(device->mixlock));
     device->mixlock.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": DirectSoundDevice.mixlock");
@@ -693,17 +682,16 @@
         if (hr != DS_OK)
             WARN("DSOUND_PrimaryDestroy failed\n");
 
-        if(device->client)
+        if(device->client) {
+            IAudioClient_Stop(device->client);
             IAudioClient_Release(device->client);
+        }
         if(device->render)
             IAudioRenderClient_Release(device->render);
-        if(device->clock)
-            IAudioClock_Release(device->clock);
         if(device->volume)
             IAudioStreamVolume_Release(device->volume);
 
         HeapFree(GetProcessHeap(), 0, device->tmp_buffer);
-        HeapFree(GetProcessHeap(), 0, device->mix_buffer);
         HeapFree(GetProcessHeap(), 0, device->buffer);
         RtlDeleteResource(&device->buffer_list_lock);
         device->mixlock.DebugInfo->Spare[0] = 0;
@@ -813,6 +801,7 @@
     device->mmdevice = mmdevice;
     device->guid = devGUID;
     device->sleepev = CreateEventW(0, 0, 0, 0);
+    device->buflen = ds_hel_buflen;
 
     hr = DSOUND_ReopenDevice(device, FALSE);
     if (FAILED(hr))
@@ -868,12 +857,8 @@
 
     ZeroMemory(&device->volpan, sizeof(device->volpan));
 
-    hr = DSOUND_PrimaryCreate(device);
-    if (hr == DS_OK) {
-        device->thread = CreateThread(0, 0, DSOUND_mixthread, device, 0, 0);
-        SetThreadPriority(device->thread, THREAD_PRIORITY_TIME_CRITICAL);
-    } else
-        WARN("DSOUND_PrimaryCreate failed: %08x\n", hr);
+    device->thread = CreateThread(0, 0, DSOUND_mixthread, device, 0, 0);
+    SetThreadPriority(device->thread, THREAD_PRIORITY_TIME_CRITICAL);
 
     *ppDevice = device;
     list_add_tail(&DSOUND_renderers, &device->entry);
diff -urN wine-1.5.30/dlls/dsound/dsound_convert.c wine-multimedia/dlls/dsound/dsound_convert.c
--- wine-1.5.30/dlls/dsound/dsound_convert.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dsound/dsound_convert.c	2013-05-17 10:44:20.721233338 +0300
@@ -222,27 +222,9 @@
     }
 }
 
-static void normieee32(float *src, float *dst, unsigned len)
-{
-    TRACE("%p - %p %d\n", src, dst, len);
-    len /= 4;
-    while (len--)
-    {
-        if(*src > 1)
-            *dst = 1;
-        else if(*src < -1)
-            *dst = -1;
-        else
-            *dst = *src;
-        ++dst;
-        ++src;
-    }
-}
-
 const normfunc normfunctions[5] = {
     (normfunc)norm8,
     (normfunc)norm16,
     (normfunc)norm24,
     (normfunc)norm32,
-    (normfunc)normieee32
 };
diff -urN wine-1.5.30/dlls/dsound/dsound_main.c wine-multimedia/dlls/dsound/dsound_main.c
--- wine-1.5.30/dlls/dsound/dsound_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dsound/dsound_main.c	2013-05-17 10:44:20.721233338 +0300
@@ -91,8 +91,7 @@
 WCHAR wine_vxd_drv[] = { 'w','i','n','e','m','m','.','v','x','d', 0 };
 
 /* All default settings, you most likely don't want to touch these, see wiki on UsefulRegistryKeys */
-int ds_hel_buflen = 32768 * 2;
-int ds_snd_queue_max = 10;
+int ds_hel_buflen = 32768;
 static HINSTANCE instance;
 
 /*
@@ -145,15 +144,10 @@
     if (!get_config_key( hkey, appkey, "HelBuflen", buffer, MAX_PATH ))
         ds_hel_buflen = atoi(buffer);
 
-    if (!get_config_key( hkey, appkey, "SndQueueMax", buffer, MAX_PATH ))
-        ds_snd_queue_max = atoi(buffer);
-
-
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 
     TRACE("ds_hel_buflen = %d\n", ds_hel_buflen);
-    TRACE("ds_snd_queue_max = %d\n", ds_snd_queue_max);
 }
 
 static const char * get_device_id(LPCGUID pGuid)
diff -urN wine-1.5.30/dlls/dsound/dsound_private.h wine-multimedia/dlls/dsound/dsound_private.h
--- wine-1.5.30/dlls/dsound/dsound_private.h	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dsound/dsound_private.h	2013-05-17 10:44:20.722233326 +0300
@@ -31,7 +31,6 @@
 #include "wine/list.h"
 
 extern int ds_hel_buflen DECLSPEC_HIDDEN;
-extern int ds_snd_queue_max DECLSPEC_HIDDEN;
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
@@ -70,17 +69,15 @@
     DSCAPS                      drvcaps;
     DWORD                       priolevel, sleeptime;
     PWAVEFORMATEX               pwfx, primary_pwfx;
-    UINT                        playing_offs_bytes, in_mmdev_bytes, prebuf;
-    DWORD                       fraglen;
     LPBYTE                      buffer;
-    DWORD                       writelead, buflen, state, playpos, mixpos;
+    DWORD                       writelead, buflen, aclen, fraglen, playpos, pad, stopped;
     int                         nrofbuffers;
     IDirectSoundBufferImpl**    buffers;
     RTL_RWLOCK                  buffer_list_lock;
     CRITICAL_SECTION            mixlock;
     IDirectSoundBufferImpl     *primary;
     DWORD                       speaker_config;
-    float *mix_buffer, *tmp_buffer;
+    float *tmp_buffer;
     DWORD                       tmp_buffer_len, mix_buffer_len;
 
     DSVOLUMEPAN                 volpan;
@@ -93,7 +90,6 @@
 
     IMMDevice *mmdevice;
     IAudioClient *client;
-    IAudioClock *clock;
     IAudioStreamVolume *volume;
     IAudioRenderClient *render;
 
@@ -202,14 +198,11 @@
 
 /* primary.c */
 
-HRESULT DSOUND_PrimaryCreate(DirectSoundDevice *device) DECLSPEC_HIDDEN;
 HRESULT DSOUND_PrimaryDestroy(DirectSoundDevice *device) DECLSPEC_HIDDEN;
 HRESULT DSOUND_PrimaryPlay(DirectSoundDevice *device) DECLSPEC_HIDDEN;
 HRESULT DSOUND_PrimaryStop(DirectSoundDevice *device) DECLSPEC_HIDDEN;
-HRESULT DSOUND_PrimaryGetPosition(DirectSoundDevice *device, LPDWORD playpos, LPDWORD writepos) DECLSPEC_HIDDEN;
 LPWAVEFORMATEX DSOUND_CopyFormat(LPCWAVEFORMATEX wfex) DECLSPEC_HIDDEN;
 HRESULT DSOUND_ReopenDevice(DirectSoundDevice *device, BOOL forcewave) DECLSPEC_HIDDEN;
-HRESULT DSOUND_PrimaryOpen(DirectSoundDevice *device) DECLSPEC_HIDDEN;
 HRESULT primarybuffer_create(DirectSoundDevice *device, IDirectSoundBufferImpl **ppdsb,
     const DSBUFFERDESC *dsbd) DECLSPEC_HIDDEN;
 void primarybuffer_destroy(IDirectSoundBufferImpl *This) DECLSPEC_HIDDEN;
diff -urN wine-1.5.30/dlls/dsound/mixer.c wine-multimedia/dlls/dsound/mixer.c
--- wine-1.5.30/dlls/dsound/mixer.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dsound/mixer.c	2013-05-17 10:44:20.723233313 +0300
@@ -427,7 +427,7 @@
  * writepos = position (offset) in device buffer to write at
  * fraglen = number of bytes to mix
  */
-static DWORD DSOUND_MixInBuffer(IDirectSoundBufferImpl *dsb, DWORD writepos, DWORD fraglen)
+static DWORD DSOUND_MixInBuffer(IDirectSoundBufferImpl *dsb, float *mix_buffer, DWORD writepos, DWORD fraglen)
 {
 	INT len = fraglen;
 	float *ibuf;
@@ -452,7 +452,7 @@
 	/* Apply volume if needed */
 	DSOUND_MixerVol(dsb, frames);
 
-	mixieee32(ibuf, dsb->device->mix_buffer, frames * dsb->device->pwfx->nChannels);
+	mixieee32(ibuf, mix_buffer, frames * dsb->device->pwfx->nChannels);
 
 	/* check for notification positions */
 	if (dsb->dsbd.dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY &&
@@ -476,7 +476,7 @@
  *
  * Returns: the number of bytes beyond the writepos that were mixed.
  */
-static DWORD DSOUND_MixOne(IDirectSoundBufferImpl *dsb, DWORD writepos, DWORD mixlen)
+static DWORD DSOUND_MixOne(IDirectSoundBufferImpl *dsb, float *mix_buffer, DWORD writepos, DWORD mixlen)
 {
 	DWORD primary_done = 0;
 
@@ -503,7 +503,7 @@
 	/* First try to mix to the end of the buffer if possible
 	 * Theoretically it would allow for better optimization
 	*/
-	primary_done += DSOUND_MixInBuffer(dsb, writepos, mixlen);
+	primary_done += DSOUND_MixInBuffer(dsb, mix_buffer, writepos, mixlen);
 
 	TRACE("total mixed data=%d\n", primary_done);
 
@@ -518,14 +518,12 @@
  * writepos = the current safe-to-write position in the primary buffer
  * mixlen = the maximum amount to mix into the primary buffer
  *          (beyond the current writepos)
- * recover = true if the sound device may have been reset and the write
- *           position in the device buffer changed
  * all_stopped = reports back if all buffers have stopped
  *
  * Returns:  the length beyond the writepos that was mixed to.
  */
 
-static void DSOUND_MixToPrimary(const DirectSoundDevice *device, DWORD writepos, DWORD mixlen, BOOL recover, BOOL *all_stopped)
+static void DSOUND_MixToPrimary(const DirectSoundDevice *device, float *mix_buffer, DWORD writepos, DWORD mixlen, BOOL *all_stopped)
 {
 	INT i;
 	IDirectSoundBufferImpl	*dsb;
@@ -533,7 +531,7 @@
 	/* unless we find a running buffer, all have stopped */
 	*all_stopped = TRUE;
 
-	TRACE("(%d,%d,%d)\n", writepos, mixlen, recover);
+	TRACE("(%d,%d)\n", writepos, mixlen);
 	for (i = 0; i < device->nrofbuffers; i++) {
 		dsb = device->buffers[i];
 
@@ -553,7 +551,7 @@
 					dsb->state = STATE_PLAYING;
 
 				/* mix next buffer into the main buffer */
-				DSOUND_MixOne(dsb, writepos, mixlen);
+				DSOUND_MixOne(dsb, mix_buffer, writepos, mixlen);
 
 				*all_stopped = FALSE;
 			}
@@ -572,85 +570,29 @@
  * Returns:  None
  */
 
-static void DSOUND_WaveQueue(DirectSoundDevice *device, BOOL force)
+static void DSOUND_WaveQueue(DirectSoundDevice *device, LPBYTE pos, DWORD bytes)
 {
-	DWORD prebuf_frames, prebuf_bytes, read_offs_bytes;
 	BYTE *buffer;
 	HRESULT hr;
 
 	TRACE("(%p)\n", device);
 
-	read_offs_bytes = (device->playing_offs_bytes + device->in_mmdev_bytes) % device->buflen;
-
-	TRACE("read_offs_bytes = %u, playing_offs_bytes = %u, in_mmdev_bytes: %u, prebuf = %u\n",
-		read_offs_bytes, device->playing_offs_bytes, device->in_mmdev_bytes, device->prebuf);
-
-	if (!force)
-	{
-		if(device->mixpos < device->playing_offs_bytes)
-			prebuf_bytes = device->mixpos + device->buflen - device->playing_offs_bytes;
-		else
-			prebuf_bytes = device->mixpos - device->playing_offs_bytes;
-	}
-	else
-		/* buffer the maximum amount of frags */
-		prebuf_bytes = device->prebuf * device->fraglen;
-
-	/* limit to the queue we have left */
-	if(device->in_mmdev_bytes + prebuf_bytes > device->prebuf * device->fraglen)
-		prebuf_bytes = device->prebuf * device->fraglen - device->in_mmdev_bytes;
-
-	TRACE("prebuf_bytes = %u\n", prebuf_bytes);
-
-	if(!prebuf_bytes)
-		return;
-
-	device->in_mmdev_bytes += prebuf_bytes;
-
-	if(prebuf_bytes + read_offs_bytes > device->buflen){
-		DWORD chunk_bytes = device->buflen - read_offs_bytes;
-		prebuf_frames = chunk_bytes / device->pwfx->nBlockAlign;
-		prebuf_bytes -= chunk_bytes;
-	}else{
-		prebuf_frames = prebuf_bytes / device->pwfx->nBlockAlign;
-		prebuf_bytes = 0;
-	}
-
-	hr = IAudioRenderClient_GetBuffer(device->render, prebuf_frames, &buffer);
+	hr = IAudioRenderClient_GetBuffer(device->render, bytes / device->pwfx->nBlockAlign, &buffer);
 	if(FAILED(hr)){
 		WARN("GetBuffer failed: %08x\n", hr);
 		return;
 	}
 
-	memcpy(buffer, device->buffer + read_offs_bytes,
-			prebuf_frames * device->pwfx->nBlockAlign);
+	memcpy(buffer, pos, bytes);
 
-	hr = IAudioRenderClient_ReleaseBuffer(device->render, prebuf_frames, 0);
-	if(FAILED(hr)){
-		WARN("ReleaseBuffer failed: %08x\n", hr);
+	hr = IAudioRenderClient_ReleaseBuffer(device->render, bytes / device->pwfx->nBlockAlign, 0);
+	if(FAILED(hr)) {
+		ERR("ReleaseBuffer failed: %08x\n", hr);
+		IAudioRenderClient_ReleaseBuffer(device->render, 0, 0);
 		return;
 	}
 
-	/* check if anything wrapped */
-	if(prebuf_bytes > 0){
-		prebuf_frames = prebuf_bytes / device->pwfx->nBlockAlign;
-
-		hr = IAudioRenderClient_GetBuffer(device->render, prebuf_frames, &buffer);
-		if(FAILED(hr)){
-			WARN("GetBuffer failed: %08x\n", hr);
-			return;
-		}
-
-		memcpy(buffer, device->buffer, prebuf_frames * device->pwfx->nBlockAlign);
-
-		hr = IAudioRenderClient_ReleaseBuffer(device->render, prebuf_frames, 0);
-		if(FAILED(hr)){
-			WARN("ReleaseBuffer failed: %08x\n", hr);
-			return;
-		}
-	}
-
-	TRACE("in_mmdev_bytes now = %i\n", device->in_mmdev_bytes);
+	device->pad += bytes;
 }
 
 /**
@@ -663,12 +605,12 @@
  * secondary->buffer (secondary format)
  *   =[Resample]=> device->tmp_buffer (float format)
  *   =[Volume]=> device->tmp_buffer (float format)
- *   =[Mix]=> device->mix_buffer (float format)
- *   =[Reformat]=> device->buffer (device format)
+ *   =[Reformat]=> device->buffer (device format, skipped on float)
  */
 static void DSOUND_PerformMix(DirectSoundDevice *device)
 {
-	UINT32 pad, to_mix_frags, to_mix_bytes;
+	UINT32 pad, maxq, writepos;
+	DWORD block;
 	HRESULT hr;
 
 	TRACE("(%p)\n", device);
@@ -682,161 +624,68 @@
 		LeaveCriticalSection(&device->mixlock);
 		return;
 	}
-
-	to_mix_frags = device->prebuf - (pad * device->pwfx->nBlockAlign + device->fraglen - 1) / device->fraglen;
-
-	to_mix_bytes = to_mix_frags * device->fraglen;
-
-	if(device->in_mmdev_bytes > 0){
-		DWORD delta_bytes = min(to_mix_bytes, device->in_mmdev_bytes);
-		device->in_mmdev_bytes -= delta_bytes;
-		device->playing_offs_bytes += delta_bytes;
-		device->playing_offs_bytes %= device->buflen;
+	block = device->pwfx->nBlockAlign;
+	pad *= block;
+	device->playpos += device->pad - pad;
+	device->playpos %= device->buflen;
+	device->pad = pad;
+
+	maxq = device->aclen - pad;
+	if(!maxq){
+		/* nothing to do! */
+		LeaveCriticalSection(&device->mixlock);
+		return;
 	}
+	if (maxq > device->fraglen * 3)
+		maxq = device->fraglen * 3;
+
+	writepos = (device->playpos + pad) % device->buflen;
 
 	if (device->priolevel != DSSCL_WRITEPRIMARY) {
-		BOOL recover = FALSE, all_stopped = FALSE;
-		DWORD playpos, writepos, writelead, maxq, prebuff_max, prebuff_left, size1, size2;
-		LPVOID buf1, buf2;
+		BOOL all_stopped = FALSE;
 		int nfiller;
+		void *buffer = NULL;
 
 		/* the sound of silence */
 		nfiller = device->pwfx->wBitsPerSample == 8 ? 128 : 0;
 
-		/* get the position in the primary buffer */
-		if (DSOUND_PrimaryGetPosition(device, &playpos, &writepos) != 0){
-			LeaveCriticalSection(&(device->mixlock));
-			return;
-		}
-
-		TRACE("primary playpos=%d, writepos=%d, clrpos=%d, mixpos=%d, buflen=%d\n",
-			playpos,writepos,device->playpos,device->mixpos,device->buflen);
-		assert(device->playpos < device->buflen);
-
-		/* calc maximum prebuff */
-		prebuff_max = (device->prebuf * device->fraglen);
-
-		/* check how close we are to an underrun. It occurs when the writepos overtakes the mixpos */
-		prebuff_left = DSOUND_BufPtrDiff(device->buflen, device->mixpos, playpos);
-		writelead = DSOUND_BufPtrDiff(device->buflen, writepos, playpos);
-
 		/* check for underrun. underrun occurs when the write position passes the mix position
 		 * also wipe out just-played sound data */
-		if((prebuff_left > prebuff_max) || (device->state == STATE_STOPPED) || (device->state == STATE_STARTING)){
-			if (device->state == STATE_STOPPING || device->state == STATE_PLAYING)
-				WARN("Probable buffer underrun\n");
-			else TRACE("Buffer starting or buffer underrun\n");
-
-			/* recover mixing for all buffers */
-			recover = TRUE;
-
-			/* reset mix position to write position */
-			device->mixpos = writepos;
-
-			ZeroMemory(device->buffer, device->buflen);
-		} else if (playpos < device->playpos) {
-			buf1 = device->buffer + device->playpos;
-			buf2 = device->buffer;
-			size1 = device->buflen - device->playpos;
-			size2 = playpos;
-			FillMemory(buf1, size1, nfiller);
-			if (playpos && (!buf2 || !size2))
-				FIXME("%d: (%d, %d)=>(%d, %d) There should be an additional buffer here!!\n", __LINE__, device->playpos, device->mixpos, playpos, writepos);
-			FillMemory(buf2, size2, nfiller);
-		} else {
-			buf1 = device->buffer + device->playpos;
-			buf2 = NULL;
-			size1 = playpos - device->playpos;
-			size2 = 0;
-			FillMemory(buf1, size1, nfiller);
-		}
-		device->playpos = playpos;
-
-		/* find the maximum we can prebuffer from current write position */
-		maxq = (writelead < prebuff_max) ? (prebuff_max - writelead) : 0;
-
-		TRACE("prebuff_left = %d, prebuff_max = %dx%d=%d, writelead=%d\n",
-			prebuff_left, device->prebuf, device->fraglen, prebuff_max, writelead);
-
-		ZeroMemory(device->mix_buffer, device->mix_buffer_len);
-
-		/* do the mixing */
-		DSOUND_MixToPrimary(device, writepos, maxq, recover, &all_stopped);
-
-		if (maxq + writepos > device->buflen)
-		{
-			DWORD todo = device->buflen - writepos;
-			DWORD offs_float = (todo / device->pwfx->nBlockAlign) * device->pwfx->nChannels;
-			device->normfunction(device->mix_buffer, device->buffer + writepos, todo);
-			device->normfunction(device->mix_buffer + offs_float, device->buffer, maxq - todo);
-		}
-		else
-			device->normfunction(device->mix_buffer, device->buffer + writepos, maxq);
-
-		/* update the mix position, taking wrap-around into account */
-		device->mixpos = writepos + maxq;
-		device->mixpos %= device->buflen;
-
-		/* update prebuff left */
-		prebuff_left = DSOUND_BufPtrDiff(device->buflen, device->mixpos, playpos);
-
-		/* check if have a whole fragment */
-		if (prebuff_left >= device->fraglen){
-
-			/* update the wave queue */
-			DSOUND_WaveQueue(device, FALSE);
-
-			/* buffers are full. start playing if applicable */
-			if(device->state == STATE_STARTING){
-				TRACE("started primary buffer\n");
-				if(DSOUND_PrimaryPlay(device) != DS_OK){
-					WARN("DSOUND_PrimaryPlay failed\n");
-				}
-				else{
-					/* we are playing now */
-					device->state = STATE_PLAYING;
-				}
-			}
-
-			/* buffers are full. start stopping if applicable */
-			if(device->state == STATE_STOPPED){
-				TRACE("restarting primary buffer\n");
-				if(DSOUND_PrimaryPlay(device) != DS_OK){
-					WARN("DSOUND_PrimaryPlay failed\n");
-				}
-				else{
-					/* start stopping again. as soon as there is no more data, it will stop */
-					device->state = STATE_STOPPING;
-				}
-			}
-		}
-
-		/* if device was stopping, its for sure stopped when all buffers have stopped */
-		else if((all_stopped == TRUE) && (device->state == STATE_STOPPING)){
-			TRACE("All buffers have stopped. Stopping primary buffer\n");
-			device->state = STATE_STOPPED;
+		if (!pad)
+			WARN("Probable buffer underrun\n");
 
-			/* stop the primary buffer now */
-			DSOUND_PrimaryStop(device);
+		hr = IAudioRenderClient_GetBuffer(device->render, maxq / block, (void*)&buffer);
+		if(FAILED(hr)){
+			WARN("GetBuffer failed: %08x\n", hr);
+			LeaveCriticalSection(&device->mixlock);
+			return;
 		}
 
-	} else if (device->state != STATE_STOPPED) {
+		memset(buffer, nfiller, maxq);
 
-		DSOUND_WaveQueue(device, TRUE);
-
-		/* in the DSSCL_WRITEPRIMARY mode, the app is totally in charge... */
-		if (device->state == STATE_STARTING) {
-			if (DSOUND_PrimaryPlay(device) != DS_OK)
-				WARN("DSOUND_PrimaryPlay failed\n");
-			else
-				device->state = STATE_PLAYING;
-		}
-		else if (device->state == STATE_STOPPING) {
-			if (DSOUND_PrimaryStop(device) != DS_OK)
-				WARN("DSOUND_PrimaryStop failed\n");
-			else
-				device->state = STATE_STOPPED;
-		}
+		if (!device->normfunction)
+			DSOUND_MixToPrimary(device, buffer, writepos, maxq, &all_stopped);
+		else {
+
+			/* do the mixing */
+			DSOUND_MixToPrimary(device, (float*)device->buffer, writepos, maxq, &all_stopped);
+
+			device->normfunction(device->buffer, buffer, maxq);
+		}
+
+		hr = IAudioRenderClient_ReleaseBuffer(device->render, maxq / block, 0);
+		if(FAILED(hr))
+			ERR("ReleaseBuffer failed: %08x\n", hr);
+
+		device->pad += maxq;
+	} else if (!device->stopped) {
+		if (maxq > device->buflen)
+			maxq = device->buflen;
+		if (writepos + maxq > device->buflen) {
+			DSOUND_WaveQueue(device, device->buffer + writepos, device->buflen - writepos);
+			DSOUND_WaveQueue(device, device->buffer, writepos + maxq - device->buflen);
+		} else
+			DSOUND_WaveQueue(device, device->buffer + writepos, maxq);
 	}
 
 	LeaveCriticalSection(&(device->mixlock));
diff -urN wine-1.5.30/dlls/dsound/primary.c wine-multimedia/dlls/dsound/primary.c
--- wine-1.5.30/dlls/dsound/primary.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dsound/primary.c	2013-05-17 10:44:20.724233301 +0300
@@ -40,24 +40,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
 
-static DWORD DSOUND_fraglen(DirectSoundDevice *device)
-{
-    REFERENCE_TIME period;
-    HRESULT hr;
-    DWORD ret;
-
-    hr = IAudioClient_GetDevicePeriod(device->client, &period, NULL);
-    if(FAILED(hr)){
-        /* just guess at 10ms */
-        WARN("GetDevicePeriod failed: %08x\n", hr);
-        ret = MulDiv(device->pwfx->nBlockAlign, device->pwfx->nSamplesPerSec, 100);
-    }else
-        ret = MulDiv(device->pwfx->nSamplesPerSec * device->pwfx->nBlockAlign, period, 10000000);
-
-    ret -= ret % device->pwfx->nBlockAlign;
-    return ret;
-}
-
 static HRESULT DSOUND_WaveFormat(DirectSoundDevice *device, IAudioClient *client,
 				 BOOL forcewave, WAVEFORMATEX **wfx)
 {
@@ -146,17 +128,8 @@
     return S_OK;
 }
 
-HRESULT DSOUND_ReopenDevice(DirectSoundDevice *device, BOOL forcewave)
+static void DSOUND_ReleaseDevice(DirectSoundDevice *device)
 {
-    UINT prebuf_frames;
-    REFERENCE_TIME prebuf_rt;
-    WAVEFORMATEX *wfx = NULL;
-    HRESULT hres;
-    REFERENCE_TIME period;
-    DWORD period_ms;
-
-    TRACE("(%p, %d)\n", device, forcewave);
-
     if(device->client){
         IAudioClient_Release(device->client);
         device->client = NULL;
@@ -165,166 +138,88 @@
         IAudioRenderClient_Release(device->render);
         device->render = NULL;
     }
-    if(device->clock){
-        IAudioClock_Release(device->clock);
-        device->clock = NULL;
-    }
     if(device->volume){
         IAudioStreamVolume_Release(device->volume);
         device->volume = NULL;
     }
 
-    hres = IMMDevice_Activate(device->mmdevice, &IID_IAudioClient,
-            CLSCTX_INPROC_SERVER, NULL, (void **)&device->client);
-    if(FAILED(hres)) {
-        WARN("Activate failed: %08x\n", hres);
-        return hres;
-    }
-
-    hres = DSOUND_WaveFormat(device, device->client, forcewave, &wfx);
-    if (FAILED(hres)) {
-        IAudioClient_Release(device->client);
-        device->client = NULL;
-        return hres;
-    }
-    HeapFree(GetProcessHeap(), 0, device->pwfx);
-    device->pwfx = wfx;
-
-    prebuf_frames = device->prebuf * DSOUND_fraglen(device) / device->pwfx->nBlockAlign;
-    prebuf_rt = (10000000 * (UINT64)prebuf_frames) / device->pwfx->nSamplesPerSec;
-
-    hres = IAudioClient_Initialize(device->client,
-            AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_NOPERSIST |
-            AUDCLNT_STREAMFLAGS_EVENTCALLBACK, prebuf_rt, 0, device->pwfx, NULL);
-    if(FAILED(hres)){
-        IAudioClient_Release(device->client);
-        device->client = NULL;
-        WARN("Initialize failed: %08x\n", hres);
-        return hres;
-    }
-    IAudioClient_SetEventHandle(device->client, device->sleepev);
-
-    hres = IAudioClient_GetService(device->client, &IID_IAudioRenderClient,
-            (void**)&device->render);
-    if(FAILED(hres)){
-        IAudioClient_Release(device->client);
-        device->client = NULL;
-        WARN("GetService failed: %08x\n", hres);
-        return hres;
-    }
-
-    hres = IAudioClient_GetService(device->client, &IID_IAudioClock,
-            (void**)&device->clock);
-    if(FAILED(hres)){
-        IAudioClient_Release(device->client);
-        IAudioRenderClient_Release(device->render);
-        device->client = NULL;
-        device->render = NULL;
-        WARN("GetService failed: %08x\n", hres);
-        return hres;
-    }
-
-    hres = IAudioClient_GetService(device->client, &IID_IAudioStreamVolume,
-            (void**)&device->volume);
-    if(FAILED(hres)){
-        IAudioClient_Release(device->client);
-        IAudioRenderClient_Release(device->render);
-        IAudioClock_Release(device->clock);
-        device->client = NULL;
-        device->render = NULL;
-        device->clock = NULL;
-        WARN("GetService failed: %08x\n", hres);
-        return hres;
+    if (device->pad) {
+        device->playpos += device->pad;
+        device->playpos %= device->buflen;
+        device->pad = 0;
     }
-
-    /* Now kick off the timer so the event fires periodically */
-    hres = IAudioClient_Start(device->client);
-    if (FAILED(hres))
-        WARN("starting failed with %08x\n", hres);
-
-    hres = IAudioClient_GetStreamLatency(device->client, &period);
-    if (FAILED(hres)) {
-        WARN("GetStreamLatency failed with %08x\n", hres);
-        period_ms = 10;
-    } else
-        period_ms = (period + 9999) / 10000;
-    TRACE("period %u ms fraglen %u prebuf %u\n", period_ms, device->fraglen, device->prebuf);
-
-    if (period_ms < 3)
-        device->sleeptime = 5;
-    else
-        device->sleeptime = period_ms * 5 / 2;
-
-    return S_OK;
 }
 
-HRESULT DSOUND_PrimaryOpen(DirectSoundDevice *device)
+static HRESULT DSOUND_PrimaryOpen(DirectSoundDevice *device, WAVEFORMATEX *wfx, DWORD aclen, BOOL forcewave)
 {
-	IDirectSoundBufferImpl** dsb = device->buffers;
-	LPBYTE newbuf;
-        int i;
-
-	TRACE("(%p)\n", device);
+    IDirectSoundBufferImpl** dsb = device->buffers;
+    LPBYTE newbuf;
+    DWORD new_buflen;
+    BOOL mixfloat = FALSE;
+    int i;
 
-	device->fraglen = DSOUND_fraglen(device);
+    TRACE("(%p)\n", device);
 
-	/* on original windows, the buffer it set to a fixed size, no matter what the settings are.
-	   on windows this size is always fixed (tested on win-xp) */
-	if (!device->buflen)
-		device->buflen = ds_hel_buflen;
-	device->buflen -= device->buflen % device->pwfx->nBlockAlign;
-	while(device->buflen < device->fraglen * device->prebuf){
-		device->buflen += ds_hel_buflen;
-		device->buflen -= device->buflen % device->pwfx->nBlockAlign;
-	}
-
-	HeapFree(GetProcessHeap(), 0, device->mix_buffer);
-	device->mix_buffer_len = (device->buflen / (device->pwfx->wBitsPerSample / 8)) * sizeof(float);
-	device->mix_buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, device->mix_buffer_len);
-	if (!device->mix_buffer)
-		return DSERR_OUTOFMEMORY;
+    new_buflen = device->buflen;
+    new_buflen -= new_buflen % wfx->nBlockAlign;
 
-	if (device->state == STATE_PLAYING) device->state = STATE_STARTING;
-	else if (device->state == STATE_STOPPING) device->state = STATE_STOPPED;
+    if (wfx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT ||
+        (wfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
+         IsEqualGUID(&((WAVEFORMATEXTENSIBLE*)wfx)->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)))
+        mixfloat = TRUE;
 
     /* reallocate emulated primary buffer */
-    if (device->buffer)
-        newbuf = HeapReAlloc(GetProcessHeap(),0,device->buffer, device->buflen);
-    else
-        newbuf = HeapAlloc(GetProcessHeap(),0, device->buflen);
+    if (forcewave) {
+        if (device->buffer)
+            newbuf = HeapReAlloc(GetProcessHeap(), 0, device->buffer, new_buflen);
+        else
+            newbuf = HeapAlloc(GetProcessHeap(), 0, new_buflen);
 
-    if (!newbuf) {
-        ERR("failed to allocate primary buffer\n");
-        return DSERR_OUTOFMEMORY;
-        /* but the old buffer might still exist and must be re-prepared */
-    }
+        if (!newbuf) {
+            ERR("failed to allocate primary buffer\n");
+            return DSERR_OUTOFMEMORY;
+        }
+        device->mix_buffer_len = 0;
+    } else if (!mixfloat) {
+        DWORD alloc_len = aclen / (wfx->nBlockAlign / 8) * sizeof(float);
+
+        if (device->buffer)
+            newbuf = HeapReAlloc(GetProcessHeap(), 0, device->buffer, alloc_len);
+        else
+            newbuf = HeapAlloc(GetProcessHeap(), 0, alloc_len);
 
-    device->writelead = (device->pwfx->nSamplesPerSec / 100) * device->pwfx->nBlockAlign;
+        if (!newbuf) {
+            ERR("failed to allocate primary buffer\n");
+            return DSERR_OUTOFMEMORY;
+        }
+        device->mix_buffer_len = alloc_len;
+    } else {
+        HeapFree(GetProcessHeap(), 0, device->buffer);
+        newbuf = NULL;
+        device->mix_buffer_len = 0;
+    }
 
     device->buffer = newbuf;
+    device->buflen = new_buflen;
+    HeapFree(GetProcessHeap(), 0, device->pwfx);
+    device->pwfx = wfx;
+
+    device->writelead = (wfx->nSamplesPerSec / 100) * wfx->nBlockAlign;
 
     TRACE("buflen: %u, fraglen: %u, mix_buffer_len: %u\n",
-            device->buflen, device->fraglen, device->mix_buffer_len);
+          device->buflen, device->fraglen, device->mix_buffer_len);
 
-    if(device->pwfx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT ||
-            (device->pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-             IsEqualGUID(&((WAVEFORMATEXTENSIBLE*)device->pwfx)->SubFormat,
-                 &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)))
-        device->normfunction = normfunctions[4];
+    if (!forcewave && !mixfloat)
+        device->normfunction = normfunctions[wfx->nBlockAlign/8 - 1];
     else
-        device->normfunction = normfunctions[device->pwfx->wBitsPerSample/8 - 1];
+        device->normfunction = NULL;
 
-    FillMemory(device->buffer, device->buflen, (device->pwfx->wBitsPerSample == 8) ? 128 : 0);
-    FillMemory(device->mix_buffer, device->mix_buffer_len, 0);
+    if (device->mix_buffer_len)
+        FillMemory(device->buffer, device->mix_buffer_len, 0);
+    else if (device->buffer)
+        FillMemory(device->buffer, device->buflen, (wfx->wBitsPerSample == 8) ? 128 : 0);
     device->playpos = 0;
 
-    if (device->pwfx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT ||
-	 (device->pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-	  IsEqualGUID(&((WAVEFORMATEXTENSIBLE*)device->pwfx)->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)))
-        device->normfunction = normfunctions[4];
-    else
-        device->normfunction = normfunctions[device->pwfx->wBitsPerSample/8 - 1];
-
     for (i = 0; i < device->nrofbuffers; i++) {
         RtlAcquireResourceExclusive(&dsb[i]->lock, TRUE);
         DSOUND_RecalcFormat(dsb[i]);
@@ -334,38 +229,103 @@
     return DS_OK;
 }
 
-
-static void DSOUND_PrimaryClose(DirectSoundDevice *device)
+HRESULT DSOUND_ReopenDevice(DirectSoundDevice *device, BOOL forcewave)
 {
-    HRESULT hr;
+    HRESULT hres;
+    REFERENCE_TIME period;
+    UINT32 frames;
+    DWORD period_ms;
+    IAudioClient *client = NULL;
+    IAudioRenderClient *render = NULL;
+    IAudioStreamVolume *volume = NULL;
+    DWORD fraglen, aclen;
+    WAVEFORMATEX *wfx = NULL;
 
-    TRACE("(%p)\n", device);
+    TRACE("(%p, %d)\n", device, forcewave);
 
-    if(device->client){
-        hr = IAudioClient_Stop(device->client);
-        if(FAILED(hr))
-            WARN("Stop failed: %08x\n", hr);
+    hres = IMMDevice_Activate(device->mmdevice, &IID_IAudioClient,
+            CLSCTX_INPROC_SERVER, NULL, (void **)&client);
+    if(FAILED(hres)){
+        WARN("Activate failed: %08x\n", hres);
+        return hres;
     }
 
-    /* clear the queue */
-    device->in_mmdev_bytes = 0;
-}
+    hres = DSOUND_WaveFormat(device, client, forcewave, &wfx);
+    if (FAILED(hres)) {
+        IAudioClient_Release(client);
+        return hres;
+    }
 
-HRESULT DSOUND_PrimaryCreate(DirectSoundDevice *device)
-{
-	HRESULT err = DS_OK;
-	TRACE("(%p)\n", device);
+    hres = IAudioClient_Initialize(client,
+            AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_NOPERSIST |
+            AUDCLNT_STREAMFLAGS_EVENTCALLBACK, 800000, 0, wfx, NULL);
+    if(FAILED(hres)){
+        IAudioClient_Release(client);
+        ERR("Initialize failed: %08x\n", hres);
+        return hres;
+    }
 
-	device->buflen = ds_hel_buflen;
-	err = DSOUND_PrimaryOpen(device);
+    IAudioClient_SetEventHandle(client, device->sleepev);
 
-	if (err != DS_OK) {
-		WARN("DSOUND_PrimaryOpen failed\n");
-		return err;
-	}
+    hres = IAudioClient_GetService(client, &IID_IAudioRenderClient, (void**)&render);
+    if(FAILED(hres))
+        goto err_service;
+
+    hres = IAudioClient_GetService(client, &IID_IAudioStreamVolume, (void**)&volume);
+    if(FAILED(hres))
+        goto err_service;
 
-	device->state = STATE_STOPPED;
-	return DS_OK;
+    /* Now kick off the timer so the event fires periodically */
+    hres = IAudioClient_Start(client);
+    if (FAILED(hres)) {
+        WARN("Start failed with %08x\n", hres);
+        goto err;
+    }
+    hres = IAudioClient_GetStreamLatency(client, &period);
+    if (FAILED(hres)) {
+        WARN("GetStreamLatency failed with %08x\n", hres);
+        goto err;
+    }
+    hres = IAudioClient_GetBufferSize(client, &frames);
+    if (FAILED(hres)) {
+        WARN("GetBufferSize failed with %08x\n", hres);
+        goto err;
+    }
+
+    period_ms = (period + 9999) / 10000;
+    fraglen = MulDiv(wfx->nSamplesPerSec, period, 10000000) * wfx->nBlockAlign;
+    aclen = frames * wfx->nBlockAlign;
+    TRACE("period %u ms fraglen %u buflen %u\n", period_ms, fraglen, aclen);
+
+    hres = DSOUND_PrimaryOpen(device, wfx, aclen, forcewave);
+    if(FAILED(hres))
+        goto err;
+
+    DSOUND_ReleaseDevice(device);
+    device->client = client;
+    device->render = render;
+    device->volume = volume;
+    device->fraglen = fraglen;
+    device->aclen = aclen;
+
+    if (period_ms < 3)
+        device->sleeptime = 5;
+    else
+        device->sleeptime = period_ms * 5 / 2;
+
+    return S_OK;
+
+err_service:
+    WARN("GetService failed: %08x\n", hres);
+err:
+    if (volume)
+        IAudioStreamVolume_Release(volume);
+    if (render)
+        IAudioRenderClient_Release(render);
+    if (client)
+        IAudioClient_Release(client);
+    HeapFree(GetProcessHeap(), 0, wfx);
+    return hres;
 }
 
 HRESULT DSOUND_PrimaryDestroy(DirectSoundDevice *device)
@@ -375,8 +335,6 @@
 	/* **** */
 	EnterCriticalSection(&(device->mixlock));
 
-	DSOUND_PrimaryClose(device);
-
 	if(device->primary && (device->primary->ref || device->primary->numIfaces))
 		WARN("Destroying primary buffer while references held (%u %u)\n", device->primary->ref, device->primary->numIfaces);
 
@@ -393,53 +351,6 @@
 	return DS_OK;
 }
 
-HRESULT DSOUND_PrimaryPlay(DirectSoundDevice *device)
-{
-    HRESULT hr;
-
-    TRACE("(%p)\n", device);
-
-    hr = IAudioClient_Start(device->client);
-    if(FAILED(hr) && hr != AUDCLNT_E_NOT_STOPPED){
-        WARN("Start failed: %08x\n", hr);
-        return hr;
-    }
-
-    return DS_OK;
-}
-
-HRESULT DSOUND_PrimaryStop(DirectSoundDevice *device)
-{
-    HRESULT hr;
-
-    TRACE("(%p)\n", device);
-
-    hr = IAudioClient_Stop(device->client);
-    if(FAILED(hr)){
-        WARN("Stop failed: %08x\n", hr);
-        return hr;
-    }
-
-    return DS_OK;
-}
-
-HRESULT DSOUND_PrimaryGetPosition(DirectSoundDevice *device, LPDWORD playpos, LPDWORD writepos)
-{
-	TRACE("(%p,%p,%p)\n", device, playpos, writepos);
-
-	/* check if playpos was requested */
-	if (playpos)
-		*playpos = device->playing_offs_bytes;
-
-	/* check if writepos was requested */
-	if (writepos)
-		/* the writepos is the first non-queued position */
-		*writepos = (device->playing_offs_bytes + device->in_mmdev_bytes) % device->buflen;
-
-	TRACE("playpos = %d, writepos = %d (%p, time=%d)\n", playpos?*playpos:-1, writepos?*writepos:-1, device, GetTickCount());
-	return DS_OK;
-}
-
 static DWORD DSOUND_GetFormatSize(LPCWAVEFORMATEX wfex)
 {
 	if (wfex->wFormatTag == WAVE_FORMAT_PCM)
@@ -476,7 +387,6 @@
 	HRESULT err = S_OK;
 	WAVEFORMATEX *old_fmt;
 	WAVEFORMATEXTENSIBLE *fmtex, *passed_fmtex = (WAVEFORMATEXTENSIBLE*)passed_fmt;
-	BOOL forced = (device->priolevel == DSSCL_WRITEPRIMARY);
 
 	TRACE("(%p,%p)\n", device, passed_fmt);
 
@@ -526,24 +436,12 @@
 			fmtex->Samples.wValidBitsPerSample = fmtex->Format.wBitsPerSample;
 		}
 
-		DSOUND_PrimaryClose(device);
-
-		err = DSOUND_ReopenDevice(device, forced);
+		err = DSOUND_ReopenDevice(device, TRUE);
 		if (FAILED(err)) {
 			ERR("No formats could be opened\n");
-			goto done;
-		}
-
-		err = DSOUND_PrimaryOpen(device);
-		if (err != DS_OK) {
-			ERR("DSOUND_PrimaryOpen failed\n");
-			goto done;
-		}
-
-done:
-		if (err != DS_OK)
+			HeapFree(GetProcessHeap(), 0, device->primary_pwfx);
 			device->primary_pwfx = old_fmt;
-		else
+		} else
 			HeapFree(GetProcessHeap(), 0, old_fmt);
 	} else if (passed_fmt->wFormatTag == WAVE_FORMAT_PCM ||
 		   passed_fmt->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
@@ -556,10 +454,15 @@
 		if (IsEqualGUID(&fmtex->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) &&
 		    passed_fmt->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
 			fmt->wFormatTag = WAVE_FORMAT_IEEE_FLOAT;
+			fmt->wBitsPerSample = 32;
 		} else {
 			fmt->wFormatTag = WAVE_FORMAT_PCM;
-			fmt->wBitsPerSample = 16;
+			fmt->wBitsPerSample = passed_fmt->wBitsPerSample;
 		}
+		fmt->nSamplesPerSec = passed_fmt->nSamplesPerSec;
+		fmt->nChannels = passed_fmt->nChannels;
+		if (fmt->nChannels > device->pwfx->nChannels)
+			fmt->nChannels = device->pwfx->nChannels;
 		fmt->nBlockAlign = fmt->nChannels * fmt->wBitsPerSample / 8;
 		fmt->nAvgBytesPerSec = fmt->nBlockAlign * fmt->nSamplesPerSec;
 		fmt->cbSize = 0;
@@ -735,16 +638,7 @@
 		return DSERR_INVALIDPARAM;
 	}
 
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-	if (device->state == STATE_STOPPED)
-		device->state = STATE_STARTING;
-	else if (device->state == STATE_STOPPING)
-		device->state = STATE_PLAYING;
-
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
+	device->stopped = 0;
 
 	return DS_OK;
 }
@@ -755,16 +649,7 @@
         DirectSoundDevice *device = This->device;
 	TRACE("(%p)\n", iface);
 
-	/* **** */
-	EnterCriticalSection(&(device->mixlock));
-
-	if (device->state == STATE_PLAYING)
-		device->state = STATE_STOPPING;
-	else if (device->state == STATE_STARTING)
-		device->state = STATE_STOPPED;
-
-	LeaveCriticalSection(&(device->mixlock));
-	/* **** */
+	device->stopped = 1;
 
 	return DS_OK;
 }
@@ -810,7 +695,9 @@
 static HRESULT WINAPI PrimaryBufferImpl_GetCurrentPosition(IDirectSoundBuffer *iface,
         DWORD *playpos, DWORD *writepos)
 {
-	HRESULT	hres;
+	HRESULT	hres = DS_OK;
+	UINT32 pad = 0;
+	UINT32 mixpos;
         IDirectSoundBufferImpl *This = impl_from_IDirectSoundBuffer(iface);
         DirectSoundDevice *device = This->device;
 	TRACE("(%p,%p,%p)\n", iface, playpos, writepos);
@@ -818,17 +705,23 @@
 	/* **** */
 	EnterCriticalSection(&(device->mixlock));
 
-	hres = DSOUND_PrimaryGetPosition(device, playpos, writepos);
+	if (device->client)
+		hres = IAudioClient_GetCurrentPadding(device->client, &pad);
 	if (hres != DS_OK) {
-		WARN("DSOUND_PrimaryGetPosition failed\n");
+		WARN("IAudioClient_GetCurrentPadding failed\n");
 		LeaveCriticalSection(&(device->mixlock));
 		return hres;
 	}
+	mixpos = (device->playpos + pad * device->pwfx->nBlockAlign) % device->buflen;
+	if (playpos)
+		*playpos = mixpos;
 	if (writepos) {
-		if (device->state != STATE_STOPPED)
+		*writepos = mixpos;
+		if (!device->stopped) {
 			/* apply the documented 10ms lead to writepos */
 			*writepos += device->writelead;
-		while (*writepos >= device->buflen) *writepos -= device->buflen;
+			*writepos %= device->buflen;
+		}
 	}
 
 	LeaveCriticalSection(&(device->mixlock));
@@ -850,8 +743,7 @@
 	}
 
 	*status = 0;
-	if ((device->state == STATE_STARTING) ||
-	    (device->state == STATE_PLAYING))
+	if (!device->stopped)
 		*status |= DSBSTATUS_PLAYING | DSBSTATUS_LOOPING;
 
 	TRACE("status=%x\n", *status);
diff -urN wine-1.5.30/dlls/dwrite/main.c wine-multimedia/dlls/dwrite/main.c
--- wine-1.5.30/dlls/dwrite/main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dwrite/main.c	2013-05-17 10:44:20.731233213 +0300
@@ -44,6 +44,7 @@
         DisableThreadLibraryCalls( hinstDLL );
         break;
     case DLL_PROCESS_DETACH:
+        if (reserved) break;
         release_system_fontcollection();
         break;
     }
diff -urN wine-1.5.30/dlls/dxgi/dxgi_main.c wine-multimedia/dlls/dxgi/dxgi_main.c
--- wine-1.5.30/dlls/dxgi/dxgi_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/dxgi/dxgi_main.c	2013-05-17 10:44:20.741233088 +0300
@@ -44,16 +44,8 @@
 
 static void dxgi_main_cleanup(void)
 {
-    EnterCriticalSection(&dxgi_cs);
-
     HeapFree(GetProcessHeap(), 0, dxgi_main.device_layers);
-    dxgi_main.device_layers = NULL;
-    dxgi_main.layer_count = 0;
-
     FreeLibrary(dxgi_main.d3d10core);
-    dxgi_main.d3d10core = NULL;
-
-    LeaveCriticalSection(&dxgi_cs);
     DeleteCriticalSection(&dxgi_cs);
 }
 
@@ -68,6 +60,7 @@
             break;
 
         case DLL_PROCESS_DETACH:
+            if (lpv) break;
             dxgi_main_cleanup();
             break;
     }
diff -urN wine-1.5.30/dlls/gdiplus/gdiplus.c wine-multimedia/dlls/gdiplus/gdiplus.c
--- wine-1.5.30/dlls/gdiplus/gdiplus.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/gdiplus/gdiplus.c	2013-05-17 10:44:20.790232476 +0300
@@ -66,6 +66,7 @@
         break;
 
     case DLL_PROCESS_DETACH:
+        if (reserved) break;
         free_installed_fonts();
         break;
     }
diff -urN wine-1.5.30/dlls/ieframe/ieframe_main.c wine-multimedia/dlls/ieframe/ieframe_main.c
--- wine-1.5.30/dlls/ieframe/ieframe_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/ieframe/ieframe_main.c	2013-05-17 10:44:20.812232201 +0300
@@ -218,6 +218,7 @@
         DisableThreadLibraryCalls(ieframe_instance);
         break;
     case DLL_PROCESS_DETACH:
+        if (lpv) break;
         unregister_iewindow_class();
         release_typelib();
     }
diff -urN wine-1.5.30/dlls/ieframe/shellbrowser.c wine-multimedia/dlls/ieframe/shellbrowser.c
--- wine-1.5.30/dlls/ieframe/shellbrowser.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/ieframe/shellbrowser.c	2013-05-17 10:44:20.815232163 +0300
@@ -824,12 +824,18 @@
     V_VT(&url_var) = VT_BSTR;
     V_BSTR(&url_var) = url;
 
+    /* Keep reference to This. It may be released in event handler. */
+    IShellBrowser_AddRef(&This->IShellBrowser_iface);
+
     TRACE(">>>\n");
     call_sink(This->doc_host->cps.wbe2, DISPID_DOCUMENTCOMPLETE, &dp);
     TRACE("<<<\n");
 
     SysFreeString(url);
-    This->doc_host->busy = VARIANT_FALSE;
+    if(This->doc_host)
+        This->doc_host->busy = VARIANT_FALSE;
+
+    IShellBrowser_Release(&This->IShellBrowser_iface);
     return S_OK;
 }
 
diff -urN wine-1.5.30/dlls/imm32/imm.c wine-multimedia/dlls/imm32/imm.c
--- wine-1.5.30/dlls/imm32/imm.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/imm32/imm.c	2013-05-17 10:44:20.820232101 +0300
@@ -386,6 +386,7 @@
             IMM_FreeThreadData();
             break;
         case DLL_PROCESS_DETACH:
+            if (lpReserved) break;
             IMM_FreeThreadData();
             IMM_FreeAllImmHkl();
             TlsFree(tlsIndex);
diff -urN wine-1.5.30/dlls/inetcomm/inetcomm_main.c wine-multimedia/dlls/inetcomm/inetcomm_main.c
--- wine-1.5.30/dlls/inetcomm/inetcomm_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/inetcomm/inetcomm_main.c	2013-05-17 10:44:20.821232088 +0300
@@ -58,11 +58,10 @@
         MimeInternational_Construct(&international);
         break;
     case DLL_PROCESS_DETACH:
+        if (lpvReserved) break;
         IMimeInternational_Release(international);
         InternetTransport_UnregisterClass(hinstDLL);
         break;
-    default:
-        break;
     }
     return TRUE;
 }
diff -urN wine-1.5.30/dlls/inetmib1/main.c wine-multimedia/dlls/inetmib1/main.c
--- wine-1.5.30/dlls/inetmib1/main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/inetmib1/main.c	2013-05-17 10:44:20.826232026 +0300
@@ -1454,10 +1454,9 @@
             DisableThreadLibraryCalls(hinstDLL);
             break;
         case DLL_PROCESS_DETACH:
+            if (lpvReserved) break;
             cleanup();
             break;
-        default:
-            break;
     }
 
     return TRUE;
diff -urN wine-1.5.30/dlls/jscript/jscript_main.c wine-multimedia/dlls/jscript/jscript_main.c
--- wine-1.5.30/dlls/jscript/jscript_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/jscript/jscript_main.c	2013-05-17 10:44:20.842231826 +0300
@@ -144,6 +144,7 @@
             return FALSE;
         break;
     case DLL_PROCESS_DETACH:
+        if (lpv) break;
         free_strings();
     }
 
diff -urN wine-1.5.30/dlls/kernel32/tests/loader.c wine-multimedia/dlls/kernel32/tests/loader.c
--- wine-1.5.30/dlls/kernel32/tests/loader.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/kernel32/tests/loader.c	2013-05-17 10:44:20.883231313 +0300
@@ -1060,12 +1060,12 @@
 #define MAX_COUNT 10
 static HANDLE attached_thread[MAX_COUNT];
 static DWORD attached_thread_count;
-HANDLE stop_event, event, mutex, semaphore, loader_lock_event, peb_lock_event, ack_event;
-static int test_dll_phase, inside_loader_lock, inside_peb_lock;
+HANDLE stop_event, event, mutex, semaphore, loader_lock_event, peb_lock_event, heap_lock_event, ack_event;
+static int test_dll_phase, inside_loader_lock, inside_peb_lock, inside_heap_lock;
 
 static DWORD WINAPI mutex_thread_proc(void *param)
 {
-    HANDLE wait_list[3];
+    HANDLE wait_list[4];
     DWORD ret;
 
     ret = WaitForSingleObject(mutex, 0);
@@ -1076,11 +1076,12 @@
     wait_list[0] = stop_event;
     wait_list[1] = loader_lock_event;
     wait_list[2] = peb_lock_event;
+    wait_list[3] = heap_lock_event;
 
     while (1)
     {
         trace("%04u: mutex_thread_proc: still alive\n", GetCurrentThreadId());
-        ret = WaitForMultipleObjects(3, wait_list, FALSE, 50);
+        ret = WaitForMultipleObjects(sizeof(wait_list)/sizeof(wait_list[0]), wait_list, FALSE, 50);
         if (ret == WAIT_OBJECT_0) break;
         else if (ret == WAIT_OBJECT_0 + 1)
         {
@@ -1098,6 +1099,13 @@
             inside_peb_lock++;
             SetEvent(ack_event);
         }
+        else if (ret == WAIT_OBJECT_0 + 3)
+        {
+            trace("%04u: mutex_thread_proc: Entering heap lock\n", GetCurrentThreadId());
+            HeapLock(GetProcessHeap());
+            inside_heap_lock++;
+            SetEvent(ack_event);
+        }
     }
 
     trace("%04u: mutex_thread_proc: exiting\n", GetCurrentThreadId());
@@ -1169,6 +1177,18 @@
             break;
         }
 
+        /* The process should already deadlock at this point */
+        if (test_dll_phase == 6)
+        {
+            /* In reality, code below never gets executed, probably some other
+             * code tries to access process heap and deadlocks earlier, even XP
+             * doesn't call the DLL entry point on process detach either.
+             */
+            HeapLock(GetProcessHeap());
+            ok(0, "dll_entry_point: process should already deadlock\n");
+            break;
+        }
+
         if (test_dll_phase == 0 || test_dll_phase == 1 || test_dll_phase == 3)
             ok(param != NULL, "dll: param %p\n", param);
         else
@@ -1444,6 +1464,10 @@
     ok(peb_lock_event != 0, "CreateEvent error %d\n", GetLastError());
 
     SetLastError(0xdeadbeef);
+    heap_lock_event = CreateEvent(NULL, FALSE, FALSE, NULL);
+    ok(heap_lock_event != 0, "CreateEvent error %d\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
     ack_event = CreateEvent(NULL, FALSE, FALSE, NULL);
     ok(ack_event != 0, "CreateEvent error %d\n", GetLastError());
 
@@ -1644,6 +1668,20 @@
         ok(0, "ExitProcess should not return\n");
         break;
 
+    case 6:
+        trace("setting heap_lock_event\n");
+        SetEvent(heap_lock_event);
+        WaitForSingleObject(ack_event, 1000);
+        ok(inside_heap_lock != 0, "inside_heap_lock is not set\n");
+
+        *child_failures = winetest_get_failures();
+
+        /* calling ExitProcess should cause a deadlock */
+        trace("call ExitProcess(1)\n");
+        ExitProcess(1);
+        ok(0, "ExitProcess should not return\n");
+        break;
+
     default:
         assert(0);
         break;
@@ -1923,6 +1961,30 @@
     else
         win_skip("RtlAcquirePebLock/RtlReleasePebLock are not available on this platform\n");
 
+    /* phase 6 */
+    *child_failures = -1;
+    sprintf(cmdline, "\"%s\" loader %s %u 6", argv[0], dll_name, target_offset);
+    ret = CreateProcess(argv[0], cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+    ok(ret, "CreateProcess(%s) error %d\n", cmdline, GetLastError());
+    ret = WaitForSingleObject(pi.hProcess, 5000);
+    ok(ret == WAIT_TIMEOUT || broken(ret == WAIT_OBJECT_0) /* XP */, "child process should fail to terminate\n");
+    if (ret != WAIT_OBJECT_0)
+    {
+        trace("terminating child process\n");
+        TerminateProcess(pi.hProcess, 201);
+    }
+    ret = WaitForSingleObject(pi.hProcess, 1000);
+    ok(ret == WAIT_OBJECT_0, "child process failed to terminate\n");
+    GetExitCodeProcess(pi.hProcess, &ret);
+    ok(ret == 201 || broken(ret == 1) /* XP */, "expected exit code 201, got %u\n", ret);
+    if (*child_failures)
+    {
+        trace("%d failures in child process\n", *child_failures);
+        winetest_add_failures(*child_failures);
+    }
+    CloseHandle(pi.hThread);
+    CloseHandle(pi.hProcess);
+
     /* test remote process termination */
     SetLastError(0xdeadbeef);
     ret = CreateProcess(argv[0], NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
diff -urN wine-1.5.30/dlls/mmdevapi/main.c wine-multimedia/dlls/mmdevapi/main.c
--- wine-1.5.30/dlls/mmdevapi/main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/mmdevapi/main.c	2013-05-17 10:44:20.924230800 +0300
@@ -110,7 +110,7 @@
 {
     static const WCHAR drv_value[] = {'A','u','d','i','o',0};
 
-    static WCHAR default_list[] = {'a','l','s','a',',','o','s','s',',',
+    static WCHAR default_list[] = {'p','u','l','s','e',',','a','l','s','a',',','o','s','s',',',
         'c','o','r','e','a','u','d','i','o',0};
 
     DriverFuncs driver;
diff -urN wine-1.5.30/dlls/mmdevapi/tests/capture.c wine-multimedia/dlls/mmdevapi/tests/capture.c
--- wine-1.5.30/dlls/mmdevapi/tests/capture.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/mmdevapi/tests/capture.c	2013-05-17 10:44:20.925230788 +0300
@@ -240,7 +240,7 @@
         ok(hr == S_OK, "Valid IAudioCaptureClient_GetBuffer returns %08x\n", hr);
         ok(frames2 == frames, "GetBuffer after ReleaseBuffer(0) %u/%u\n", frames2, frames);
         ok(pos2 == pos, "Position after ReleaseBuffer(0) %u/%u\n", (UINT)pos2, (UINT)pos);
-        todo_wine ok(qpc2 == qpc, "HPC after ReleaseBuffer(0) %u vs. %u\n", (UINT)qpc2, (UINT)qpc);
+        ok(qpc2 == qpc, "HPC after ReleaseBuffer(0) %u vs. %u\n", (UINT)qpc2, (UINT)qpc);
     }
 
     /* trace after the GCP test because log output to MS-DOS console disturbs timing */
@@ -303,13 +303,13 @@
 
     if(hr == S_OK){
         /* The discontinuity is reported here, but is this an old or new packet? */
-        todo_wine ok(flags & AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY, "expect DISCONTINUITY %x\n", flags);
+        ok(flags & AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY, "expect DISCONTINUITY %x\n", flags);
         ok(pad == next, "GCP %u vs. BufferSize %u\n", (UINT32)pad, next);
 
         /* Native's position is one period further than what we read.
          * Perhaps that's precisely the meaning of DATA_DISCONTINUITY:
          * signal when the position jump left a gap. */
-        todo_wine ok(pos == sum + frames, "Position %u gap %d\n",
+        ok(pos == sum + frames, "Position %u gap %d\n",
                      (UINT)pos, (UINT)pos - sum);
         if(flags & AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY)
             sum = pos;
@@ -387,7 +387,7 @@
         /* Only PulseAudio goes here; despite snd_pcm_drop it manages
          * to fill GetBufferSize with a single snd_pcm_read */
         trace("Test marked todo: only PulseAudio gets here\n");
-        todo_wine ok(flags & AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY, "expect DISCONTINUITY %x\n", flags);
+        ok(flags & AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY, "expect DISCONTINUITY %x\n", flags);
         /* Reset zeroes padding, not the position */
         ok(pos >= sum, "Position %u last %u\n", (UINT)pos, sum);
         /*sum = pos; check after next GetBuffer */
@@ -423,7 +423,7 @@
 
     /* Still receiving events! */
     r = WaitForSingleObject(handle, 20);
-    todo_wine ok(r == WAIT_OBJECT_0, "Wait(event) after Stop gave %x\n", r);
+    ok(r == WAIT_OBJECT_0, "Wait(event) after Stop gave %x\n", r);
 
     hr = IAudioClient_Reset(ac);
     ok(hr == S_OK, "Reset failed: %08x\n", hr);
@@ -431,13 +431,13 @@
     ok(ResetEvent(handle), "ResetEvent\n");
 
     r = WaitForSingleObject(handle, 120);
-    todo_wine ok(r == WAIT_OBJECT_0, "Wait(event) after Reset gave %x\n", r);
+    ok(r == WAIT_OBJECT_0, "Wait(event) after Reset gave %x\n", r);
 
     hr = IAudioClient_SetEventHandle(ac, NULL);
     ok(hr == E_INVALIDARG, "SetEventHandle(NULL) returns %08x\n", hr);
 
     r = WaitForSingleObject(handle, 70);
-    todo_wine ok(r == WAIT_OBJECT_0, "Wait(NULL event) gave %x\n", r);
+    ok(r == WAIT_OBJECT_0, "Wait(NULL event) gave %x\n", r);
 
     hr = IAudioClient_Start(ac);
     ok(hr == S_OK, "Start failed: %08x\n", hr);
diff -urN wine-1.5.30/dlls/mmdevapi/tests/render.c wine-multimedia/dlls/mmdevapi/tests/render.c
--- wine-1.5.30/dlls/mmdevapi/tests/render.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/mmdevapi/tests/render.c	2013-05-17 10:44:20.926230775 +0300
@@ -472,6 +472,169 @@
     }
 }
 
+static void test_formats2(void)
+{
+    IAudioClient *ac;
+    HRESULT hr;
+    WAVEFORMATEX *pwfx, *pwfx2;
+    WAVEFORMATEXTENSIBLE *pwfe, wfe, *pwfe2;
+
+    hr = IMMDevice_Activate(dev, &IID_IAudioClient, CLSCTX_INPROC_SERVER,
+                            NULL, (void**)&ac);
+
+    ok(hr == S_OK, "Activation failed with %08x\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IAudioClient_GetMixFormat(ac, &pwfx);
+    ok(hr == S_OK, "GetMixFormat failed: %08x\n", hr);
+    if (hr != S_OK)
+        return;
+
+    ok(pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE, "Invalid wFormatTag\n");
+    if (pwfx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
+        CoTaskMemFree(pwfx);
+        return;
+    }
+
+    pwfe = (WAVEFORMATEXTENSIBLE*)pwfx;
+    ok(pwfe->Samples.wValidBitsPerSample, "wValidBitsPerSample should be non-zero\n");
+
+    if (pwfx->nChannels > 2) {
+        trace("Limiting channels to 2\n");
+        pwfx->nChannels = 2;
+        pwfx->nBlockAlign = pwfx->wBitsPerSample / 8 * pwfx->nChannels;
+        pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
+        pwfe->dwChannelMask = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
+    }
+
+    wfe = *pwfe;
+    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign = 0;
+
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with nAvgBytesPerSec=0 and nBlockAlign=0 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == E_INVALIDARG && !pwfx2,
+       "Shared IsFormatSupported with nAvgBytesPerSec=0 and nBlockAlign=0 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    pwfx->wFormatTag = WAVE_FORMAT_PCM;
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK && !pwfx2,
+       "Shared IsFormatSupported with nAvgBytesPerSec=0 and nBlockAlign=0 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfe->dwChannelMask = 0;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=0 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK,
+       "Shared IsFormatSupported with dwChannelMask=0 returned %08x\n", hr);
+    CoTaskMemFree(pwfx2);
+
+
+    pwfe->dwChannelMask = 0x3ffff;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=0x3ffff returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK && !pwfx2,
+       "Shared IsFormatSupported with dwChannelMask=0x3ffff returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+
+    pwfe->dwChannelMask = 0x40000000;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=0x40000000 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK && !pwfx2,
+       "Shared IsFormatSupported with dwChannelMask=0x40000000 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    pwfe->dwChannelMask = SPEAKER_ALL | SPEAKER_RESERVED;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=SPEAKER_ALL | SPEAKER_RESERVED returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK && !pwfx2,
+       "Shared IsFormatSupported with dwChannelMask=SPEAKER_ALL | SPEAKER_RESERVED returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfe->Samples.wValidBitsPerSample = 0;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with wValidBitsPerSample=0 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_FALSE && pwfx2,
+       "Shared IsFormatSupported with wValidBitsPerSample=0 returned %08x %p\n", hr, pwfx2);
+    if (pwfx2) {
+        pwfe2 = (WAVEFORMATEXTENSIBLE*)pwfx2;
+        ok(pwfe2->Samples.wValidBitsPerSample == pwfx->wBitsPerSample,
+           "Shared IsFormatSupported had wValidBitsPerSample set to %u, not %u\n",
+           pwfe2->Samples.wValidBitsPerSample, pwfx->wBitsPerSample);
+        CoTaskMemFree(pwfx2);
+    }
+
+    pwfx2 = NULL;
+    pwfe->Samples.wValidBitsPerSample = pwfx->wBitsPerSample + 1;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == E_INVALIDARG && !pwfx2,
+       "Shared IsFormatSupported with wValidBitsPerSample += 1 returned %08x %p\n", hr, pwfx2);
+
+    *pwfe = wfe;
+    memset(&pwfe->SubFormat, 0xff, 16);
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT && !pwfx2,
+       "Shared IsFormatSupported with SubFormat=-1 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfx2 = NULL;
+    pwfe->Samples.wValidBitsPerSample = pwfx->wBitsPerSample = 256;
+    pwfx->nBlockAlign = pwfx->wBitsPerSample / 8 * pwfx->nChannels;
+    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == E_INVALIDARG && !pwfx2,
+       "Shared IsFormatSupported with wBitsPerSample=256 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfx2 = NULL;
+    pwfe->Samples.wValidBitsPerSample = pwfx->wBitsPerSample - 1;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_FALSE && pwfx2,
+       "Shared IsFormatSupported with wValidBitsPerSample-=1 returned %08x %p\n", hr, pwfx2);
+    if (pwfx2) {
+        pwfe2 = (WAVEFORMATEXTENSIBLE*)pwfx2;
+        ok(pwfe2->Samples.wValidBitsPerSample == pwfx->wBitsPerSample,
+           "Shared IsFormatSupported had wValidBitsPerSample set to %u, not %u\n",
+           pwfe2->Samples.wValidBitsPerSample, pwfx->wBitsPerSample);
+        CoTaskMemFree(pwfx2);
+    }
+
+    CoTaskMemFree(pwfx);
+    IAudioClient_Release(ac);
+}
+
 static void test_references(void)
 {
     IAudioClient *ac;
@@ -656,7 +819,7 @@
 
     /* Still receiving events! */
     r = WaitForSingleObject(event, 20);
-    todo_wine ok(r == WAIT_OBJECT_0, "Wait(event) after Stop gave %x\n", r);
+    ok(r == WAIT_OBJECT_0, "Wait(event) after Stop gave %x\n", r);
 
     hr = IAudioClient_Reset(ac);
     ok(hr == S_OK, "Reset failed: %08x\n", hr);
@@ -664,13 +827,13 @@
     ok(ResetEvent(event), "ResetEvent\n");
 
     r = WaitForSingleObject(event, 120);
-    todo_wine ok(r == WAIT_OBJECT_0, "Wait(event) after Reset gave %x\n", r);
+    ok(r == WAIT_OBJECT_0, "Wait(event) after Reset gave %x\n", r);
 
     hr = IAudioClient_SetEventHandle(ac, NULL);
     ok(hr == E_INVALIDARG, "SetEventHandle(NULL) returns %08x\n", hr);
 
     r = WaitForSingleObject(event, 70);
-    todo_wine ok(r == WAIT_OBJECT_0, "Wait(NULL event) gave %x\n", r);
+    ok(r == WAIT_OBJECT_0, "Wait(NULL event) gave %x\n", r);
 
     /* test releasing a playing stream */
     hr = IAudioClient_Start(ac);
@@ -929,7 +1092,7 @@
     if (share)
     ok(gbsize == bufsize,
        "BufferSize %u at rate %u\n", gbsize, pwfx->nSamplesPerSec);
-    else todo_wine
+    else
     ok(gbsize == parts * fragment || gbsize == MulDiv(bufsize, 1, 1024) * 1024,
        "BufferSize %u misfits fragment size %u at rate %u\n", gbsize, fragment, pwfx->nSamplesPerSec);
 
@@ -949,7 +1112,7 @@
     trace("Clock Frequency %u\n", (UINT)freq);
 
     /* MSDN says it's arbitrary units, but shared mode is unlikely to change */
-    if (share) todo_wine
+    if (share)
         ok(freq == pwfx->nSamplesPerSec * pwfx->nBlockAlign,
            "Clock Frequency %u\n", (UINT)freq);
     else
@@ -977,7 +1140,7 @@
     ok(hr == S_OK, "GetBuffer failed: %08x\n", hr);
     trace("data at %p\n", data);
 
-    hr = IAudioRenderClient_ReleaseBuffer(arc, avail, winetest_debug>2 ?
+    hr = IAudioRenderClient_ReleaseBuffer(arc, avail, winetest_interactive ?
         wave_generate_tone(pwfx, data, avail) : AUDCLNT_BUFFERFLAGS_SILENT);
     ok(hr == S_OK, "ReleaseBuffer failed: %08x\n", hr);
     if(hr == S_OK) sum += avail;
@@ -1014,8 +1177,7 @@
     ok(hr == S_OK, "GetPosition failed: %08x\n", hr);
     ok(pos >= last, "Position %u vs. last %u\n", (UINT)pos,(UINT)last);
     last = pos;
-    if(/*share &&*/ winetest_debug>1) todo_wine
-        ok(pos*1000/freq <= slept*1.1, "Position %u too far after stop %ums\n", (UINT)pos, slept);
+    ok(pos*1000/freq <= slept*1.1, "Position %u too far after stop %ums\n", (UINT)pos, slept);
 
     hr = IAudioClient_Start(ac); /* #2 */
     ok(hr == S_OK, "Start failed: %08x\n", hr);
@@ -1048,12 +1210,11 @@
     ok(pos * pwfx->nSamplesPerSec <= sum * freq, "Position %u > written %u\n", (UINT)pos, sum);
     /* Prove that Stop must not drop frames (in shared mode). */
     ok(pad ? pos > last : pos >= last, "Position %u vs. last %u\n", (UINT)pos,(UINT)last);
-    if (share && pad > 0 && winetest_debug>1) todo_wine
+    if (share && pad > 0)
         ok(pos*1000/freq <= slept*1.1, "Position %u too far after playing %ums\n", (UINT)pos, slept);
     /* in exclusive mode, testbot's w7 machines yield pos > sum-pad */
-    if(/*share &&*/ winetest_debug>1)
-        ok(pos * pwfx->nSamplesPerSec == (sum-pad) * freq,
-           "Position %u after stop vs. %u padding\n", (UINT)pos, pad);
+    ok(pos * pwfx->nSamplesPerSec == (sum-pad) * freq,
+       "Position %u after stop vs. %u padding\n", (UINT)pos, pad);
     last = pos;
 
     Sleep(100);
@@ -1081,7 +1242,7 @@
     ok(hr == S_OK, "GetBuffer failed: %08x\n", hr);
     trace("data at %p\n", data);
 
-    hr = IAudioRenderClient_ReleaseBuffer(arc, avail, winetest_debug>2 ?
+    hr = IAudioRenderClient_ReleaseBuffer(arc, avail, winetest_interactive ?
         wave_generate_tone(pwfx, data, avail) : AUDCLNT_BUFFERFLAGS_SILENT);
     ok(hr == S_OK, "ReleaseBuffer failed: %08x\n", hr);
     if(hr == S_OK) sum += avail;
@@ -1106,10 +1267,7 @@
     trace("position %u past %ums sleep #3\n", (UINT)pos, slept);
     ok(pos > last, "Position %u vs. last %u\n", (UINT)pos,(UINT)last);
     ok(pos * pwfx->nSamplesPerSec <= sum * freq, "Position %u > written %u\n", (UINT)pos, sum);
-    if (winetest_debug>1)
-        ok(pos*1000/freq <= slept*1.1, "Position %u too far after playing %ums\n", (UINT)pos, slept);
-    else
-        skip("Rerun with WINETEST_DEBUG=2 for GetPosition tests.\n");
+    ok(pos*1000/freq <= slept*1.1, "Position %u too far after playing %ums\n", (UINT)pos, slept);
     last = pos;
 
     hr = IAudioClient_Reset(ac);
@@ -1127,11 +1285,10 @@
     ok(pos >= last, "Position %u vs. last %u\n", (UINT)pos,(UINT)last);
     ok(pcpos > pcpos0, "pcpos should increase\n");
     ok(pos * pwfx->nSamplesPerSec <= sum * freq, "Position %u > written %u\n", (UINT)pos, sum);
-    if (pad > 0 && winetest_debug>1) todo_wine
+    if (pad > 0)
         ok(pos*1000/freq <= slept*1.1, "Position %u too far after stop %ums\n", (UINT)pos, slept);
-    if(winetest_debug>1)
-        ok(pos * pwfx->nSamplesPerSec == (sum-pad) * freq,
-           "Position %u after stop vs. %u padding\n", (UINT)pos, pad);
+    ok(pos * pwfx->nSamplesPerSec == (sum-pad) * freq,
+       "Position %u after stop vs. %u padding\n", (UINT)pos, pad);
     last = pos;
 
     /* Begin the big loop */
@@ -1154,19 +1311,17 @@
     ok(hr == S_OK, "GetBuffer failed: %08x\n", hr);
     trace("data at %p for prefill %u\n", data, avail);
 
-    if (winetest_debug>2) {
-        hr = IAudioClient_Stop(ac);
-        ok(hr == S_OK, "Stop failed: %08x\n", hr);
+    hr = IAudioClient_Stop(ac);
+    ok(hr == S_OK, "Stop failed: %08x\n", hr);
 
-        Sleep(20);
-        slept += 20;
+    Sleep(20);
+    slept += 20;
 
-        hr = IAudioClient_Reset(ac);
-        ok(hr == AUDCLNT_E_BUFFER_OPERATION_PENDING, "Reset failed: %08x\n", hr);
+    hr = IAudioClient_Reset(ac);
+    ok(hr == AUDCLNT_E_BUFFER_OPERATION_PENDING, "Reset failed: %08x\n", hr);
 
-        hr = IAudioClient_Start(ac);
-        ok(hr == S_OK, "Start failed: %08x\n", hr);
-    }
+    hr = IAudioClient_Start(ac);
+    ok(hr == S_OK, "Start failed: %08x\n", hr);
 
     /* Despite passed time, data must still point to valid memory... */
     hr = IAudioRenderClient_ReleaseBuffer(arc, avail,
@@ -1211,14 +1366,13 @@
         trace("padding %u position %u/%u slept %ums iteration %d\n", pad, (UINT)pos, sum-pad, slept, i);
         ok(pad ? pos > last : pos >= last, "No position increase at iteration %d\n", i);
         ok(pos * pwfx->nSamplesPerSec <= sum * freq, "Position %u > written %u\n", (UINT)pos, sum);
-        if (winetest_debug>1) {
-            /* Padding does not lag behind by much */
-            ok(pos * pwfx->nSamplesPerSec <= (sum-pad+fragment) * freq, "Position %u > written %u\n", (UINT)pos, sum);
-            ok(pos*1000/freq <= slept*1.1, "Position %u too far after %ums\n", (UINT)pos, slept);
-            if (pad) /* not in case of underrun */
-                ok((pos-last)*1000/freq >= 90 && 110 >= (pos-last)*1000/freq,
-                   "Position delta %ld not regular\n", (long)(pos-last));
-        }
+
+        /* Padding does not lag behind by much */
+        ok(pos * pwfx->nSamplesPerSec <= (sum-pad+fragment) * freq, "Position %u > written %u\n", (UINT)pos, sum);
+        ok(pos*1000/freq <= slept*1.1, "Position %u too far after %ums\n", (UINT)pos, slept);
+        if (pad) /* not in case of underrun */
+            ok((pos-last)*1000/freq >= 90 && 110 >= (pos-last)*1000/freq,
+               "Position delta %ld not regular\n", (long)(pos-last));
         last = pos;
 
         hr = IAudioClient_GetStreamLatency(ac, &t1);
@@ -1231,7 +1385,7 @@
         /* ok(hr == AUDCLNT_E_BUFFER_TOO_LARGE || (hr == S_OK && i==0) without todo_wine */
         ok(hr == S_OK || hr == AUDCLNT_E_BUFFER_TOO_LARGE,
            "GetBuffer large (%u) failed: %08x\n", avail, hr);
-        if(hr == S_OK && i) todo_wine ok(FALSE, "GetBuffer large (%u) at iteration %d\n", avail, i);
+        if(hr == S_OK && i) ok(FALSE, "GetBuffer large (%u) at iteration %d\n", avail, i);
         /* Only the first iteration should allow that large a buffer
          * as prefill was drained during the first 350+100ms sleep.
          * Afterwards, only 100ms of data should find room per iteration. */
@@ -2083,7 +2237,7 @@
     hr = IAudioClock_GetFrequency(acl, &freq);
     ok(hr == S_OK, "GetFrequency failed: %08x\n", hr);
 
-    for(j = 0; j <= (winetest_interactive ? 9 : 2); j++){
+    for(j = 0; j < 10; j++){
         sum = 0;
         trace("Should play %ums continuous tone with fragment size %u.\n",
               (ULONG)(defp/100), fragment);
@@ -2092,15 +2246,13 @@
         ok(hr == S_OK, "GetPosition failed: %08x\n", hr);
 
         /* XAudio2 prefills one period, play without it */
-        if(winetest_debug>2){
-            hr = IAudioRenderClient_GetBuffer(arc, fragment, &data);
-            ok(hr == S_OK, "GetBuffer failed: %08x\n", hr);
-
-            hr = IAudioRenderClient_ReleaseBuffer(arc, fragment, AUDCLNT_BUFFERFLAGS_SILENT);
-            ok(hr == S_OK, "ReleaseBuffer failed: %08x\n", hr);
-            if(hr == S_OK)
-                sum += fragment;
-        }
+        hr = IAudioRenderClient_GetBuffer(arc, fragment, &data);
+        ok(hr == S_OK, "GetBuffer failed: %08x\n", hr);
+
+        hr = IAudioRenderClient_ReleaseBuffer(arc, fragment, AUDCLNT_BUFFERFLAGS_SILENT);
+        ok(hr == S_OK, "ReleaseBuffer failed: %08x\n", hr);
+        if(hr == S_OK)
+            sum += fragment;
 
         hr = IAudioClient_Start(ac);
         ok(hr == S_OK, "Start failed: %08x\n", hr);
@@ -2185,6 +2337,7 @@
     test_audioclient();
     test_formats(AUDCLNT_SHAREMODE_EXCLUSIVE);
     test_formats(AUDCLNT_SHAREMODE_SHARED);
+    test_formats2();
     test_references();
     trace("Output to a MS-DOS console is particularly slow and disturbs timing.\n");
     trace("Please redirect output to a file.\n");
diff -urN wine-1.5.30/dlls/mpr/mpr_main.c wine-multimedia/dlls/mpr/mpr_main.c
--- wine-1.5.30/dlls/mpr/mpr_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/mpr/mpr_main.c	2013-05-17 10:44:20.932230700 +0300
@@ -85,6 +85,7 @@
             break;
 
         case DLL_PROCESS_DETACH:
+            if (lpvReserved) break;
             wnetFree();
             break;
     }
diff -urN wine-1.5.30/dlls/mscms/mscms_main.c wine-multimedia/dlls/mscms/mscms_main.c
--- wine-1.5.30/dlls/mscms/mscms_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/mscms/mscms_main.c	2013-05-17 10:44:20.938230625 +0300
@@ -66,6 +66,7 @@
 #endif
         break;
     case DLL_PROCESS_DETACH:
+        if (reserved) break;
 #ifdef HAVE_LCMS
         free_handle_tables();
 #endif
diff -urN wine-1.5.30/dlls/mshtml/nsevents.c wine-multimedia/dlls/mshtml/nsevents.c
--- wine-1.5.30/dlls/mshtml/nsevents.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/mshtml/nsevents.c	2013-05-17 10:44:20.963230313 +0300
@@ -235,6 +235,7 @@
     HTMLDocumentNode *doc = This->This->doc;
     nsIDOMHTMLElement *nsbody = NULL;
     HTMLDocumentObj *doc_obj = NULL;
+    nsresult nsres = NS_OK;
 
     TRACE("(%p)\n", doc);
 
@@ -245,6 +246,8 @@
 
     connect_scripts(doc->window);
 
+    htmldoc_addref(&doc->basedoc);
+
     if(doc_obj)
         handle_docobj_load(doc_obj);
 
@@ -264,18 +267,19 @@
         IDocObjectService_FireDocumentComplete(doc_obj->doc_object_service,
                 &doc->basedoc.window->base.IHTMLWindow2_iface, 0);
 
-    if(!doc->nsdoc) {
+    if(doc->nsdoc) {
+        nsIDOMHTMLDocument_GetBody(doc->nsdoc, &nsbody);
+        if(nsbody) {
+            fire_event(doc, EVENTID_LOAD, TRUE, (nsIDOMNode*)nsbody, event, (IDispatch*)&doc->window->base.IDispatchEx_iface);
+            nsIDOMHTMLElement_Release(nsbody);
+        }
+    }else {
         ERR("NULL nsdoc\n");
-        return NS_ERROR_FAILURE;
-    }
-
-    nsIDOMHTMLDocument_GetBody(doc->nsdoc, &nsbody);
-    if(nsbody) {
-        fire_event(doc, EVENTID_LOAD, TRUE, (nsIDOMNode*)nsbody, event, (IDispatch*)&doc->window->base.IDispatchEx_iface);
-        nsIDOMHTMLElement_Release(nsbody);
+        nsres = NS_ERROR_FAILURE;
     }
 
-    return NS_OK;
+    htmldoc_release(&doc->basedoc);
+    return nsres;
 }
 
 static nsresult NSAPI handle_htmlevent(nsIDOMEventListener *iface, nsIDOMEvent *event)
diff -urN wine-1.5.30/dlls/msi/msi_main.c wine-multimedia/dlls/msi/msi_main.c
--- wine-1.5.30/dlls/msi/msi_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/msi/msi_main.c	2013-05-17 10:44:20.990229975 +0300
@@ -76,6 +76,7 @@
         IsWow64Process( GetCurrentProcess(), &is_wow64 );
         break;
     case DLL_PROCESS_DETACH:
+        if (lpvReserved) break;
         msi_dialog_unregister_class();
         msi_free_handle_table();
         msi_free( gszLogFile );
diff -urN wine-1.5.30/dlls/msisys.ocx/msisys.c wine-multimedia/dlls/msisys.ocx/msisys.c
--- wine-1.5.30/dlls/msisys.ocx/msisys.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/msisys.ocx/msisys.c	2013-05-17 10:44:21.017229638 +0300
@@ -35,50 +35,6 @@
 
 
 /***********************************************************************
- *		MSISYS_InitProcess (internal)
- */
-static BOOL MSISYS_InitProcess( void )
-{
-	TRACE("()\n");
-
-	return TRUE;
-}
-
-/***********************************************************************
- *		MSISYS_UninitProcess (internal)
- */
-static void MSISYS_UninitProcess( void )
-{
-	TRACE("()\n");
-}
-
-/***********************************************************************
- *		DllMain for MSISYS
- */
-BOOL WINAPI DllMain(
-	HINSTANCE hInstDLL,
-	DWORD fdwReason,
-	LPVOID lpvReserved )
-{
-	TRACE("(%p,%d,%p)\n",hInstDLL,fdwReason,lpvReserved);
-
-	switch ( fdwReason )
-	{
-	case DLL_PROCESS_ATTACH:
-                DisableThreadLibraryCalls(hInstDLL);
-		if ( !MSISYS_InitProcess() )
-			return FALSE;
-		break;
-	case DLL_PROCESS_DETACH:
-		MSISYS_UninitProcess();
-		break;
-	}
-
-	return TRUE;
-}
-
-
-/***********************************************************************
  *		DllCanUnloadNow (MSISYS.@)
  *
  * RETURNS
diff -urN wine-1.5.30/dlls/msxml3/domdoc.c wine-multimedia/dlls/msxml3/domdoc.c
--- wine-1.5.30/dlls/msxml3/domdoc.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/msxml3/domdoc.c	2013-05-17 10:44:21.126228275 +0300
@@ -416,20 +416,26 @@
 
     if (ctxt->node)
     {
+        xmlChar cur = *(ctxt->input->cur);
+
         /* Characters are reported with multiple calls, for example each charref is reported with a separate
            call and then parser appends it to a single text node or creates a new node if not created.
            It's not possible to tell if it's ignorable data or not just looking at data itself cause it could be
-           a space chars that separate charrefs or similar case. We only need to skip leading and trailing spaces,
+           space chars that separate charrefs or similar case. We only need to skip leading and trailing spaces,
            or whole node if it has nothing but space chars, so to detect leading space node->last is checked that
            contains text node pointer if already created, trailing spaces are detected directly looking at parser input
-           for next '<' opening bracket - similar logic is used by libxml2 itself.
+           for next '<' opening bracket - similar logic is used by libxml2 itself. Basically 'cur' == '<' means the last
+           chunk of char data, in case it's not the last chunk we check for previously added node type and if it's not
+           a text node it's safe to ignore.
 
            Note that during domdoc_loadXML() the xmlDocPtr->_private data is not available. */
+
         if (!This->properties->preserving &&
             !is_preserving_whitespace(ctxt->node) &&
             strn_isspace(ch, len) &&
             (!ctxt->node->last ||
-            ((ctxt->node->last && (*ctxt->input->cur) == '<'))))
+            ((ctxt->node->last && (cur == '<' || ctxt->node->last->type != XML_TEXT_NODE))
+           )))
             return;
     }
 
diff -urN wine-1.5.30/dlls/msxml3/tests/domdoc.c wine-multimedia/dlls/msxml3/tests/domdoc.c
--- wine-1.5.30/dlls/msxml3/tests/domdoc.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/msxml3/tests/domdoc.c	2013-05-17 10:44:21.137228138 +0300
@@ -385,6 +385,15 @@
     '<','o','p','e','n','>','<','/','o','p','e','n','>','\n',0
 };
 
+static const char complete7[] = {
+    "<?xml version=\"1.0\"?>\n\t"
+    "<root>\n"
+    "\t<a/>\n"
+    "\t<b/>\n"
+    "\t<c/>\n"
+    "</root>"
+};
+
 #define DECL_WIN_1252 \
 "<?xml version=\"1.0\" encoding=\"Windows-1252\"?>"
 
@@ -4212,7 +4221,11 @@
 static void test_whitespace(void)
 {
     IXMLDOMDocument2 *doc1, *doc2, *doc3, *doc4;
+    IXMLDOMNodeList *list;
+    IXMLDOMElement *root;
     VARIANT_BOOL b;
+    HRESULT hr;
+    LONG len;
 
     doc1 = create_document(&IID_IXMLDOMDocument2);
     doc2 = create_document(&IID_IXMLDOMDocument2);
@@ -4286,6 +4299,26 @@
     /* text with char references */
     test_preserve_charref(doc1, VARIANT_TRUE);
     test_preserve_charref(doc1, VARIANT_FALSE);
+
+    /* formatting whitespaces */
+    hr = IXMLDOMDocument2_put_preserveWhiteSpace(doc1, VARIANT_FALSE);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    hr = IXMLDOMDocument2_loadXML(doc1, _bstr_(complete7), &b);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(b == VARIANT_TRUE, "for %x\n", b);
+
+    hr = IXMLDOMDocument2_get_documentElement(doc1, &root);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    hr = IXMLDOMElement_get_childNodes(root, &list);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    len = 0;
+    hr = IXMLDOMNodeList_get_length(list, &len);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(len == 3, "got %d\n", len);
+    IXMLDOMNodeList_Release(list);
+    IXMLDOMElement_Release(root);
+
     IXMLDOMDocument2_Release(doc1);
 
     free_bstrs();
diff -urN wine-1.5.30/dlls/ntdll/server.c wine-multimedia/dlls/ntdll/server.c
--- wine-1.5.30/dlls/ntdll/server.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/ntdll/server.c	2013-05-17 10:44:21.163227813 +0300
@@ -79,6 +79,9 @@
 #include "ntdll_misc.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
+WINE_DECLARE_DEBUG_CHANNEL(tid);
+WINE_DECLARE_DEBUG_CHANNEL(timestamp);
 
 /* Some versions of glibc don't define this */
 #ifndef SCM_RIGHTS
@@ -979,6 +982,88 @@
 }
 
 
+#ifdef SIGXCPU
+static int convert_tidtostr_r(char *s, unsigned hex)
+{
+    int i;
+    char *start = s;
+
+    for (i = 0; i < 8; ++i) {
+        unsigned c = hex >> (28 - 4 * i);
+
+        if (c || i >= 4)
+        { /* last 4 digits always printed */
+            c &= 0xf;
+
+            if (c < 10)
+                *s++ = '0' + c;
+            else
+                *s++ = 'a' + c - 10;
+        }
+    }
+
+    *s++ = ':';
+    return s - start;
+}
+
+static int convert_stamptostr_r(char *s, unsigned stamp)
+{
+    unsigned high = stamp / 1000, low = stamp % 1000, i;
+    char *start = s;
+
+    for (i = 1000000; i; i /= 10) {
+        if (high >= i)
+            *s++ = '0' + (high / i) % 10;
+        else if (i <= 100)
+            *s++ = ' ';
+    }
+
+    *s++ = '.';
+
+    for (i = 100; i; i /= 10)
+         *s++ = '0' + (low / i) % 10;
+
+    *s++ = ':';
+
+    return s - start;
+}
+
+
+static const char throttle_str[] =
+"fixme:winediag:sigxcpu_handler realtime priority was throttled due to program exceeding time limit\n";
+
+static void sigxcpu_handler( int sig )
+{
+    char temp[16];
+    int old_errno = errno, ret;
+
+    if (server_pid > 0)
+        kill(server_pid, SIGXCPU);
+    else {
+        /* uh oh, somehow init failed to get server_pid */
+        struct sched_param parm;
+        memset(&parm, 0, sizeof(parm));
+        sched_setscheduler(0, SCHED_OTHER | SCHED_RESET_ON_FORK, &parm);
+    }
+
+    if (FIXME_ON(winediag)) {
+        if (TRACE_ON(timestamp)) {
+            ret = convert_stamptostr_r(temp, NtGetTickCount());
+            write(2, temp, ret);
+        }
+
+        if (TRACE_ON(tid)) {
+            ret = convert_tidtostr_r(temp, GetCurrentThreadId());
+            write(2, temp, ret);
+        }
+
+        write(2, throttle_str, sizeof(throttle_str)-1);
+    }
+
+    errno = old_errno;
+}
+#endif
+
 /***********************************************************************
  *           server_init_process
  *
@@ -988,6 +1073,14 @@
 {
     obj_handle_t version;
     const char *env_socket = getenv( "WINESERVERSOCKET" );
+#ifdef SIGXCPU
+    struct sigaction sa;
+
+    sa.sa_handler = sigxcpu_handler;
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sigaction( SIGXCPU, &sa, NULL );
+#endif
 
     server_pid = -1;
     if (env_socket)
@@ -1071,7 +1164,6 @@
     return status;
 }
 
-
 /***********************************************************************
  *           server_init_thread
  *
diff -urN wine-1.5.30/dlls/ole32/compobj.c wine-multimedia/dlls/ole32/compobj.c
--- wine-1.5.30/dlls/ole32/compobj.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/ole32/compobj.c	2013-05-17 10:44:21.189227487 +0300
@@ -4449,9 +4449,9 @@
 /***********************************************************************
  *		DllMain (OLE32.@)
  */
-BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID fImpLoad)
+BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID reserved)
 {
-    TRACE("%p 0x%x %p\n", hinstDLL, fdwReason, fImpLoad);
+    TRACE("%p 0x%x %p\n", hinstDLL, fdwReason, reserved);
 
     switch(fdwReason) {
     case DLL_PROCESS_ATTACH:
@@ -4460,6 +4460,7 @@
 	break;
 
     case DLL_PROCESS_DETACH:
+        if (reserved) break;
         COMPOBJ_UninitProcess();
         RPC_UnregisterAllChannelHooks();
         COMPOBJ_DllList_Free();
diff -urN wine-1.5.30/dlls/ole32/rpc.c wine-multimedia/dlls/ole32/rpc.c
--- wine-1.5.30/dlls/ole32/rpc.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/ole32/rpc.c	2013-05-17 10:44:21.200227350 +0300
@@ -1917,16 +1917,12 @@
                 DWORD ret;
                 ret = WaitForMultipleObjects(2, handles, FALSE, INFINITE);
                 if (ret != WAIT_OBJECT_0)
-                {
-                    CloseHandle(hPipe);
                     break;
-                }
             }
             /* client already connected isn't an error */
             else if (error != ERROR_PIPE_CONNECTED)
             {
                 ERR("ConnectNamedPipe failed with error %d\n", GetLastError());
-                CloseHandle(hPipe);
                 break;
             }
         }
@@ -1935,20 +1931,14 @@
         
         hres = IStream_Stat(pStm,&ststg,STATFLAG_NONAME);
         if (hres)
-        {
-            CloseHandle(hPipe);
-            CloseHandle(pipe_event);
-            return hres;
-        }
+            break;
 
         seekto.u.LowPart = 0;
         seekto.u.HighPart = 0;
         hres = IStream_Seek(pStm,seekto,STREAM_SEEK_SET,&newpos);
         if (hres) {
             FIXME("IStream_Seek failed, %x\n",hres);
-            CloseHandle(hPipe);
-            CloseHandle(pipe_event);
-            return hres;
+            break;
         }
 
         buflen = ststg.cbSize.u.LowPart;
@@ -1957,10 +1947,8 @@
         hres = IStream_Read(pStm,buffer,buflen,&res);
         if (hres) {
             FIXME("Stream Read failed, %x\n",hres);
-            CloseHandle(hPipe);
-            CloseHandle(pipe_event);
             HeapFree(GetProcessHeap(),0,buffer);
-            return hres;
+            break;
         }
         
         WriteFile(hPipe,buffer,buflen,&res,&ovl);
@@ -1974,22 +1962,22 @@
         if (!multi_use)
         {
             TRACE("single use object, shutting down pipe %s\n", debugstr_w(pipefn));
-            CloseHandle(hPipe);
             break;
         }
         new_pipe = CreateNamedPipeW( pipefn, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                                      PIPE_TYPE_BYTE|PIPE_WAIT, PIPE_UNLIMITED_INSTANCES,
                                      4096, 4096, 500 /* 0.5 second timeout */, NULL );
-        CloseHandle(hPipe);
         if (new_pipe == INVALID_HANDLE_VALUE)
         {
             FIXME("pipe creation failed for %s, le is %u\n", debugstr_w(pipefn), GetLastError());
-            CloseHandle(pipe_event);
-            return 1;
+            break;
         }
+        CloseHandle(hPipe);
         hPipe = new_pipe;
     }
+
     CloseHandle(pipe_event);
+    CloseHandle(hPipe);
     return 0;
 }
 
diff -urN wine-1.5.30/dlls/oleaut32/typelib.c wine-multimedia/dlls/oleaut32/typelib.c
--- wine-1.5.30/dlls/oleaut32/typelib.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/oleaut32/typelib.c	2013-05-17 10:44:21.227227012 +0300
@@ -5330,9 +5330,12 @@
         dest->funckind = FUNC_DISPATCH;
     buffer = (char *)(dest + 1);
 
-    dest->lprgscode = (SCODE *)buffer;
-    memcpy(dest->lprgscode, src->lprgscode, sizeof(*src->lprgscode) * src->cScodes);
-    buffer += sizeof(*src->lprgscode) * src->cScodes;
+    if (dest->cScodes) {
+        dest->lprgscode = (SCODE *)buffer;
+        memcpy(dest->lprgscode, src->lprgscode, sizeof(*src->lprgscode) * src->cScodes);
+        buffer += sizeof(*src->lprgscode) * src->cScodes;
+    } else
+        dest->lprgscode = NULL;
 
     hr = TLB_CopyElemDesc(&src->elemdescFunc, &dest->elemdescFunc, &buffer);
     if (FAILED(hr))
@@ -5341,23 +5344,26 @@
         return hr;
     }
 
-    dest->lprgelemdescParam = (ELEMDESC *)buffer;
-    buffer += sizeof(ELEMDESC) * src->cParams;
-    for (i = 0; i < src->cParams; i++)
-    {
-        hr = TLB_CopyElemDesc(&src->lprgelemdescParam[i], &dest->lprgelemdescParam[i], &buffer);
+    if (dest->cParams) {
+        dest->lprgelemdescParam = (ELEMDESC *)buffer;
+        buffer += sizeof(ELEMDESC) * src->cParams;
+        for (i = 0; i < src->cParams; i++)
+        {
+            hr = TLB_CopyElemDesc(&src->lprgelemdescParam[i], &dest->lprgelemdescParam[i], &buffer);
+            if (FAILED(hr))
+                break;
+        }
         if (FAILED(hr))
-            break;
-    }
-    if (FAILED(hr))
-    {
-        /* undo the above actions */
-        for (i = i - 1; i >= 0; i--)
-            TLB_FreeElemDesc(&dest->lprgelemdescParam[i]);
-        TLB_FreeElemDesc(&dest->elemdescFunc);
-        SysFreeString((BSTR)dest);
-        return hr;
-    }
+        {
+            /* undo the above actions */
+            for (i = i - 1; i >= 0; i--)
+                TLB_FreeElemDesc(&dest->lprgelemdescParam[i]);
+            TLB_FreeElemDesc(&dest->elemdescFunc);
+            SysFreeString((BSTR)dest);
+            return hr;
+        }
+    } else
+        dest->lprgelemdescParam = NULL;
 
     /* special treatment for dispinterfaces: this makes functions appear
      * to return their [retval] value when it is really returning an
@@ -5498,6 +5504,9 @@
 
     TRACE("(%p) index %d\n", This, index);
 
+    if (!ppFuncDesc)
+        return E_INVALIDARG;
+
     if (This->TypeAttr.typekind == TKIND_DISPATCH)
         hr = ITypeInfoImpl_GetInternalDispatchFuncDesc((ITypeInfo *)iface, index,
                                                        &internal_funcdesc, NULL,
@@ -5729,6 +5738,9 @@
 
     TRACE("(%p) index %d\n", This, index);
 
+    if(!pImplTypeFlags)
+        return E_INVALIDARG;
+
     if(This->TypeAttr.typekind == TKIND_DISPATCH && index == 0){
         *pImplTypeFlags = 0;
         return S_OK;
@@ -6892,7 +6904,7 @@
         if(pdwHelpContext)
             *pdwHelpContext=This->dwHelpContext;
         if(pBstrHelpFile)
-            *pBstrHelpFile=SysAllocString(This->DocString);/* FIXME */
+            *pBstrHelpFile=SysAllocString(This->pTypeLib->HelpFile);
         return S_OK;
     }else {/* for a member */
         pFDesc = TLB_get_funcdesc_by_memberid(This->funcdescs, This->TypeAttr.cFuncs, memid);
@@ -6913,6 +6925,8 @@
               *pBstrDocString=SysAllocString(pVDesc->HelpString);
             if(pdwHelpContext)
               *pdwHelpContext=pVDesc->HelpContext;
+            if(pBstrHelpFile)
+              *pBstrHelpFile = SysAllocString(This->pTypeLib->HelpFile);
             return S_OK;
         }
     }
@@ -7027,6 +7041,9 @@
     ITypeInfoImpl *This = impl_from_ITypeInfo2(iface);
     HRESULT result = E_FAIL;
 
+    if(!ppTInfo)
+        return E_INVALIDARG;
+
     if ((This->hreftype != -1) && (This->hreftype == hRefType))
     {
         *ppTInfo = (ITypeInfo *)&This->ITypeInfo2_iface;
@@ -7424,6 +7441,9 @@
 
     TRACE("%p %s %p\n", This, debugstr_guid(guid), pVarVal);
 
+    if(!guid || !pVarVal)
+        return E_INVALIDARG;
+
     pCData = TLB_get_custdata_by_guid(&This->custdata_list, guid);
 
     VariantInit( pVarVal);
diff -urN wine-1.5.30/dlls/oledb32/convert.c wine-multimedia/dlls/oledb32/convert.c
--- wine-1.5.30/dlls/oledb32/convert.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/oledb32/convert.c	2013-05-17 10:44:21.235226912 +0300
@@ -790,10 +790,56 @@
             V_CY(v) = *(CY*)src;
             hr = S_OK;
             break;
+        case DBTYPE_BYTES:
+        {
+            LONG i;
+            LONG size;
+            SAFEARRAY *psa = NULL;
+            SAFEARRAYBOUND rgsabound[1];
+            unsigned char *p = src;
+
+            size = min(src_len, dst_max_len);
+
+            rgsabound[0].lLbound = 0;
+            rgsabound[0].cElements = size;
+
+            psa = SafeArrayCreate(VT_UI1,1,rgsabound);
+            for(i =0; i < size; i++,p++)
+            {
+                hr = SafeArrayPutElement(psa, &i, &p);
+                if(FAILED(hr))
+                   return hr;
+            }
+
+            V_VT(v) = VT_ARRAY|VT_UI1;
+            V_ARRAY(v) = psa;
+            hr = S_OK;
+            break;
+        }
         default: FIXME("Unimplemented conversion %04x -> VARIANT\n", src_type); return E_NOTIMPL;
         }
         break;
     }
+    case DBTYPE_BYTES:
+    {
+        BYTE *d = dst;
+
+        switch(src_type)
+        {
+        case DBTYPE_BYTES:
+            if( src_len > dst_max_len)
+                *dst_status = DBSTATUS_S_TRUNCATED;
+            else
+                *dst_status = DBSTATUS_S_OK;
+
+            *dst_len = src_len;
+            memcpy(d, src, min(src_len, dst_max_len));
+
+            return S_OK;
+        default: FIXME("Unimplemented conversion %04x -> DBTYPE_BYTES\n", src_type); return E_NOTIMPL;
+        }
+        break;
+    }
 
     default:
         FIXME("Unimplemented conversion %04x -> %04x\n", src_type, dst_type);
@@ -1113,6 +1159,20 @@
     {
         switch (src_type)
         {
+        case DBTYPE_VARIANT:
+        {
+            VARIANT v;
+
+            VariantInit(&v);
+            if ((hr = VariantChangeType(&v, (VARIANT*)src, 0, VT_BSTR)) == S_OK)
+            {
+                *dst_len = (SysStringLen(V_BSTR(&v)) + 1) * sizeof(WCHAR);
+                VariantClear(&v);
+            }
+            else
+                return hr;
+        }
+        break;
         case DBTYPE_STR:
             if(src_len)
                 *dst_len = (*src_len + 1) * sizeof(WCHAR);
diff -urN wine-1.5.30/dlls/oledb32/tests/convert.c wine-multimedia/dlls/oledb32/tests/convert.c
--- wine-1.5.30/dlls/oledb32/tests/convert.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/oledb32/tests/convert.c	2013-05-17 10:44:21.236226900 +0300
@@ -2339,6 +2339,7 @@
     BSTR str;
     static WCHAR strW[] = {'t','e','s','t',0};
     static char strTest[] = "test";
+    VARIANT var;
 
     /* same way as CanConvert fails here */
     dst_len = 0;
@@ -2394,11 +2395,62 @@
     hr = IDataConvert_GetConversionSize(convert, DBTYPE_STR, DBTYPE_WSTR, &src_len, &dst_len, strTest);
     ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(dst_len == 42, "%ld\n", dst_len);
+
+    dst_len = 0;
+    V_VT(&var) = VT_BSTR;
+    V_BSTR(&var) = SysAllocString(strW);
+    hr = IDataConvert_GetConversionSize(convert, DBTYPE_VARIANT, DBTYPE_WSTR, NULL, &dst_len, &var);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(dst_len == 10, "%ld\n", dst_len);
+    VariantClear(&var);
+
+    dst_len = 0;
+    src_len = 20;
+    V_VT(&var) = VT_BSTR;
+    V_BSTR(&var) = SysAllocString(strW);
+    hr = IDataConvert_GetConversionSize(convert, DBTYPE_VARIANT, DBTYPE_WSTR, &src_len, &dst_len, &var);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(dst_len == 10, "%ld\n", dst_len);
+    VariantClear(&var);
+
+    dst_len = 0;
+    src_len = 20;
+    V_VT(&var) = VT_I4;
+    V_I4(&var) = 4;
+    hr = IDataConvert_GetConversionSize(convert, DBTYPE_VARIANT, DBTYPE_WSTR, &src_len, &dst_len, &var);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    todo_wine ok(dst_len == 110, "%ld\n", dst_len);
+    VariantClear(&var);
+
+}
+
+static void test_converttobytes(void)
+{
+    DBLENGTH dst_len;
+    HRESULT hr;
+    BYTE byte_src[] = {0, 1, 2, 4, 5};
+    BYTE dst[10] = {0};
+    DBSTATUS dst_status;
+
+    dst_len = 0;
+    hr = IDataConvert_DataConvert(convert, DBTYPE_BYTES, DBTYPE_BYTES, sizeof(byte_src), &dst_len, byte_src, &dst, sizeof(dst), 0, &dst_status, 0, 0, 0);
+    ok(hr == S_OK, "got %08x\n", hr);
+    ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    ok(dst_len == sizeof(byte_src), "got %ld\n", dst_len);
+    ok(!memcmp(byte_src, dst, dst_len ), "bytes differ\n");
+
+    dst_len = 0;
+    hr = IDataConvert_DataConvert(convert, DBTYPE_BYTES, DBTYPE_BYTES, sizeof(byte_src), &dst_len, byte_src, &dst, 2, 0, &dst_status, 0, 0, 0);
+    ok(hr == S_OK, "got %08x\n", hr);
+    ok(dst_status == DBSTATUS_S_TRUNCATED, "got %08x\n", dst_status);
+    ok(dst_len == sizeof(byte_src), "got %ld\n", dst_len);
+    ok(!memcmp(byte_src, dst, 2 ), "bytes differ\n");
 }
 
 static void test_converttovar(void)
 {
     static WCHAR strW[] = {'t','e','s','t',0};
+    BYTE byte_src[5] = {1, 2, 3, 4, 5};
     double dvalue = 123.56;
     DBSTATUS dst_status;
     DBLENGTH dst_len;
@@ -2497,6 +2549,14 @@
 
     cy2 = V_CY(&dst);
     ok(S(cy2).Lo == S(cy).Lo && S(cy2).Hi == S(cy).Hi, "got %d,%d\n", S(cy2).Lo, S(cy2).Hi);
+
+    dst_len = 0x1234;
+    hr = IDataConvert_DataConvert(convert, DBTYPE_BYTES, DBTYPE_VARIANT, 0, &dst_len, &byte_src, &dst, sizeof(dst), 0, &dst_status, 0, 0, 0);
+    ok(hr == S_OK, "got %08x\n", hr);
+    ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    ok(V_VT(&dst) == (VT_ARRAY|VT_UI1), "got %d\n", V_VT(&dst));
+    VariantClear(&dst);
 }
 
 START_TEST(convert)
@@ -2531,6 +2591,7 @@
     test_converttocy();
     test_converttoui8();
     test_converttovar();
+    test_converttobytes();
     test_getconversionsize();
 
     IDataConvert_Release(convert);
diff -urN wine-1.5.30/dlls/riched20/editor.c wine-multimedia/dlls/riched20/editor.c
--- wine-1.5.30/dlls/riched20/editor.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/riched20/editor.c	2013-05-17 10:44:21.283226312 +0300
@@ -2843,6 +2843,7 @@
       break;
 
     case DLL_PROCESS_DETACH:
+      if (lpvReserved) break;
       UnregisterClassW(RICHEDIT_CLASS20W, 0);
       UnregisterClassW(MSFTEDIT_CLASS, 0);
       UnregisterClassA(RICHEDIT_CLASS20A, 0);
@@ -2853,7 +2854,6 @@
           UnregisterClassW(REComboBox20W, 0);
       LookupCleanup();
       HeapDestroy (me_heap);
-      me_heap = NULL;
       break;
     }
     return TRUE;
diff -urN wine-1.5.30/dlls/riched32/richedit.c wine-multimedia/dlls/riched32/richedit.c
--- wine-1.5.30/dlls/riched32/richedit.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/riched32/richedit.c	2013-05-17 10:44:21.293226187 +0300
@@ -40,16 +40,6 @@
 extern LRESULT WINAPI RichEdit10ANSIWndProc(HWND, UINT, WPARAM, LPARAM);
 
 
-/* Unregisters the window class. */
-static BOOL RICHED32_Unregister(void)
-{
-    TRACE("\n");
-
-    UnregisterClassA(RICHEDIT_CLASS10A, NULL);
-    return TRUE;
-}
-
-
 /* Registers the window class. */
 static BOOL RICHED32_Register(void)
 {
@@ -80,7 +70,9 @@
         return RICHED32_Register();
 
     case DLL_PROCESS_DETACH:
-        return RICHED32_Unregister();
+        if (lpvReserved) break;
+        UnregisterClassA(RICHEDIT_CLASS10A, NULL);
+        break;
     }
     return TRUE;
 }
diff -urN wine-1.5.30/dlls/rsaenh/rsaenh.c wine-multimedia/dlls/rsaenh/rsaenh.c
--- wine-1.5.30/dlls/rsaenh/rsaenh.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/rsaenh/rsaenh.c	2013-05-17 10:44:21.311225962 +0300
@@ -358,7 +358,7 @@
  *
  * Initializes and destroys the handle table for the CSP's handles.
  */
-int WINAPI DllMain(HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved)
+BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD fdwReason, PVOID reserved)
 {
     switch (fdwReason)
     {
@@ -369,10 +369,11 @@
             break;
 
         case DLL_PROCESS_DETACH:
+            if (reserved) break;
             destroy_handle_table(&handle_table);
             break;
     }
-    return 1;
+    return TRUE;
 }
 
 /******************************************************************************
diff -urN wine-1.5.30/dlls/scrrun/scrrun.c wine-multimedia/dlls/scrrun/scrrun.c
--- wine-1.5.30/dlls/scrrun/scrrun.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/scrrun/scrrun.c	2013-05-17 10:44:21.318225875 +0300
@@ -176,6 +176,7 @@
             scrrun_instance = hinst;
             break;
         case DLL_PROCESS_DETACH:
+            if (reserved) break;
             release_typelib();
             break;
     }
diff -urN wine-1.5.30/dlls/secur32/secur32.c wine-multimedia/dlls/secur32/secur32.c
--- wine-1.5.30/dlls/secur32/secur32.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/secur32/secur32.c	2013-05-17 10:44:21.322225825 +0300
@@ -1177,15 +1177,16 @@
 /***********************************************************************
  *		DllMain (SECUR32.0)
  */
-BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD reason, LPVOID reserved)
 {
-    if (fdwReason == DLL_PROCESS_ATTACH)
+    switch (reason)
     {
+    case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls(hinstDLL);
         SECUR32_initializeProviders();
-    }
-    else if (fdwReason == DLL_PROCESS_DETACH)
-    {
+        break;
+    case DLL_PROCESS_DETACH:
+        if (reserved) break;
         SECUR32_freeProviders();
     }
 
diff -urN wine-1.5.30/dlls/shell32/shell32_main.c wine-multimedia/dlls/shell32/shell32_main.c
--- wine-1.5.30/dlls/shell32/shell32_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/shell32/shell32_main.c	2013-05-17 10:44:21.350225475 +0300
@@ -1279,7 +1279,7 @@
         break;
 
     case DLL_PROCESS_DETACH:
-        shell32_hInstance = 0;
+        if (fImpLoad) break;
         SIC_Destroy();
         FreeChangeNotifications();
         break;
diff -urN wine-1.5.30/dlls/spoolss/spoolss_main.c wine-multimedia/dlls/spoolss/spoolss_main.c
--- wine-1.5.30/dlls/spoolss/spoolss_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/spoolss/spoolss_main.c	2013-05-17 10:44:21.384225050 +0300
@@ -55,6 +55,7 @@
             break;
 
         case DLL_PROCESS_DETACH:
+            if (lpvReserved) break;
             backend_unload_all();
             break;
         }
diff -urN wine-1.5.30/dlls/urlmon/urlmon_main.c wine-multimedia/dlls/urlmon/urlmon_main.c
--- wine-1.5.30/dlls/urlmon/urlmon_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/urlmon/urlmon_main.c	2013-05-17 10:44:21.411224712 +0300
@@ -157,6 +157,7 @@
         break;
 
     case DLL_PROCESS_DETACH:
+        if (fImpLoad) break;
         process_detach();
         DeleteCriticalSection(&tls_cs);
         break;
diff -urN wine-1.5.30/dlls/user32/clipboard.c wine-multimedia/dlls/user32/clipboard.c
--- wine-1.5.30/dlls/user32/clipboard.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/user32/clipboard.c	2013-05-17 10:44:21.416224650 +0300
@@ -287,7 +287,7 @@
             bCBHasChanged = FALSE;
 
             if (hWndViewer)
-                SendMessageW(hWndViewer, WM_DRAWCLIPBOARD, (WPARAM) GetClipboardOwner(), 0);
+                SendNotifyMessageW(hWndViewer, WM_DRAWCLIPBOARD, (WPARAM) GetClipboardOwner(), 0);
         }
 
         bRet = TRUE;
@@ -393,7 +393,7 @@
     HWND hwndPrev = CLIPBOARD_SetClipboardViewer(hWnd);
 
     if (hWnd)
-        SendMessageW(hWnd, WM_DRAWCLIPBOARD, (WPARAM) GetClipboardOwner(), 0);
+        SendNotifyMessageW(hWnd, WM_DRAWCLIPBOARD, (WPARAM) GetClipboardOwner(), 0);
     TRACE("(%p): returning %p\n", hWnd, hwndPrev);
 
     return hwndPrev;
diff -urN wine-1.5.30/dlls/user32/edit.c wine-multimedia/dlls/user32/edit.c
--- wine-1.5.30/dlls/user32/edit.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/user32/edit.c	2013-05-17 10:44:21.423224562 +0300
@@ -5182,6 +5182,8 @@
                         chpos->pt.y = HIWORD(pos);
                         chpos->cLineHeight = es->line_height;
                         chpos->rcDocument = es->format_rect;
+                        MapWindowPoints(hwnd, 0, &chpos->pt, 1);
+                        MapWindowPoints(hwnd, 0, (POINT*)&chpos->rcDocument, 2);
                         result = 1;
                         break;
                     }
diff -urN wine-1.5.30/dlls/user32/tests/clipboard.c wine-multimedia/dlls/user32/tests/clipboard.c
--- wine-1.5.30/dlls/user32/tests/clipboard.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/user32/tests/clipboard.c	2013-05-17 10:44:21.440224350 +0300
@@ -269,6 +269,83 @@
     ok(r, "gle %d\n", GetLastError());
 }
 
+static CRITICAL_SECTION clipboard_cs;
+static LRESULT CALLBACK clipboard_wnd_proc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch(msg) {
+    case WM_DRAWCLIPBOARD:
+        EnterCriticalSection(&clipboard_cs);
+        LeaveCriticalSection(&clipboard_cs);
+        break;
+    case WM_USER:
+        PostQuitMessage(0);
+        break;
+    }
+
+    return DefWindowProc(hwnd, msg, wp, lp);
+}
+
+static DWORD WINAPI clipboard_thread(void *param)
+{
+    HWND win = param;
+    BOOL r;
+
+    EnterCriticalSection(&clipboard_cs);
+    SetLastError(0xdeadbeef);
+    SetClipboardViewer(win);
+    ok(GetLastError() == 0xdeadbeef, "GetLastError = %d\n", GetLastError());
+    LeaveCriticalSection(&clipboard_cs);
+
+    r = OpenClipboard(win);
+    ok(r, "OpenClipboard failed: %d\n", GetLastError());
+
+    r = EmptyClipboard();
+    ok(r, "EmptyClipboard failed: %d\n", GetLastError());
+
+    EnterCriticalSection(&clipboard_cs);
+    r = CloseClipboard();
+    ok(r, "CloseClipboard failed: %d\n", GetLastError());
+    LeaveCriticalSection(&clipboard_cs);
+
+    r = PostMessage(win, WM_USER, 0, 0);
+    ok(r, "PostMessage failed: %d\n", GetLastError());
+    return 0;
+}
+
+static void test_messages(void)
+{
+    WNDCLASS cls;
+    HWND win;
+    MSG msg;
+    HANDLE thread;
+    DWORD tid;
+
+    InitializeCriticalSection(&clipboard_cs);
+
+    memset(&cls, 0, sizeof(cls));
+    cls.lpfnWndProc = clipboard_wnd_proc;
+    cls.hInstance = GetModuleHandle(0);
+    cls.lpszClassName = "clipboard_test";
+    RegisterClass(&cls);
+
+    win = CreateWindow("clipboard_test", NULL, 0, 0, 0, 0, 0, NULL, 0, NULL, 0);
+    ok(win != NULL, "CreateWindow failed: %d\n", GetLastError());
+
+    thread = CreateThread(NULL, 0, clipboard_thread, (void*)win, 0, &tid);
+    ok(thread != NULL, "CreateThread failed: %d\n", GetLastError());
+
+    while(GetMessage(&msg, NULL, 0, 0)) {
+        TranslateMessage(&msg);
+        DispatchMessage(&msg);
+    }
+
+    ok(WaitForSingleObject(thread, INFINITE) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(thread);
+
+    UnregisterClass("clipboard_test", GetModuleHandle(0));
+    DeleteCriticalSection(&clipboard_cs);
+}
+
 START_TEST(clipboard)
 {
     SetLastError(0xdeadbeef);
@@ -278,4 +355,5 @@
     test_RegisterClipboardFormatA();
     test_ClipboardOwner();
     test_synthesized();
+    test_messages();
 }
diff -urN wine-1.5.30/dlls/user32/tests/msg.c wine-multimedia/dlls/user32/tests/msg.c
--- wine-1.5.30/dlls/user32/tests/msg.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/user32/tests/msg.c	2013-05-17 10:44:21.452224200 +0300
@@ -11900,6 +11900,93 @@
     DestroyWindow(hwnd2);
 }
 
+static void test_unicode_wm_char(void)
+{
+    HWND hwnd;
+    MSG msg;
+    struct message seq[2];
+    HKL hkl_orig, hkl_greek;
+    DWORD cp;
+    LCID thread_locale;
+
+    hkl_orig = GetKeyboardLayout( 0 );
+    GetLocaleInfoW( LOWORD( hkl_orig ), LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER, (WCHAR*)&cp, sizeof(cp) / sizeof(WCHAR) );
+    if (cp != 1252)
+    {
+        skip( "Default codepage %d\n", cp );
+        return;
+    }
+
+    hkl_greek = LoadKeyboardLayout( "00000408", 0 );
+    if (!hkl_greek || hkl_greek == hkl_orig /* win2k */)
+    {
+        skip( "Unable to load Greek keyboard layout\n" );
+        return;
+    }
+
+    hwnd = CreateWindowExW( 0, testWindowClassW, NULL, WS_OVERLAPPEDWINDOW,
+                            100, 100, 200, 200, 0, 0, 0, NULL );
+    flush_sequence();
+
+    PostMessageW( hwnd, WM_CHAR, 0x3b1, 0 );
+
+    ok( GetMessageW( &msg, hwnd, 0, 0 ), "no message\n" );
+    ok( msg.hwnd == hwnd, "unexpected hwnd %p\n", msg.hwnd );
+    ok( msg.message == WM_CHAR, "unexpected message %x\n", msg.message );
+    ok( msg.wParam == 0x3b1, "bad wparam %lx\n", msg.wParam );
+    ok( msg.lParam == 0, "bad lparam %lx\n", msg.lParam );
+
+    DispatchMessageW( &msg );
+
+    memset( seq, 0, sizeof(seq) );
+    seq[0].message = WM_CHAR;
+    seq[0].flags = sent|wparam;
+    seq[0].wParam = 0x3b1;
+
+    ok_sequence( seq, "unicode WM_CHAR", FALSE );
+
+    flush_sequence();
+
+    /* greek alpha -> 'a' in cp1252 */
+    PostMessageW( hwnd, WM_CHAR, 0x3b1, 0 );
+
+    ok( GetMessageA( &msg, hwnd, 0, 0 ), "no message\n" );
+    ok( msg.hwnd == hwnd, "unexpected hwnd %p\n", msg.hwnd );
+    ok( msg.message == WM_CHAR, "unexpected message %x\n", msg.message );
+    ok( msg.wParam == 0x61, "bad wparam %lx\n", msg.wParam );
+    ok( msg.lParam == 0, "bad lparam %lx\n", msg.lParam );
+
+    DispatchMessageA( &msg );
+
+    seq[0].wParam = 0x61;
+    ok_sequence( seq, "unicode WM_CHAR", FALSE );
+
+    thread_locale = GetThreadLocale();
+    ActivateKeyboardLayout( hkl_greek, 0 );
+    ok( GetThreadLocale() == thread_locale, "locale changed from %08x to %08x\n",
+        thread_locale, GetThreadLocale() );
+
+    flush_sequence();
+
+    /* greek alpha -> 0xe1 in cp1253 */
+    PostMessageW( hwnd, WM_CHAR, 0x3b1, 0 );
+
+    ok( GetMessageA( &msg, hwnd, 0, 0 ), "no message\n" );
+    ok( msg.hwnd == hwnd, "unexpected hwnd %p\n", msg.hwnd );
+    ok( msg.message == WM_CHAR, "unexpected message %x\n", msg.message );
+    ok( msg.wParam == 0xe1, "bad wparam %lx\n", msg.wParam );
+    ok( msg.lParam == 0, "bad lparam %lx\n", msg.lParam );
+
+    DispatchMessageA( &msg );
+
+    seq[0].wParam = 0x3b1;
+    ok_sequence( seq, "unicode WM_CHAR", FALSE );
+
+    DestroyWindow( hwnd );
+    ActivateKeyboardLayout( hkl_orig, 0 );
+    UnloadKeyboardLayout( hkl_greek );
+}
+
 #define ID_LISTBOX 0x000f
 
 static const struct message wm_lb_setcursel_0[] =
@@ -14124,6 +14211,7 @@
     test_EndDialog();
     test_nullCallback();
     test_dbcs_wm_char();
+    test_unicode_wm_char();
     test_menu_messages();
     test_paintingloop();
     test_defwinproc();
diff -urN wine-1.5.30/dlls/vbscript/vbscript_main.c wine-multimedia/dlls/vbscript/vbscript_main.c
--- wine-1.5.30/dlls/vbscript/vbscript_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/vbscript/vbscript_main.c	2013-05-17 10:44:21.480223850 +0300
@@ -332,6 +332,7 @@
         vbscript_hinstance = hInstDLL;
         break;
     case DLL_PROCESS_DETACH:
+        if (lpv) break;
         release_typelib();
         release_regexp_typelib();
     }
diff -urN wine-1.5.30/dlls/wbemprox/services.c wine-multimedia/dlls/wbemprox/services.c
--- wine-1.5.30/dlls/wbemprox/services.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wbemprox/services.c	2013-05-17 10:44:21.487223762 +0300
@@ -221,8 +221,10 @@
     IWbemServices *iface,
     IWbemObjectSink *pSink )
 {
-    FIXME("\n");
-    return WBEM_E_FAILED;
+    FIXME("%p, %p\n", iface, pSink);
+
+    IWbemObjectSink_Release( pSink );
+    return S_OK;
 }
 
 static HRESULT WINAPI wbem_services_QueryObjectSink(
@@ -562,8 +564,11 @@
     IWbemContext *pCtx,
     IWbemObjectSink *pResponseHandler )
 {
-    FIXME("\n");
-    return WBEM_E_FAILED;
+    FIXME("%p, %s, %s, 0x%08x, %p, %p\n", iface, debugstr_w(strQueryLanguage), debugstr_w(strQuery),
+          lFlags, pCtx, pResponseHandler);
+
+    IWbemObjectSink_AddRef( pResponseHandler );
+    return S_OK;
 }
 
 static HRESULT WINAPI wbem_services_ExecMethod(
diff -urN wine-1.5.30/dlls/wbemprox/tests/query.c wine-multimedia/dlls/wbemprox/tests/query.c
--- wine-1.5.30/dlls/wbemprox/tests/query.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wbemprox/tests/query.c	2013-05-17 10:44:21.488223749 +0300
@@ -516,6 +516,77 @@
     SysFreeString( class );
 }
 
+static HRESULT WINAPI sink_QueryInterface(
+    IWbemObjectSink *iface, REFIID riid, void **ppv )
+{
+    *ppv = NULL;
+    if (IsEqualGUID( &IID_IUnknown, riid ) || IsEqualGUID( &IID_IWbemObjectSink, riid ))
+    {
+        *ppv = iface;
+        IWbemObjectSink_AddRef( iface );
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+static ULONG sink_refs;
+
+static ULONG WINAPI sink_AddRef(
+    IWbemObjectSink *iface )
+{
+    return ++sink_refs;
+}
+
+static ULONG WINAPI sink_Release(
+    IWbemObjectSink *iface )
+{
+    return --sink_refs;
+}
+
+static HRESULT WINAPI sink_Indicate(
+    IWbemObjectSink *iface, LONG count, IWbemClassObject **objects )
+{
+    trace("%d, %p\n", count, objects);
+    return S_OK;
+}
+
+static HRESULT WINAPI sink_SetStatus(
+    IWbemObjectSink *iface, LONG flags, HRESULT hresult, BSTR str_param, IWbemClassObject *obj_param )
+{
+    trace("%08x, %08x, %s, %p\n", flags, hresult, wine_dbgstr_w(str_param), obj_param);
+    return S_OK;
+}
+
+static IWbemObjectSinkVtbl sink_vtbl =
+{
+    sink_QueryInterface,
+    sink_AddRef,
+    sink_Release,
+    sink_Indicate,
+    sink_SetStatus
+};
+
+static IWbemObjectSink sink = { &sink_vtbl };
+
+static void test_notification_query_async( IWbemServices *services )
+{
+    static const WCHAR queryW[] =
+        {'S','E','L','E','C','T',' ','*',' ','F','R','O','M',' ','W','i','n','3','2','_',
+         'D','e','v','i','c','e','C','h','a','n','g','e','E','v','e','n','t',0};
+    BSTR wql = SysAllocString( wqlW ), query = SysAllocString( queryW );
+    HRESULT hr;
+
+    hr = IWbemServices_ExecNotificationQueryAsync( services, wql, query, 0, NULL, &sink );
+    ok( hr == S_OK || broken(hr == WBEM_E_NOT_FOUND), "got %08x\n", hr );
+    ok( sink_refs, "got %u\n", sink_refs );
+
+    hr =  IWbemServices_CancelAsyncCall( services, &sink );
+    ok( hr == S_OK, "got %08x\n", hr );
+
+    SysFreeString( wql );
+    SysFreeString( query );
+}
+
 START_TEST(query)
 {
     static const WCHAR cimv2W[] = {'R','O','O','T','\\','C','I','M','V','2',0};
@@ -545,6 +616,7 @@
     test_Win32_Process( services );
     test_Win32_Service( services );
     test_StdRegProv( services );
+    test_notification_query_async( services );
 
     SysFreeString( path );
     IWbemServices_Release( services );
diff -urN wine-1.5.30/dlls/wined3d/arb_program_shader.c wine-multimedia/dlls/wined3d/arb_program_shader.c
--- wine-1.5.30/dlls/wined3d/arb_program_shader.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wined3d/arb_program_shader.c	2013-05-17 10:44:21.512223449 +0300
@@ -640,8 +640,8 @@
     checkGLcall("Load vs int consts");
 }
 
-static void shader_arb_select(const struct wined3d_context *context, enum wined3d_shader_mode vertex_mode,
-        enum wined3d_shader_mode fragment_mode);
+static void shader_arb_select(void *shader_priv, const struct wined3d_context *context,
+        const struct wined3d_state *state);
 
 /**
  * Loads the app-supplied constants into the currently set ARB_[vertex/fragment]_programs.
@@ -650,40 +650,31 @@
  * worry about the Integers or Booleans
  */
 /* Context activation is done by the caller (state handler). */
-static void shader_arb_load_constants_internal(const struct wined3d_context *context,
+static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
+        const struct wined3d_context *context, const struct wined3d_state *state,
         BOOL usePixelShader, BOOL useVertexShader, BOOL from_shader_select)
 {
-    struct wined3d_device *device = context->swapchain->device;
-    const struct wined3d_stateblock *stateblock = device->stateBlock;
-    const struct wined3d_state *state = &stateblock->state;
-    const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct wined3d_d3d_info *d3d_info = context->d3d_info;
-    struct shader_arb_priv *priv = device->shader_priv;
+    const struct wined3d_gl_info *gl_info = context->gl_info;
 
     if (!from_shader_select)
     {
         const struct wined3d_shader *vshader = state->vertex_shader, *pshader = state->pixel_shader;
         if (vshader
-                && (stateblock->changed.vertexShaderConstantsB & vshader->reg_maps.boolean_constants
+                && (vshader->reg_maps.boolean_constants
                 || (!gl_info->supported[NV_VERTEX_PROGRAM2_OPTION]
-                && (stateblock->changed.vertexShaderConstantsI
-                & vshader->reg_maps.integer_constants & ~vshader->reg_maps.local_int_consts))))
+                && (vshader->reg_maps.integer_constants & ~vshader->reg_maps.local_int_consts))))
         {
             TRACE("bool/integer vertex shader constants potentially modified, forcing shader reselection.\n");
-            shader_arb_select(context,
-                    useVertexShader ? WINED3D_SHADER_MODE_SHADER : WINED3D_SHADER_MODE_FFP,
-                    usePixelShader ? WINED3D_SHADER_MODE_SHADER : WINED3D_SHADER_MODE_FFP);
+            shader_arb_select(priv, context, state);
         }
         else if (pshader
-                && (stateblock->changed.pixelShaderConstantsB & pshader->reg_maps.boolean_constants
+                && (pshader->reg_maps.boolean_constants
                 || (!gl_info->supported[NV_FRAGMENT_PROGRAM_OPTION]
-                && (stateblock->changed.pixelShaderConstantsI
-                & pshader->reg_maps.integer_constants & ~pshader->reg_maps.local_int_consts))))
+                && (pshader->reg_maps.integer_constants & ~pshader->reg_maps.local_int_consts))))
         {
             TRACE("bool/integer pixel shader constants potentially modified, forcing shader reselection.\n");
-            shader_arb_select(context,
-                    useVertexShader ? WINED3D_SHADER_MODE_SHADER : WINED3D_SHADER_MODE_FFP,
-                    usePixelShader ? WINED3D_SHADER_MODE_SHADER : WINED3D_SHADER_MODE_FFP);
+            shader_arb_select(priv, context, state);
         }
     }
 
@@ -724,9 +715,13 @@
     }
 }
 
-static void shader_arb_load_constants(const struct wined3d_context *context, BOOL ps, BOOL vs)
+static void shader_arb_load_constants(void *shader_priv, const struct wined3d_context *context,
+        const struct wined3d_state *state)
 {
-    shader_arb_load_constants_internal(context, ps, vs, FALSE);
+    BOOL vs = use_vs(state);
+    BOOL ps = use_ps(state);
+
+    shader_arb_load_constants_internal(shader_priv, context, state, ps, vs, FALSE);
 }
 
 static void shader_arb_update_float_vertex_constants(struct wined3d_device *device, UINT start, UINT count)
@@ -3954,7 +3949,8 @@
     return found_sig->idx;
 }
 
-static void init_output_registers(const struct wined3d_shader *shader, DWORD sig_num,
+static void init_output_registers(const struct wined3d_shader *shader,
+        const struct wined3d_shader_signature_element *ps_input_sig,
         struct shader_arb_ctx_priv *priv_ctx, struct arb_vs_compiled_shader *compiled)
 {
     unsigned int i, j;
@@ -3963,8 +3959,6 @@
         "result.texcoord[0]", "result.texcoord[1]", "result.texcoord[2]", "result.texcoord[3]",
         "result.texcoord[4]", "result.texcoord[5]", "result.texcoord[6]", "result.texcoord[7]"
     };
-    struct wined3d_device *device = shader->device;
-    const struct wined3d_shader_signature_element *sig;
     const char *semantic_name;
     DWORD semantic_idx, reg_idx;
 
@@ -3978,7 +3972,7 @@
         "result.color.primary", "result.color.secondary"
     };
 
-    if(sig_num == ~0)
+    if (!ps_input_sig)
     {
         TRACE("Pixel shader uses builtin varyings\n");
         /* Map builtins to builtins */
@@ -4037,10 +4031,6 @@
         return;
     }
 
-    /* Instead of searching for the signature in the signature list, read the one from the current pixel shader.
-     * Its maybe not the shader where the signature came from, but it is the same signature and faster to find
-     */
-    sig = device->stateBlock->state.pixel_shader->input_signature;
     TRACE("Pixel shader uses declared varyings\n");
 
     /* Map builtin to declared. /dev/null the results by default to the TA temp reg */
@@ -4054,9 +4044,9 @@
 
     for(i = 0; i < MAX_REG_INPUT; i++)
     {
-        semantic_name = sig[i].semantic_name;
-        semantic_idx = sig[i].semantic_idx;
-        reg_idx = sig[i].register_idx;
+        semantic_name = ps_input_sig[i].semantic_name;
+        semantic_idx = ps_input_sig[i].semantic_idx;
+        reg_idx = ps_input_sig[i].register_idx;
         if (!semantic_name) continue;
 
         /* If a declared input register is not written by builtin arguments, don't write to it.
@@ -4115,12 +4105,12 @@
 
         for(j = 0; j < MAX_REG_INPUT; j++)
         {
-            if (!sig[j].semantic_name) continue;
+            if (!ps_input_sig[j].semantic_name) continue;
 
-            if (!strcmp(sig[j].semantic_name, semantic_name)
-                    && sig[j].semantic_idx == shader->output_signature[i].semantic_idx)
+            if (!strcmp(ps_input_sig[j].semantic_name, semantic_name)
+                    && ps_input_sig[j].semantic_idx == shader->output_signature[i].semantic_idx)
             {
-                priv_ctx->vs_output[i] = decl_idx_to_string[sig[j].register_idx];
+                priv_ctx->vs_output[i] = decl_idx_to_string[ps_input_sig[j].register_idx];
 
                 if (!strcmp(priv_ctx->vs_output[i], "result.color.primary")
                         || !strcmp(priv_ctx->vs_output[i], "result.color.secondary"))
@@ -4135,7 +4125,8 @@
 /* Context activation is done by the caller. */
 static GLuint shader_arb_generate_vshader(const struct wined3d_shader *shader,
         const struct wined3d_gl_info *gl_info, struct wined3d_shader_buffer *buffer,
-        const struct arb_vs_compile_args *args, struct arb_vs_compiled_shader *compiled)
+        const struct arb_vs_compile_args *args, struct arb_vs_compiled_shader *compiled,
+        const struct wined3d_shader_signature_element *ps_input_sig)
 {
     const struct arb_vshader_private *shader_data = shader->backend_data;
     const struct wined3d_shader_reg_maps *reg_maps = &shader->reg_maps;
@@ -4150,7 +4141,7 @@
     memset(&priv_ctx, 0, sizeof(priv_ctx));
     priv_ctx.cur_vs_args = args;
     list_init(&priv_ctx.control_frames);
-    init_output_registers(shader, args->ps_signature, &priv_ctx, compiled);
+    init_output_registers(shader, ps_input_sig, &priv_ctx, compiled);
 
     /*  Create the hw ARB shader */
     shader_addline(buffer, "!!ARBvp1.0\n");
@@ -4311,7 +4302,7 @@
         shader_data->clamp_consts = shader->reg_maps.shader_version.major == 1;
 
         if (shader->reg_maps.shader_version.major < 3)
-            shader_data->input_signature_idx = ~0;
+            shader_data->input_signature_idx = ~0U;
         else
             shader_data->input_signature_idx = find_input_signature(priv, shader->input_signature);
 
@@ -4387,7 +4378,8 @@
 }
 
 static struct arb_vs_compiled_shader *find_arb_vshader(struct wined3d_shader *shader,
-        const struct arb_vs_compile_args *args)
+        const struct arb_vs_compile_args *args,
+        const struct wined3d_shader_signature_element *ps_input_sig)
 {
     struct wined3d_device *device = shader->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -4465,7 +4457,8 @@
     }
 
     ret = shader_arb_generate_vshader(shader, gl_info, &buffer, args,
-            &shader_data->gl_shaders[shader_data->num_gl_shaders]);
+            &shader_data->gl_shaders[shader_data->num_gl_shaders],
+            ps_input_sig);
     shader_buffer_free(&buffer);
     shader_data->gl_shaders[shader_data->num_gl_shaders].prgId = ret;
 
@@ -4608,17 +4601,15 @@
 }
 
 /* Context activation is done by the caller. */
-static void shader_arb_select(const struct wined3d_context *context, enum wined3d_shader_mode vertex_mode,
-        enum wined3d_shader_mode fragment_mode)
+static void shader_arb_select(void *shader_priv, const struct wined3d_context *context,
+        const struct wined3d_state *state)
 {
-    struct wined3d_device *device = context->swapchain->device;
-    struct shader_arb_priv *priv = device->shader_priv;
+    struct shader_arb_priv *priv = shader_priv;
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_state *state = &device->stateBlock->state;
     int i;
 
     /* Deal with pixel shaders first so the vertex shader arg function has the input signature ready */
-    if (fragment_mode == WINED3D_SHADER_MODE_SHADER)
+    if (use_ps(state))
     {
         struct wined3d_shader *ps = state->pixel_shader;
         struct arb_ps_compile_args compile_args;
@@ -4641,8 +4632,7 @@
         gl_info->gl_ops.gl.p_glEnable(GL_FRAGMENT_PROGRAM_ARB);
         checkGLcall("glEnable(GL_FRAGMENT_PROGRAM_ARB);");
 
-        TRACE("(%p) : Bound fragment program %u and enabled GL_FRAGMENT_PROGRAM_ARB\n",
-                device, priv->current_fprogram_id);
+        TRACE("Bound fragment program %u and enabled GL_FRAGMENT_PROGRAM_ARB\n", priv->current_fprogram_id);
 
         /* Pixel Shader 1.x constants are clamped to [-1;1], Pixel Shader 2.0 constants are not. If switching between
          * a 1.x and newer shader, reload the first 8 constants
@@ -4656,7 +4646,7 @@
                 priv->pshader_const_dirty[i] = 1;
             }
             /* Also takes care of loading local constants */
-            shader_arb_load_constants_internal(context, TRUE, FALSE, TRUE);
+            shader_arb_load_constants_internal(shader_priv, context, state, TRUE, FALSE, TRUE);
         }
         else
         {
@@ -4680,18 +4670,28 @@
             checkGLcall("glDisable(GL_FRAGMENT_PROGRAM_ARB)");
             priv->current_fprogram_id = 0;
         }
-        priv->fragment_pipe->enable_extension(gl_info, fragment_mode == WINED3D_SHADER_MODE_FFP);
+        priv->fragment_pipe->enable_extension(gl_info, TRUE);
     }
 
-    if (vertex_mode == WINED3D_SHADER_MODE_SHADER)
+    if (use_vs(state))
     {
         struct wined3d_shader *vs = state->vertex_shader;
         struct arb_vs_compile_args compile_args;
         struct arb_vs_compiled_shader *compiled;
+        const struct wined3d_shader_signature_element *ps_input_sig;
 
         TRACE("Using vertex shader %p\n", vs);
         find_arb_vs_compile_args(state, context, vs, &compile_args);
-        compiled = find_arb_vshader(vs, &compile_args);
+
+        /* Instead of searching for the signature in the signature list, read the one from the
+         * current pixel shader. It's maybe not the shader where the signature came from, but it
+         * is the same signature and faster to find. */
+        if (compile_args.ps_signature == ~0U)
+            ps_input_sig = NULL;
+        else
+            ps_input_sig = state->pixel_shader->input_signature;
+
+        compiled = find_arb_vshader(vs, &compile_args, ps_input_sig);
         priv->current_vprogram_id = compiled->prgId;
         priv->compiled_vprog = compiled;
 
@@ -4699,10 +4699,12 @@
         GL_EXTCALL(glBindProgramARB(GL_VERTEX_PROGRAM_ARB, priv->current_vprogram_id));
         checkGLcall("glBindProgramARB(GL_VERTEX_PROGRAM_ARB, priv->current_vprogram_id);");
 
+        priv->vertex_pipe->vp_enable(gl_info, FALSE);
+
         /* Enable OpenGL vertex programs */
         gl_info->gl_ops.gl.p_glEnable(GL_VERTEX_PROGRAM_ARB);
         checkGLcall("glEnable(GL_VERTEX_PROGRAM_ARB);");
-        TRACE("(%p) : Bound vertex program %u and enabled GL_VERTEX_PROGRAM_ARB\n", device, priv->current_vprogram_id);
+        TRACE("Bound vertex program %u and enabled GL_VERTEX_PROGRAM_ARB\n", priv->current_vprogram_id);
         shader_arb_vs_local_constants(compiled, context, state);
 
         if(priv->last_vs_color_unclamp != compiled->need_color_unclamp) {
@@ -4717,13 +4719,47 @@
             }
         }
     }
-    else if (gl_info->supported[ARB_VERTEX_PROGRAM])
+    else
+    {
+        if (gl_info->supported[ARB_VERTEX_PROGRAM])
+        {
+            priv->current_vprogram_id = 0;
+            gl_info->gl_ops.gl.p_glDisable(GL_VERTEX_PROGRAM_ARB);
+            checkGLcall("glDisable(GL_VERTEX_PROGRAM_ARB)");
+        }
+        priv->vertex_pipe->vp_enable(gl_info, TRUE);
+    }
+}
+
+
+/* Context activation is done by the caller. */
+static void shader_arb_disable(void *shader_priv, const struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    struct shader_arb_priv *priv = shader_priv;
+
+    if (gl_info->supported[ARB_FRAGMENT_PROGRAM])
+    {
+        gl_info->gl_ops.gl.p_glDisable(GL_FRAGMENT_PROGRAM_ARB);
+        checkGLcall("glDisable(GL_FRAGMENT_PROGRAM_ARB)");
+        priv->current_fprogram_id = 0;
+    }
+    priv->fragment_pipe->enable_extension(gl_info, FALSE);
+
+    if (gl_info->supported[ARB_VERTEX_PROGRAM])
     {
         priv->current_vprogram_id = 0;
         gl_info->gl_ops.gl.p_glDisable(GL_VERTEX_PROGRAM_ARB);
         checkGLcall("glDisable(GL_VERTEX_PROGRAM_ARB)");
     }
-    priv->vertex_pipe->vp_enable(gl_info, vertex_mode == WINED3D_SHADER_MODE_FFP);
+    priv->vertex_pipe->vp_enable(gl_info, FALSE);
+
+    if (gl_info->supported[ARB_COLOR_BUFFER_FLOAT] && priv->last_vs_color_unclamp)
+    {
+        GL_EXTCALL(glClampColorARB(GL_CLAMP_VERTEX_COLOR_ARB, GL_FIXED_ONLY_ARB));
+        checkGLcall("glClampColorARB");
+        priv->last_vs_color_unclamp = FALSE;
+    }
 }
 
 /* Context activation is done by the caller. */
@@ -5621,6 +5657,7 @@
 {
     shader_arb_handle_instruction,
     shader_arb_select,
+    shader_arb_disable,
     shader_arb_select_depth_blt,
     shader_arb_deselect_depth_blt,
     shader_arb_update_float_vertex_constants,
@@ -7005,7 +7042,7 @@
 {
     BYTE table[256][4];
     struct wined3d_device *device = surface->resource.device;
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    const struct wined3d_gl_info *gl_info = context->gl_info;
     struct arbfp_blit_priv *priv = device->blit_priv;
     BOOL colorkey = (surface->CKeyFlags & WINEDDSD_CKSRCBLT) != 0;
 
diff -urN wine-1.5.30/dlls/wined3d/ati_fragment_shader.c wine-multimedia/dlls/wined3d/ati_fragment_shader.c
--- wine-1.5.30/dlls/wined3d/ati_fragment_shader.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wined3d/ati_fragment_shader.c	2013-05-17 10:44:21.513223437 +0300
@@ -1167,10 +1167,9 @@
 }
 
 /* Context activation is done by the caller. */
-static void atifs_free_ffpshader(struct wine_rb_entry *entry, void *context)
+static void atifs_free_ffpshader(struct wine_rb_entry *entry, void *cb_ctx)
 {
-    struct wined3d_device *device = context;
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    const struct wined3d_gl_info *gl_info = cb_ctx;
     struct atifs_ffp_desc *entry_ati = WINE_RB_ENTRY_VALUE(entry, struct atifs_ffp_desc, parent.entry);
 
     GL_EXTCALL(glDeleteFragmentShaderATI(entry_ati->shader));
@@ -1183,7 +1182,7 @@
 {
     struct atifs_private_data *priv = device->fragment_priv;
 
-    wine_rb_destroy(&priv->fragment_shaders, atifs_free_ffpshader, device);
+    wine_rb_destroy(&priv->fragment_shaders, atifs_free_ffpshader, &device->adapter->gl_info);
 
     HeapFree(GetProcessHeap(), 0, priv);
     device->fragment_priv = NULL;
diff -urN wine-1.5.30/dlls/wined3d/context.c wine-multimedia/dlls/wined3d/context.c
--- wine-1.5.30/dlls/wined3d/context.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wined3d/context.c	2013-05-17 10:44:21.515223412 +0300
@@ -1,7 +1,7 @@
 /*
  * Context and render target management in wined3d
  *
- * Copyright 2007-2008 Stefan Dösinger for CodeWeavers
+ * Copyright 2007-2011, 2013 Stefan Dösinger for CodeWeavers
  * Copyright 2009-2011 Henri Verbeet for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
@@ -1922,7 +1922,7 @@
     set_blit_dimension(gl_info, rt_size.cx, rt_size.cy);
 
     /* Disable shaders */
-    device->shader_backend->shader_select(context, WINED3D_SHADER_MODE_NONE, WINED3D_SHADER_MODE_NONE);
+    device->shader_backend->shader_disable(device->shader_priv, context);
     context->select_shader = 1;
     context->load_constants = 1;
 
@@ -2403,15 +2403,14 @@
 
     if (context->select_shader)
     {
-        device->shader_backend->shader_select(context,
-                use_vs(state) ? WINED3D_SHADER_MODE_SHADER : WINED3D_SHADER_MODE_FFP,
-                use_ps(state) ? WINED3D_SHADER_MODE_SHADER : WINED3D_SHADER_MODE_FFP);
+        device->shader_backend->shader_select(device->shader_priv, context, state);
         context->select_shader = 0;
     }
 
     if (context->load_constants)
     {
-        device->shader_backend->shader_load_constants(context, use_ps(state), use_vs(state));
+        device->shader_backend->shader_load_constants(device->shader_priv,
+                context, state);
         context->load_constants = 0;
     }
 
diff -urN wine-1.5.30/dlls/wined3d/glsl_shader.c wine-multimedia/dlls/wined3d/glsl_shader.c
--- wine-1.5.30/dlls/wined3d/glsl_shader.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wined3d/glsl_shader.c	2013-05-17 10:44:21.524223299 +0300
@@ -3,7 +3,7 @@
  *
  * Copyright 2006 Jason Green
  * Copyright 2006-2007 Henri Verbeet
- * Copyright 2007-2008 Stefan Dösinger for CodeWeavers
+ * Copyright 2007-2009, 2013 Stefan Dösinger for CodeWeavers
  * Copyright 2009-2011 Henri Verbeet for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
@@ -725,14 +725,11 @@
 }
 
 /* Context activation is done by the caller (state handler). */
-static void shader_glsl_load_constants(const struct wined3d_context *context,
-        BOOL usePixelShader, BOOL useVertexShader)
+static void shader_glsl_load_constants(void *shader_priv, const struct wined3d_context *context,
+        const struct wined3d_state *state)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    struct wined3d_device *device = context->swapchain->device;
-    struct wined3d_stateblock *stateBlock = device->stateBlock;
-    const struct wined3d_state *state = &stateBlock->state;
-    struct shader_glsl_priv *priv = device->shader_priv;
+    struct shader_glsl_priv *priv = shader_priv;
     float position_fixup[4];
 
     GLhandleARB programId;
@@ -747,7 +744,7 @@
     programId = prog->programId;
     constant_version = prog->constant_version;
 
-    if (useVertexShader)
+    if (use_vs(state))
     {
         const struct wined3d_shader *vshader = state->vertex_shader;
 
@@ -757,11 +754,11 @@
 
         /* Load DirectX 9 integer constants/uniforms for vertex shader */
         shader_glsl_load_constantsI(vshader, gl_info, prog->vs.uniform_i_locations, state->vs_consts_i,
-                stateBlock->changed.vertexShaderConstantsI & vshader->reg_maps.integer_constants);
+                vshader->reg_maps.integer_constants);
 
         /* Load DirectX 9 boolean constants/uniforms for vertex shader */
         shader_glsl_load_constantsB(vshader, gl_info, programId, state->vs_consts_b,
-                stateBlock->changed.vertexShaderConstantsB & vshader->reg_maps.boolean_constants);
+                vshader->reg_maps.boolean_constants);
 
         /* Upload the position fixup params */
         shader_get_position_fixup(context, state, position_fixup);
@@ -769,7 +766,7 @@
         checkGLcall("glUniform4fvARB");
     }
 
-    if (usePixelShader)
+    if (use_ps(state))
     {
         const struct wined3d_shader *pshader = state->pixel_shader;
 
@@ -779,11 +776,11 @@
 
         /* Load DirectX 9 integer constants/uniforms for pixel shader */
         shader_glsl_load_constantsI(pshader, gl_info, prog->ps.uniform_i_locations, state->ps_consts_i,
-                stateBlock->changed.pixelShaderConstantsI & pshader->reg_maps.integer_constants);
+                pshader->reg_maps.integer_constants);
 
         /* Load DirectX 9 boolean constants/uniforms for pixel shader */
         shader_glsl_load_constantsB(pshader, gl_info, programId, state->ps_consts_b,
-                stateBlock->changed.pixelShaderConstantsB & pshader->reg_maps.boolean_constants);
+                pshader->reg_maps.boolean_constants);
 
         /* Upload the environment bump map matrix if needed. The needsbumpmat
          * member specifies the texture stage to load the matrix from. It
@@ -5483,13 +5480,11 @@
 }
 
 /* Context activation is done by the caller. */
-static void set_glsl_shader_program(const struct wined3d_context *context, struct wined3d_device *device,
-        enum wined3d_shader_mode vertex_mode, enum wined3d_shader_mode fragment_mode)
+static void set_glsl_shader_program(const struct wined3d_context *context, const struct wined3d_state *state,
+        struct shader_glsl_priv *priv)
 {
-    const struct wined3d_state *state = &device->stateBlock->state;
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct ps_np2fixup_info *np2fixup_info = NULL;
-    struct shader_glsl_priv *priv = device->shader_priv;
     struct glsl_shader_prog_link *entry = NULL;
     struct wined3d_shader *vshader = NULL;
     struct wined3d_shader *gshader = NULL;
@@ -5501,8 +5496,9 @@
     struct vs_compile_args vs_compile_args;
     GLhandleARB vs_id, gs_id, ps_id;
     struct list *ps_list;
+    struct wined3d_device *device = context->swapchain->device;
 
-    if (vertex_mode == WINED3D_SHADER_MODE_SHADER)
+    if (use_vs(state))
     {
         vshader = state->vertex_shader;
         find_vs_compile_args(state, vshader, &vs_compile_args);
@@ -5519,7 +5515,7 @@
         gs_id = 0;
     }
 
-    if (fragment_mode == WINED3D_SHADER_MODE_SHADER)
+    if (use_ps(state))
     {
         pshader = state->pixel_shader;
         find_ps_compile_args(state, pshader, &ps_compile_args);
@@ -5527,7 +5523,7 @@
                 pshader, &ps_compile_args, &np2fixup_info);
         ps_list = &pshader->linked_programs;
     }
-    else if (fragment_mode == WINED3D_SHADER_MODE_FFP && priv->fragment_pipe == &glsl_fragment_pipe)
+    else if (priv->fragment_pipe == &glsl_fragment_pipe)
     {
         struct glsl_ffp_fragment_shader *ffp_shader;
         struct ffp_frag_settings settings;
@@ -5784,20 +5780,19 @@
 }
 
 /* Context activation is done by the caller. */
-static void shader_glsl_select(const struct wined3d_context *context, enum wined3d_shader_mode vertex_mode,
-        enum wined3d_shader_mode fragment_mode)
+static void shader_glsl_select(void *shader_priv, const struct wined3d_context *context,
+        const struct wined3d_state *state)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    struct wined3d_device *device = context->swapchain->device;
-    struct shader_glsl_priv *priv = device->shader_priv;
+    struct shader_glsl_priv *priv = shader_priv;
     GLhandleARB program_id = 0;
     GLenum old_vertex_color_clamp, current_vertex_color_clamp;
 
-    priv->vertex_pipe->vp_enable(gl_info, vertex_mode == WINED3D_SHADER_MODE_FFP);
-    priv->fragment_pipe->enable_extension(gl_info, fragment_mode == WINED3D_SHADER_MODE_FFP);
+    priv->vertex_pipe->vp_enable(gl_info, !use_vs(state));
+    priv->fragment_pipe->enable_extension(gl_info, !use_ps(state));
 
     old_vertex_color_clamp = priv->glsl_program ? priv->glsl_program->vs.vertex_color_clamp : GL_FIXED_ONLY_ARB;
-    set_glsl_shader_program(context, device, vertex_mode, fragment_mode);
+    set_glsl_shader_program(context, state, priv);
     current_vertex_color_clamp = priv->glsl_program ? priv->glsl_program->vs.vertex_color_clamp : GL_FIXED_ONLY_ARB;
     if (old_vertex_color_clamp != current_vertex_color_clamp)
     {
@@ -5822,7 +5817,27 @@
      * called between selecting the shader and using it, which results in wrong fixup for some frames. */
     if (priv->glsl_program && priv->glsl_program->ps.np2_fixup_info)
     {
-        shader_glsl_load_np2fixup_constants(priv, gl_info, &device->stateBlock->state);
+        shader_glsl_load_np2fixup_constants(priv, gl_info, state);
+    }
+}
+
+/* Context activation is done by the caller. */
+static void shader_glsl_disable(void *shader_priv, const struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    struct shader_glsl_priv *priv = shader_priv;
+
+    priv->glsl_program = NULL;
+    GL_EXTCALL(glUseProgramObjectARB(0));
+    checkGLcall("glUseProgramObjectARB");
+
+    priv->vertex_pipe->vp_enable(gl_info, FALSE);
+    priv->fragment_pipe->enable_extension(gl_info, FALSE);
+
+    if (gl_info->supported[ARB_COLOR_BUFFER_FLOAT])
+    {
+        GL_EXTCALL(glClampColorARB(GL_CLAMP_VERTEX_COLOR_ARB, GL_FIXED_ONLY_ARB));
+        checkGLcall("glClampColorARB");
     }
 }
 
@@ -5910,7 +5925,7 @@
                 {
                     TRACE("Deleting pixel shader %u.\n", gl_shaders[i].prgId);
                     if (priv->glsl_program && priv->glsl_program->ps.id == gl_shaders[i].prgId)
-                        shader_glsl_select(context, WINED3D_SHADER_MODE_NONE, WINED3D_SHADER_MODE_NONE);
+                        shader_glsl_disable(priv, context);
                     GL_EXTCALL(glDeleteObjectARB(gl_shaders[i].prgId));
                     checkGLcall("glDeleteObjectARB");
                 }
@@ -5933,7 +5948,7 @@
                 {
                     TRACE("Deleting vertex shader %u.\n", gl_shaders[i].prgId);
                     if (priv->glsl_program && priv->glsl_program->vs.id == gl_shaders[i].prgId)
-                        shader_glsl_select(context, WINED3D_SHADER_MODE_NONE, WINED3D_SHADER_MODE_NONE);
+                        shader_glsl_disable(priv, context);
                     GL_EXTCALL(glDeleteObjectARB(gl_shaders[i].prgId));
                     checkGLcall("glDeleteObjectARB");
                 }
@@ -5956,7 +5971,7 @@
                 {
                     TRACE("Deleting geometry shader %u.\n", gl_shaders[i].id);
                     if (priv->glsl_program && priv->glsl_program->gs.id == gl_shaders[i].id)
-                        shader_glsl_select(context, WINED3D_SHADER_MODE_NONE, WINED3D_SHADER_MODE_NONE);
+                        shader_glsl_disable(priv, context);
                     GL_EXTCALL(glDeleteObjectARB(gl_shaders[i].id));
                     checkGLcall("glDeleteObjectARB");
                 }
@@ -6345,6 +6360,7 @@
 {
     shader_glsl_handle_instruction,
     shader_glsl_select,
+    shader_glsl_disable,
     shader_glsl_select_depth_blt,
     shader_glsl_deselect_depth_blt,
     shader_glsl_update_float_vertex_constants,
diff -urN wine-1.5.30/dlls/wined3d/shader.c wine-multimedia/dlls/wined3d/shader.c
--- wine-1.5.30/dlls/wined3d/shader.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wined3d/shader.c	2013-05-17 10:44:21.526223274 +0300
@@ -4,7 +4,7 @@
  * Copyright 2004 Christian Costa
  * Copyright 2005 Oliver Stieber
  * Copyright 2006 Ivan Gyurdiev
- * Copyright 2007-2008 Stefan Dösinger for CodeWeavers
+ * Copyright 2007-2008, 2013 Stefan Dösinger for CodeWeavers
  * Copyright 2009-2011 Henri Verbeet for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
@@ -1509,21 +1509,32 @@
 static void shader_none_deselect_depth_blt(void *shader_priv, const struct wined3d_gl_info *gl_info) {}
 static void shader_none_update_float_vertex_constants(struct wined3d_device *device, UINT start, UINT count) {}
 static void shader_none_update_float_pixel_constants(struct wined3d_device *device, UINT start, UINT count) {}
-static void shader_none_load_constants(const struct wined3d_context *context, BOOL usePS, BOOL useVS) {}
+static void shader_none_load_constants(void *shader_priv, const struct wined3d_context *context,
+        const struct wined3d_state *state) {}
 static void shader_none_load_np2fixup_constants(void *shader_priv,
         const struct wined3d_gl_info *gl_info, const struct wined3d_state *state) {}
 static void shader_none_destroy(struct wined3d_shader *shader) {}
 static void shader_none_context_destroyed(void *shader_priv, const struct wined3d_context *context) {}
 
-static void shader_none_select(const struct wined3d_context *context, enum wined3d_shader_mode vertex_mode,
-        enum wined3d_shader_mode fragment_mode)
+/* Context activation is done by the caller. */
+static void shader_none_select(void *shader_priv, const struct wined3d_context *context,
+        const struct wined3d_state *state)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    struct wined3d_device *device = context->swapchain->device;
-    struct shader_none_priv *priv = device->shader_priv;
+    struct shader_none_priv *priv = shader_priv;
+
+    priv->vertex_pipe->vp_enable(gl_info, !use_vs(state));
+    priv->fragment_pipe->enable_extension(gl_info, !use_ps(state));
+}
+
+/* Context activation is done by the caller. */
+static void shader_none_disable(void *shader_priv, const struct wined3d_context *context)
+{
+    struct shader_none_priv *priv = shader_priv;
+    const struct wined3d_gl_info *gl_info = context->gl_info;
 
-    priv->vertex_pipe->vp_enable(gl_info, vertex_mode == WINED3D_SHADER_MODE_FFP);
-    priv->fragment_pipe->enable_extension(gl_info, fragment_mode == WINED3D_SHADER_MODE_FFP);
+    priv->vertex_pipe->vp_enable(gl_info, FALSE);
+    priv->fragment_pipe->enable_extension(gl_info, FALSE);
 }
 
 static HRESULT shader_none_alloc(struct wined3d_device *device, const struct wined3d_vertex_pipe_ops *vertex_pipe,
@@ -1602,6 +1613,7 @@
 {
     shader_none_handle_instruction,
     shader_none_select,
+    shader_none_disable,
     shader_none_select_depth_blt,
     shader_none_deselect_depth_blt,
     shader_none_update_float_vertex_constants,
diff -urN wine-1.5.30/dlls/wined3d/wined3d_main.c wine-multimedia/dlls/wined3d/wined3d_main.c
--- wine-1.5.30/dlls/wined3d/wined3d_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wined3d/wined3d_main.c	2013-05-17 10:44:21.539223112 +0300
@@ -521,18 +521,15 @@
             return wined3d_dll_init(hInstDLL);
 
         case DLL_PROCESS_DETACH:
+            if (lpv) break;
             return wined3d_dll_destroy(hInstDLL);
 
         case DLL_THREAD_DETACH:
-        {
             if (!context_set_current(NULL))
             {
                 ERR("Failed to clear current context.\n");
             }
             return TRUE;
-        }
-
-        default:
-            return TRUE;
     }
+    return TRUE;
 }
diff -urN wine-1.5.30/dlls/wined3d/wined3d_private.h wine-multimedia/dlls/wined3d/wined3d_private.h
--- wine-1.5.30/dlls/wined3d/wined3d_private.h	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wined3d/wined3d_private.h	2013-05-17 10:44:21.541223087 +0300
@@ -5,6 +5,7 @@
  * Copyright 2002-2003 Raphael Junqueira
  * Copyright 2002-2003, 2004 Jason Edmeades
  * Copyright 2005 Oliver Stieber
+ * Copyright 2006-2011, 2013 Stefan Dösinger for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -784,13 +785,6 @@
     WORD                        swizzle_map;   /* MAX_ATTRIBS, 16 */
 };
 
-enum wined3d_shader_mode
-{
-    WINED3D_SHADER_MODE_NONE,
-    WINED3D_SHADER_MODE_FFP,
-    WINED3D_SHADER_MODE_SHADER,
-};
-
 struct wined3d_context;
 struct wined3d_state;
 struct fragment_pipeline;
@@ -799,14 +793,16 @@
 struct wined3d_shader_backend_ops
 {
     void (*shader_handle_instruction)(const struct wined3d_shader_instruction *);
-    void (*shader_select)(const struct wined3d_context *context, enum wined3d_shader_mode vertex_mode,
-            enum wined3d_shader_mode fragment_mode);
+    void (*shader_select)(void *shader_priv, const struct wined3d_context *context,
+            const struct wined3d_state *state);
+    void (*shader_disable)(void *shader_priv, const struct wined3d_context *context);
     void (*shader_select_depth_blt)(void *shader_priv, const struct wined3d_gl_info *gl_info,
             enum tex_types tex_type, const SIZE *ds_mask_size);
     void (*shader_deselect_depth_blt)(void *shader_priv, const struct wined3d_gl_info *gl_info);
     void (*shader_update_float_vertex_constants)(struct wined3d_device *device, UINT start, UINT count);
     void (*shader_update_float_pixel_constants)(struct wined3d_device *device, UINT start, UINT count);
-    void (*shader_load_constants)(const struct wined3d_context *context, BOOL usePS, BOOL useVS);
+    void (*shader_load_constants)(void *shader_priv, const struct wined3d_context *context,
+            const struct wined3d_state *state);
     void (*shader_load_np2fixup_constants)(void *shader_priv, const struct wined3d_gl_info *gl_info,
             const struct wined3d_state *state);
     void (*shader_destroy)(struct wined3d_shader *shader);
diff -urN wine-1.5.30/dlls/winemac.drv/cocoa_window.h wine-multimedia/dlls/winemac.drv/cocoa_window.h
--- wine-1.5.30/dlls/winemac.drv/cocoa_window.h	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/winemac.drv/cocoa_window.h	2013-05-17 10:44:21.546223024 +0300
@@ -26,7 +26,6 @@
 
 @interface WineWindow : NSPanel <NSWindowDelegate>
 {
-    NSUInteger normalStyleMask;
     BOOL disabled;
     BOOL noActivate;
     BOOL floating;
diff -urN wine-1.5.30/dlls/winemac.drv/cocoa_window.m wine-multimedia/dlls/winemac.drv/cocoa_window.m
--- wine-1.5.30/dlls/winemac.drv/cocoa_window.m	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/winemac.drv/cocoa_window.m	2013-05-17 10:44:21.547223012 +0300
@@ -460,7 +460,6 @@
                                               defer:YES] autorelease];
 
         if (!window) return nil;
-        window->normalStyleMask = [window styleMask];
 
         /* Standardize windows to eliminate differences between titled and
            borderless windows and between NSWindow and NSPanel. */
@@ -515,22 +514,37 @@
 
     - (void) adjustFeaturesForState
     {
-        NSUInteger style = normalStyleMask;
-
-        if (self.disabled)
-            style &= ~NSResizableWindowMask;
-        if (style != [self styleMask])
-            [self setStyleMask:style];
+        NSUInteger style = [self styleMask];
 
         if (style & NSClosableWindowMask)
             [[self standardWindowButton:NSWindowCloseButton] setEnabled:!self.disabled];
         if (style & NSMiniaturizableWindowMask)
             [[self standardWindowButton:NSWindowMiniaturizeButton] setEnabled:!self.disabled];
+        if (style & NSResizableWindowMask)
+            [[self standardWindowButton:NSWindowZoomButton] setEnabled:!self.disabled];
     }
 
     - (void) setWindowFeatures:(const struct macdrv_window_features*)wf
     {
-        normalStyleMask = style_mask_for_features(wf);
+        NSUInteger currentStyle = [self styleMask];
+        NSUInteger newStyle = style_mask_for_features(wf);
+
+        if (newStyle != currentStyle)
+        {
+            BOOL showingButtons = (currentStyle & (NSClosableWindowMask | NSMiniaturizableWindowMask | NSResizableWindowMask)) != 0;
+            BOOL shouldShowButtons = (newStyle & (NSClosableWindowMask | NSMiniaturizableWindowMask | NSResizableWindowMask)) != 0;
+            if (shouldShowButtons != showingButtons && !((newStyle ^ currentStyle) & NSClosableWindowMask))
+            {
+                // -setStyleMask: is buggy on 10.7+ with respect to NSResizableWindowMask.
+                // If transitioning from NSTitledWindowMask | NSResizableWindowMask to
+                // just NSTitledWindowMask, the window buttons should disappear rather
+                // than just being disabled.  But they don't.  Similarly in reverse.
+                // The workaround is to also toggle NSClosableWindowMask at the same time.
+                [self setStyleMask:newStyle ^ NSClosableWindowMask];
+            }
+            [self setStyleMask:newStyle];
+        }
+
         [self adjustFeaturesForState];
         [self setHasShadow:wf->shadow];
     }
@@ -791,6 +805,18 @@
         {
             disabled = newValue;
             [self adjustFeaturesForState];
+
+            if (disabled)
+            {
+                NSSize size = [self frame].size;
+                [self setMinSize:size];
+                [self setMaxSize:size];
+            }
+            else
+            {
+                [self setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];
+                [self setMinSize:NSZeroSize];
+            }
         }
     }
 
@@ -1165,8 +1191,16 @@
     - (void)windowDidResize:(NSNotification *)notification
     {
         macdrv_event* event;
-        NSRect frame = [self contentRectForFrameRect:[self frame]];
+        NSRect frame = [self frame];
+
+        if (self.disabled)
+        {
+            NSSize size = frame.size;
+            [self setMinSize:size];
+            [self setMaxSize:size];
+        }
 
+        frame = [self contentRectForFrameRect:frame];
         [[WineApplicationController sharedController] flipRect:&frame];
 
         /* Coalesce events by discarding any previous ones still in the queue. */
diff -urN wine-1.5.30/dlls/wineoss.drv/mmdevdrv.c wine-multimedia/dlls/wineoss.drv/mmdevdrv.c
--- wine-1.5.30/dlls/wineoss.drv/mmdevdrv.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wineoss.drv/mmdevdrv.c	2013-05-17 10:44:21.554222924 +0300
@@ -243,6 +243,7 @@
         break;
 
     case DLL_PROCESS_DETACH:
+        if (!reserved)
         {
             OSSDevice *iter, *iter2;
 
@@ -251,9 +252,8 @@
             LIST_FOR_EACH_ENTRY_SAFE(iter, iter2, &g_devices, OSSDevice, entry){
                 HeapFree(GetProcessHeap(), 0, iter);
             }
-
-            break;
         }
+        break;
     }
     return TRUE;
 }
diff -urN wine-1.5.30/dlls/winepulse.drv/Makefile.in wine-multimedia/dlls/winepulse.drv/Makefile.in
--- wine-1.5.30/dlls/winepulse.drv/Makefile.in	1970-01-01 03:00:00.000000000 +0300
+++ wine-multimedia/dlls/winepulse.drv/Makefile.in	2013-05-17 10:44:21.566222774 +0300
@@ -0,0 +1,9 @@
+MODULE    = winepulse.drv
+IMPORTS   = dxguid uuid winmm user32 advapi32 ole32
+EXTRALIBS = @PULSELIBS@ @LIBPTHREAD@
+EXTRAINCL = @PULSEINCL@
+
+C_SRCS = \
+	mmdevdrv.c
+
+@MAKE_DLL_RULES@
diff -urN wine-1.5.30/dlls/winepulse.drv/mmdevdrv.c wine-multimedia/dlls/winepulse.drv/mmdevdrv.c
--- wine-1.5.30/dlls/winepulse.drv/mmdevdrv.c	1970-01-01 03:00:00.000000000 +0300
+++ wine-multimedia/dlls/winepulse.drv/mmdevdrv.c	2013-05-17 10:44:21.566222774 +0300
@@ -0,0 +1,3179 @@
+/*
+ * Copyright 2011-2012 Maarten Lankhorst
+ * Copyright 2010-2011 Maarten Lankhorst for CodeWeavers
+ * Copyright 2011 Andrew Eikum for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ * Pulseaudio driver support.. hell froze over
+ */
+
+#define NONAMELESSUNION
+#define COBJMACROS
+#include "config.h"
+#include <poll.h>
+#include <pthread.h>
+
+#include <stdarg.h>
+#include <unistd.h>
+#include <math.h>
+#include <stdio.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/list.h"
+
+#include "ole2.h"
+#include "dshow.h"
+#include "dsound.h"
+#include "propsys.h"
+
+#include "initguid.h"
+#include "ks.h"
+#include "ksmedia.h"
+#include "mmdeviceapi.h"
+#include "audioclient.h"
+#include "endpointvolume.h"
+#include "audiopolicy.h"
+
+#include "wine/list.h"
+
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
+
+WINE_DEFAULT_DEBUG_CHANNEL(pulse);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
+
+static const REFERENCE_TIME MinimumPeriod = 30000;
+static const REFERENCE_TIME DefaultPeriod = 100000;
+
+static pa_context *pulse_ctx;
+static pa_mainloop *pulse_ml;
+
+static HANDLE pulse_thread;
+static pthread_mutex_t pulse_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
+static struct list g_sessions = LIST_INIT(g_sessions);
+
+/* Mixer format + period times */
+static WAVEFORMATEXTENSIBLE pulse_fmt[2];
+static REFERENCE_TIME pulse_min_period[2], pulse_def_period[2];
+
+static DWORD pulse_stream_volume;
+
+const WCHAR pulse_keyW[] = {'S','o','f','t','w','a','r','e','\\',
+    'W','i','n','e','\\','P','u','l','s','e',0};
+const WCHAR pulse_streamW[] = { 'S','t','r','e','a','m','V','o','l',0 };
+
+static GUID pulse_render_guid =
+{ 0xfd47d9cc, 0x4218, 0x4135, { 0x9c, 0xe2, 0x0c, 0x19, 0x5c, 0x87, 0x40, 0x5b } };
+static GUID pulse_capture_guid =
+{ 0x25da76d0, 0x033c, 0x4235, { 0x90, 0x02, 0x19, 0xf4, 0x88, 0x94, 0xac, 0x6f } };
+
+static HANDLE warn_once;
+
+BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
+{
+    if (reason == DLL_PROCESS_ATTACH) {
+        HKEY key;
+        if (RegOpenKeyW(HKEY_CURRENT_USER, pulse_keyW, &key) == ERROR_SUCCESS) {
+            DWORD size = sizeof(pulse_stream_volume);
+            RegQueryValueExW(key, pulse_streamW, 0, NULL,
+                             (BYTE*)&pulse_stream_volume, &size);
+            RegCloseKey(key);
+        }
+        DisableThreadLibraryCalls(dll);
+    } else if (reason == DLL_PROCESS_DETACH) {
+        if (pulse_thread)
+           SetThreadPriority(pulse_thread, 0);
+        if (pulse_ctx) {
+           pa_context_disconnect(pulse_ctx);
+           pa_context_unref(pulse_ctx);
+        }
+        if (pulse_ml)
+            pa_mainloop_quit(pulse_ml, 0);
+        if (pulse_thread)
+            CloseHandle(pulse_thread);
+        if (warn_once)
+            CloseHandle(warn_once);
+    }
+    return TRUE;
+}
+
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+typedef struct _ACPacket {
+    struct list entry;
+    UINT64 qpcpos;
+    BYTE *data;
+    UINT32 discont;
+} ACPacket;
+
+struct ACImpl {
+    IAudioClient IAudioClient_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+    IMMDevice *parent;
+    struct list entry;
+    float vol[PA_CHANNELS_MAX];
+
+    LONG ref;
+    EDataFlow dataflow;
+    DWORD flags;
+    AUDCLNT_SHAREMODE share;
+    HANDLE event;
+
+    UINT32 bufsize_frames, bufsize_bytes, locked, capture_period, pad, started, peek_ofs;
+    void *locked_ptr, *tmp_buffer;
+
+    pa_stream *stream;
+    pa_sample_spec ss;
+    pa_channel_map map;
+
+    INT64 clock_lastpos, clock_written;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+    struct list packet_free_head;
+    struct list packet_filled_head;
+};
+
+static const WCHAR defaultW[] = {'P','u','l','s','e','a','u','d','i','o',0};
+
+static const IAudioClientVtbl AudioClient_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
+
+static inline ACImpl *impl_from_IAudioClient(IAudioClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
+
+/* Following pulseaudio design here, mainloop has the lock taken whenever
+ * it is handling something for pulse, and the lock is required whenever
+ * doing any pa_* call that can affect the state in any way
+ *
+ * pa_cond_wait is used when waiting on results, because the mainloop needs
+ * the same lock taken to affect the state
+ *
+ * This is basically the same as the pa_threaded_mainloop implementation,
+ * but that cannot be used because it uses pthread_create directly
+ *
+ * pa_threaded_mainloop_(un)lock -> pthread_mutex_(un)lock
+ * pa_threaded_mainloop_signal -> pthread_cond_signal
+ * pa_threaded_mainloop_wait -> pthread_cond_wait
+ */
+
+static int pulse_poll_func(struct pollfd *ufds, unsigned long nfds, int timeout, void *userdata) {
+    int r;
+    pthread_mutex_unlock(&pulse_lock);
+    r = poll(ufds, nfds, timeout);
+    pthread_mutex_lock(&pulse_lock);
+    return r;
+}
+
+static DWORD CALLBACK pulse_mainloop_thread(void *tmp) {
+    int ret;
+    pulse_ml = pa_mainloop_new();
+    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
+    pthread_mutex_lock(&pulse_lock);
+    pthread_cond_signal(&pulse_cond);
+    pa_mainloop_run(pulse_ml, &ret);
+    pthread_mutex_unlock(&pulse_lock);
+    pa_mainloop_free(pulse_ml);
+    CloseHandle(pulse_thread);
+    return ret;
+}
+
+static void pulse_contextcallback(pa_context *c, void *userdata);
+static void pulse_stream_state(pa_stream *s, void *user);
+
+static const enum pa_channel_position pulse_pos_from_wfx[] = {
+    PA_CHANNEL_POSITION_FRONT_LEFT,
+    PA_CHANNEL_POSITION_FRONT_RIGHT,
+    PA_CHANNEL_POSITION_FRONT_CENTER,
+    PA_CHANNEL_POSITION_LFE,
+    PA_CHANNEL_POSITION_REAR_LEFT,
+    PA_CHANNEL_POSITION_REAR_RIGHT,
+    PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
+    PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
+    PA_CHANNEL_POSITION_REAR_CENTER,
+    PA_CHANNEL_POSITION_SIDE_LEFT,
+    PA_CHANNEL_POSITION_SIDE_RIGHT,
+    PA_CHANNEL_POSITION_TOP_CENTER,
+    PA_CHANNEL_POSITION_TOP_FRONT_LEFT,
+    PA_CHANNEL_POSITION_TOP_FRONT_CENTER,
+    PA_CHANNEL_POSITION_TOP_FRONT_RIGHT,
+    PA_CHANNEL_POSITION_TOP_REAR_LEFT,
+    PA_CHANNEL_POSITION_TOP_REAR_CENTER,
+    PA_CHANNEL_POSITION_TOP_REAR_RIGHT
+};
+
+static void pulse_probe_settings(int render, WAVEFORMATEXTENSIBLE *fmt) {
+    WAVEFORMATEX *wfx = &fmt->Format;
+    pa_stream *stream;
+    pa_channel_map map;
+    pa_sample_spec ss;
+    pa_buffer_attr attr;
+    int ret, i;
+    unsigned int length = 0;
+
+    pa_channel_map_init_auto(&map, 2, PA_CHANNEL_MAP_ALSA);
+    ss.rate = 48000;
+    ss.format = PA_SAMPLE_FLOAT32LE;
+    ss.channels = map.channels;
+
+    attr.maxlength = -1;
+    attr.tlength = -1;
+    attr.minreq = attr.fragsize = pa_frame_size(&ss);
+    attr.prebuf = 0;
+
+    stream = pa_stream_new(pulse_ctx, "format test stream", &ss, &map);
+    if (stream)
+        pa_stream_set_state_callback(stream, pulse_stream_state, NULL);
+    if (!stream)
+        ret = -1;
+    else if (render)
+        ret = pa_stream_connect_playback(stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(stream, NULL, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
+    if (ret >= 0) {
+        while (pa_stream_get_state(stream) == PA_STREAM_CREATING)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        if (pa_stream_get_state(stream) == PA_STREAM_READY) {
+            ss = *pa_stream_get_sample_spec(stream);
+            map = *pa_stream_get_channel_map(stream);
+            if (render)
+                length = pa_stream_get_buffer_attr(stream)->minreq;
+            else
+                length = pa_stream_get_buffer_attr(stream)->fragsize;
+            pa_stream_disconnect(stream);
+            while (pa_stream_get_state(stream) == PA_STREAM_READY)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+        }
+    }
+    if (stream)
+        pa_stream_unref(stream);
+    if (length)
+        pulse_def_period[!render] = pulse_min_period[!render] = pa_bytes_to_usec(10 * length, &ss);
+    else
+        pulse_min_period[!render] = MinimumPeriod;
+    if (pulse_def_period[!render] <= DefaultPeriod)
+        pulse_def_period[!render] = DefaultPeriod;
+
+    wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+    wfx->nChannels = ss.channels;
+    wfx->wBitsPerSample = 8 * pa_sample_size_of_format(ss.format);
+    wfx->nSamplesPerSec = ss.rate;
+    wfx->nBlockAlign = pa_frame_size(&ss);
+    wfx->nAvgBytesPerSec = wfx->nSamplesPerSec * wfx->nBlockAlign;
+    if (ss.format != PA_SAMPLE_S24_32LE)
+        fmt->Samples.wValidBitsPerSample = wfx->wBitsPerSample;
+    else
+        fmt->Samples.wValidBitsPerSample = 24;
+    if (ss.format == PA_SAMPLE_FLOAT32LE)
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+    else
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
+
+    fmt->dwChannelMask = 0;
+    for (i = 0; i < map.channels; ++i)
+        switch (map.map[i]) {
+            default: FIXME("Unhandled channel %s\n", pa_channel_position_to_string(map.map[i])); break;
+            case PA_CHANNEL_POSITION_FRONT_LEFT: fmt->dwChannelMask |= SPEAKER_FRONT_LEFT; break;
+            case PA_CHANNEL_POSITION_MONO:
+            case PA_CHANNEL_POSITION_FRONT_CENTER: fmt->dwChannelMask |= SPEAKER_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_FRONT_RIGHT: fmt->dwChannelMask |= SPEAKER_FRONT_RIGHT; break;
+            case PA_CHANNEL_POSITION_REAR_LEFT: fmt->dwChannelMask |= SPEAKER_BACK_LEFT; break;
+            case PA_CHANNEL_POSITION_REAR_CENTER: fmt->dwChannelMask |= SPEAKER_BACK_CENTER; break;
+            case PA_CHANNEL_POSITION_REAR_RIGHT: fmt->dwChannelMask |= SPEAKER_BACK_RIGHT; break;
+            case PA_CHANNEL_POSITION_LFE: fmt->dwChannelMask |= SPEAKER_LOW_FREQUENCY; break;
+            case PA_CHANNEL_POSITION_SIDE_LEFT: fmt->dwChannelMask |= SPEAKER_SIDE_LEFT; break;
+            case PA_CHANNEL_POSITION_SIDE_RIGHT: fmt->dwChannelMask |= SPEAKER_SIDE_RIGHT; break;
+            case PA_CHANNEL_POSITION_TOP_CENTER: fmt->dwChannelMask |= SPEAKER_TOP_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_LEFT: fmt->dwChannelMask |= SPEAKER_TOP_FRONT_LEFT; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_CENTER: fmt->dwChannelMask |= SPEAKER_TOP_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_RIGHT: fmt->dwChannelMask |= SPEAKER_TOP_FRONT_RIGHT; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_LEFT: fmt->dwChannelMask |= SPEAKER_TOP_BACK_LEFT; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_CENTER: fmt->dwChannelMask |= SPEAKER_TOP_BACK_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_RIGHT: fmt->dwChannelMask |= SPEAKER_TOP_BACK_RIGHT; break;
+        }
+}
+
+static HRESULT pulse_connect(void)
+{
+    int len;
+    WCHAR path[PATH_MAX], *name;
+    char *str;
+
+    if (!pulse_thread)
+    {
+        if (!(pulse_thread = CreateThread(NULL, 0, pulse_mainloop_thread, NULL, 0, NULL)))
+        {
+            ERR("Failed to create mainloop thread.");
+            return E_FAIL;
+        }
+        SetThreadPriority(pulse_thread, THREAD_PRIORITY_TIME_CRITICAL);
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
+    }
+
+    if (pulse_ctx && PA_CONTEXT_IS_GOOD(pa_context_get_state(pulse_ctx)))
+        return S_OK;
+    if (pulse_ctx)
+        pa_context_unref(pulse_ctx);
+
+    GetModuleFileNameW(NULL, path, sizeof(path)/sizeof(*path));
+    name = strrchrW(path, '\\');
+    if (!name)
+        name = path;
+    else
+        name++;
+    len = WideCharToMultiByte(CP_UNIXCP, 0, name, -1, NULL, 0, NULL, NULL);
+    str = pa_xmalloc(len);
+    WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
+    TRACE("Name: %s\n", str);
+    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), str);
+    pa_xfree(str);
+    if (!pulse_ctx) {
+        ERR("Failed to create context\n");
+        return E_FAIL;
+    }
+
+    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
+    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+        goto fail;
+
+    /* Wait for connection */
+    while (pthread_cond_wait(&pulse_cond, &pulse_lock)) {
+        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+
+        if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
+            goto fail;
+
+        if (state == PA_CONTEXT_READY)
+            break;
+    }
+
+    TRACE("Connected to server %s with protocol version: %i.\n",
+        pa_context_get_server(pulse_ctx),
+        pa_context_get_server_protocol_version(pulse_ctx));
+    pulse_probe_settings(1, &pulse_fmt[0]);
+    pulse_probe_settings(0, &pulse_fmt[1]);
+    return S_OK;
+
+fail:
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    return E_FAIL;
+}
+
+static void pulse_contextcallback(pa_context *c, void *userdata) {
+    switch (pa_context_get_state(c)) {
+        default:
+            FIXME("Unhandled state: %i\n", pa_context_get_state(c));
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+        case PA_CONTEXT_TERMINATED:
+            TRACE("State change to %i\n", pa_context_get_state(c));
+            return;
+
+        case PA_CONTEXT_READY:
+            TRACE("Ready\n");
+            break;
+
+        case PA_CONTEXT_FAILED:
+            ERR("Context failed: %s\n", pa_strerror(pa_context_errno(c)));
+            break;
+    }
+    pthread_cond_signal(&pulse_cond);
+}
+
+static HRESULT pulse_stream_valid(ACImpl *This) {
+    if (!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+    if (!This->stream || pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+    return S_OK;
+}
+
+static void dump_attr(const pa_buffer_attr *attr) {
+    TRACE("maxlength: %u\n", attr->maxlength);
+    TRACE("minreq: %u\n", attr->minreq);
+    TRACE("fragsize: %u\n", attr->fragsize);
+    TRACE("tlength: %u\n", attr->tlength);
+    TRACE("prebuf: %u\n", attr->prebuf);
+}
+
+static void pulse_op_cb(pa_stream *s, int success, void *user) {
+    TRACE("Success: %i\n", success);
+    *(int*)user = success;
+    pthread_cond_signal(&pulse_cond);
+}
+
+static void pulse_ctx_op_cb(pa_context *c, int success, void *user) {
+    TRACE("Success: %i\n", success);
+    *(int*)user = success;
+    pthread_cond_signal(&pulse_cond);
+}
+
+static void pulse_attr_update(pa_stream *s, void *user) {
+    const pa_buffer_attr *attr = pa_stream_get_buffer_attr(s);
+    TRACE("New attributes or device moved:\n");
+    dump_attr(attr);
+}
+
+static void pulse_wr_callback(pa_stream *s, size_t bytes, void *userdata)
+{
+    ACImpl *This = userdata;
+    UINT32 oldpad = This->pad;
+
+    if (bytes < This->bufsize_bytes)
+        This->pad = This->bufsize_bytes - bytes;
+    else
+        This->pad = 0;
+
+    if (oldpad == This->pad)
+        return;
+
+    assert(oldpad > This->pad);
+
+    This->clock_written += oldpad - This->pad;
+    TRACE("New pad: %zu (-%zu)\n", This->pad / pa_frame_size(&This->ss), (oldpad - This->pad) / pa_frame_size(&This->ss));
+
+    if (This->event)
+        SetEvent(This->event);
+}
+
+static void pulse_underflow_callback(pa_stream *s, void *userdata)
+{
+    WARN("Underflow\n");
+}
+
+/* Latency is periodically updated even when nothing is played,
+ * because of PA_STREAM_AUTO_TIMING_UPDATE so use it as timer
+ *
+ * Perfect for passing all tests :)
+ */
+static void pulse_latency_callback(pa_stream *s, void *userdata)
+{
+    ACImpl *This = userdata;
+    if (!This->pad && This->event)
+        SetEvent(This->event);
+}
+
+static void pulse_started_callback(pa_stream *s, void *userdata)
+{
+    TRACE("(Re)started playing\n");
+}
+
+static void pulse_rd_loop(ACImpl *This, size_t bytes)
+{
+    while (bytes >= This->capture_period) {
+        ACPacket *p, *next;
+        LARGE_INTEGER stamp, freq;
+        BYTE *dst, *src;
+        size_t src_len, copy, rem = This->capture_period;
+        if (!(p = (ACPacket*)list_head(&This->packet_free_head))) {
+            p = (ACPacket*)list_head(&This->packet_filled_head);
+            if (!p->discont) {
+                next = (ACPacket*)p->entry.next;
+                next->discont = 1;
+            } else
+                p = (ACPacket*)list_tail(&This->packet_filled_head);
+            assert(This->pad == This->bufsize_bytes);
+        } else {
+            assert(This->pad < This->bufsize_bytes);
+            This->pad += This->capture_period;
+            assert(This->pad <= This->bufsize_bytes);
+        }
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        p->qpcpos = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+        p->discont = 0;
+        list_remove(&p->entry);
+        list_add_tail(&This->packet_filled_head, &p->entry);
+
+        dst = p->data;
+        while (rem) {
+            pa_stream_peek(This->stream, (const void**)&src, &src_len);
+            assert(src_len);
+            assert(This->peek_ofs < src_len);
+            src += This->peek_ofs;
+            src_len -= This->peek_ofs;
+            assert(src_len <= bytes);
+
+            copy = rem;
+            if (copy > src_len)
+                copy = src_len;
+            memcpy(dst, src, rem);
+            src += copy;
+            src_len -= copy;
+            dst += copy;
+            rem -= copy;
+
+            if (!src_len) {
+                This->peek_ofs = 0;
+                pa_stream_drop(This->stream);
+            } else
+                This->peek_ofs += copy;
+        }
+        bytes -= This->capture_period;
+    }
+}
+
+static void pulse_rd_drop(ACImpl *This, size_t bytes)
+{
+    while (bytes >= This->capture_period) {
+        size_t src_len, copy, rem = This->capture_period;
+        while (rem) {
+            const void *src;
+            pa_stream_peek(This->stream, &src, &src_len);
+            assert(src_len);
+            assert(This->peek_ofs < src_len);
+            src_len -= This->peek_ofs;
+            assert(src_len <= bytes);
+
+            copy = rem;
+            if (copy > src_len)
+                copy = src_len;
+
+            src_len -= copy;
+            rem -= copy;
+
+            if (!src_len) {
+                This->peek_ofs = 0;
+                pa_stream_drop(This->stream);
+            } else
+                This->peek_ofs += copy;
+            bytes -= copy;
+        }
+    }
+}
+
+static void pulse_rd_callback(pa_stream *s, size_t bytes, void *userdata)
+{
+    ACImpl *This = userdata;
+
+    TRACE("Readable total: %zu, fragsize: %u\n", bytes, pa_stream_get_buffer_attr(s)->fragsize);
+    assert(bytes >= This->peek_ofs);
+    bytes -= This->peek_ofs;
+    if (bytes < This->capture_period)
+        return;
+
+    if (This->started)
+        pulse_rd_loop(This, bytes);
+    else
+        pulse_rd_drop(This, bytes);
+
+    if (This->event)
+        SetEvent(This->event);
+}
+
+static void pulse_stream_state(pa_stream *s, void *user)
+{
+    pa_stream_state_t state = pa_stream_get_state(s);
+    TRACE("Stream state changed to %i\n", state);
+    pthread_cond_signal(&pulse_cond);
+}
+
+static HRESULT pulse_stream_connect(ACImpl *This, UINT32 period_bytes) {
+    int ret;
+    char buffer[64];
+    static LONG number;
+    pa_buffer_attr attr;
+    if (This->stream) {
+        pa_stream_disconnect(This->stream);
+        while (pa_stream_get_state(This->stream) == PA_STREAM_READY)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        pa_stream_unref(This->stream);
+    }
+    ret = InterlockedIncrement(&number);
+    sprintf(buffer, "audio stream #%i", ret);
+    This->stream = pa_stream_new(pulse_ctx, buffer, &This->ss, &This->map);
+    pa_stream_set_state_callback(This->stream, pulse_stream_state, This);
+    pa_stream_set_buffer_attr_callback(This->stream, pulse_attr_update, This);
+    pa_stream_set_moved_callback(This->stream, pulse_attr_update, This);
+
+    /* Pulseaudio will fill in correct values */
+    attr.minreq = attr.fragsize = period_bytes;
+    attr.maxlength = attr.tlength = This->bufsize_bytes;
+    attr.prebuf = pa_frame_size(&This->ss);
+    dump_attr(&attr);
+    if (This->dataflow == eRender)
+        ret = pa_stream_connect_playback(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS);
+    if (ret < 0) {
+        WARN("Returns %i\n", ret);
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+    }
+    while (pa_stream_get_state(This->stream) == PA_STREAM_CREATING)
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
+    if (pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+
+    if (This->dataflow == eRender) {
+        pa_stream_set_write_callback(This->stream, pulse_wr_callback, This);
+        pa_stream_set_underflow_callback(This->stream, pulse_underflow_callback, This);
+        pa_stream_set_started_callback(This->stream, pulse_started_callback, This);
+    } else
+        pa_stream_set_read_callback(This->stream, pulse_rd_callback, This);
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, const WCHAR ***ids, GUID **keys,
+        UINT *num, UINT *def_index)
+{
+    HRESULT hr = S_OK;
+    WCHAR *id;
+
+    TRACE("%d %p %p %p\n", flow, ids, num, def_index);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_connect();
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+    *num = 1;
+    *def_index = 0;
+
+    *ids = HeapAlloc(GetProcessHeap(), 0, sizeof(**ids));
+    *keys = NULL;
+    if (!*ids)
+        return E_OUTOFMEMORY;
+
+    (*ids)[0] = id = HeapAlloc(GetProcessHeap(), 0, sizeof(defaultW));
+    *keys = HeapAlloc(GetProcessHeap(), 0, sizeof(**keys));
+    if (!*keys || !id) {
+        HeapFree(GetProcessHeap(), 0, id);
+        HeapFree(GetProcessHeap(), 0, *keys);
+        HeapFree(GetProcessHeap(), 0, *ids);
+        *ids = NULL;
+        *keys = NULL;
+        return E_OUTOFMEMORY;
+    }
+    memcpy(id, defaultW, sizeof(defaultW));
+
+    if (flow == eRender)
+        (*keys)[0] = pulse_render_guid;
+    else
+        (*keys)[0] = pulse_capture_guid;
+
+    return S_OK;
+}
+
+int WINAPI AUDDRV_GetPriority(void)
+{
+    HRESULT hr;
+    if (getenv("WINENOPULSE")) {
+        FIXME_(winediag)("winepulse has been temporarily disabled through the environment\n");
+        return 0;
+    }
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_connect();
+    pthread_mutex_unlock(&pulse_lock);
+    return SUCCEEDED(hr) ? 3 : 0;
+}
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev, IAudioClient **out)
+{
+    HRESULT hr;
+    ACImpl *This;
+    int i;
+    EDataFlow dataflow;
+
+    /* Give one visible warning per session
+     * Sadly wine has chosen not to accept the winepulse patch, so support ourselves
+     */
+    if (!warn_once && (warn_once = CreateEventA(0, 0, 0, "__winepulse_warn_event")) && GetLastError() != ERROR_ALREADY_EXISTS) {
+        FIXME_(winediag)("Winepulse is not officially supported by the wine project\n");
+        FIXME_(winediag)("For sound related feedback and support, please visit http://ubuntuforums.org/showthread.php?t=1960599\n");
+    } else {
+        WARN_(winediag)("Winepulse is not officially supported by the wine project\n");
+        WARN_(winediag)("For sound related feedback and support, please visit http://ubuntuforums.org/showthread.php?t=1960599\n");
+    }
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+    if (IsEqualGUID(guid, &pulse_render_guid))
+        dataflow = eRender;
+    else if (IsEqualGUID(guid, &pulse_capture_guid))
+        dataflow = eCapture;
+    else
+        return E_UNEXPECTED;
+
+    *out = NULL;
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_connect();
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioClient_iface.lpVtbl = &AudioClient_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+    This->dataflow = dataflow;
+    This->parent = dev;
+    for (i = 0; i < PA_CHANNELS_MAX; ++i)
+        This->vol[i] = 1.f;
+    IMMDevice_AddRef(This->parent);
+
+    *out = &This->IAudioClient_iface;
+    IAudioClient_AddRef(&This->IAudioClient_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref) {
+        if (This->stream) {
+            pthread_mutex_lock(&pulse_lock);
+            if (PA_STREAM_IS_GOOD(pa_stream_get_state(This->stream))) {
+                pa_stream_disconnect(This->stream);
+                while (PA_STREAM_IS_GOOD(pa_stream_get_state(This->stream)))
+                    pthread_cond_wait(&pulse_cond, &pulse_lock);
+            }
+            pa_stream_unref(This->stream);
+            This->stream = NULL;
+            list_remove(&This->entry);
+            pthread_mutex_unlock(&pulse_lock);
+        }
+        IMMDevice_Release(This->parent);
+        HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag) {
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %u\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %u\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08x\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static WAVEFORMATEX *clone_format(const WAVEFORMATEX *fmt)
+{
+    WAVEFORMATEX *ret;
+    size_t size;
+
+    if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        size = sizeof(WAVEFORMATEXTENSIBLE);
+    else
+        size = sizeof(WAVEFORMATEX);
+
+    ret = CoTaskMemAlloc(size);
+    if (!ret)
+        return NULL;
+
+    memcpy(ret, fmt, size);
+
+    ret->cbSize = size - sizeof(WAVEFORMATEX);
+
+    return ret;
+}
+
+static DWORD get_channel_mask(unsigned int channels)
+{
+    switch(channels) {
+    case 0:
+        return 0;
+    case 1:
+        return SPEAKER_FRONT_CENTER;
+    case 2:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
+    case 3:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |
+            SPEAKER_LOW_FREQUENCY;
+    case 4:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT;
+    case 5:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY;
+    case 6:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_FRONT_CENTER;
+    case 7:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_FRONT_CENTER |
+            SPEAKER_BACK_CENTER;
+    case 8:
+        return SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT |
+            SPEAKER_BACK_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_FRONT_CENTER |
+            SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT;
+    }
+    FIXME("Unknown speaker configuration: %u\n", channels);
+    return 0;
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if (session->channel_count < channels) {
+        UINT i;
+
+        if (session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if (!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if (!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if (!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)) {
+        *out = create_session(&GUID_NULL, device, channels);
+        if (!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry) {
+        if (session->device == device &&
+            IsEqualGUID(sessionguid, &session->guid)) {
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if (!*out) {
+        *out = create_session(sessionguid, device, channels);
+        if (!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT pulse_spec_from_waveformat(ACImpl *This, const WAVEFORMATEX *fmt)
+{
+    pa_channel_map_init(&This->map);
+    This->ss.rate = fmt->nSamplesPerSec;
+    This->ss.format = PA_SAMPLE_INVALID;
+    switch(fmt->wFormatTag) {
+    case WAVE_FORMAT_IEEE_FLOAT:
+        if (!fmt->nChannels || fmt->nChannels > 2 || fmt->wBitsPerSample != 32)
+            break;
+        This->ss.format = PA_SAMPLE_FLOAT32LE;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_PCM:
+        if (!fmt->nChannels || fmt->nChannels > 2)
+            break;
+        if (fmt->wBitsPerSample == 8)
+            This->ss.format = PA_SAMPLE_U8;
+        else if (fmt->wBitsPerSample == 16)
+            This->ss.format = PA_SAMPLE_S16LE;
+        else
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_EXTENSIBLE: {
+        WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE*)fmt;
+        DWORD mask = wfe->dwChannelMask;
+        DWORD i = 0, j;
+        if (fmt->cbSize != (sizeof(*wfe) - sizeof(*fmt)) && fmt->cbSize != sizeof(*wfe))
+            break;
+        if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) &&
+            (!wfe->Samples.wValidBitsPerSample || wfe->Samples.wValidBitsPerSample == 32) &&
+            fmt->wBitsPerSample == 32)
+            This->ss.format = PA_SAMPLE_FLOAT32LE;
+        else if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
+            DWORD valid = wfe->Samples.wValidBitsPerSample;
+            if (!valid)
+                valid = fmt->wBitsPerSample;
+            if (!valid || valid > fmt->wBitsPerSample)
+                break;
+            switch (fmt->wBitsPerSample) {
+                case 8:
+                    if (valid == 8)
+                        This->ss.format = PA_SAMPLE_U8;
+                    break;
+                case 16:
+                    if (valid == 16)
+                        This->ss.format = PA_SAMPLE_S16LE;
+                    break;
+                case 24:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24LE;
+                    break;
+                case 32:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24_32LE;
+                    else if (valid == 32)
+                        This->ss.format = PA_SAMPLE_S32LE;
+                    break;
+                default:
+                    return AUDCLNT_E_UNSUPPORTED_FORMAT;
+            }
+        }
+        This->map.channels = fmt->nChannels;
+        if (!mask || (mask & (SPEAKER_ALL|SPEAKER_RESERVED)))
+            mask = get_channel_mask(fmt->nChannels);
+        for (j = 0; j < sizeof(pulse_pos_from_wfx)/sizeof(*pulse_pos_from_wfx) && i < fmt->nChannels; ++j) {
+            if (mask & (1 << j))
+                This->map.map[i++] = pulse_pos_from_wfx[j];
+        }
+
+        /* Special case for mono since pulse appears to map it differently */
+        if (mask == SPEAKER_FRONT_CENTER)
+            This->map.map[0] = PA_CHANNEL_POSITION_MONO;
+
+        if (i < fmt->nChannels || (mask & SPEAKER_RESERVED)) {
+            This->map.channels = 0;
+            ERR("Invalid channel mask: %i/%i and %x(%x)\n", i, fmt->nChannels, mask, wfe->dwChannelMask);
+            break;
+        }
+        break;
+        }
+        case WAVE_FORMAT_ALAW:
+        case WAVE_FORMAT_MULAW:
+            if (fmt->wBitsPerSample != 8) {
+                FIXME("Unsupported bpp %u for LAW\n", fmt->wBitsPerSample);
+                return AUDCLNT_E_UNSUPPORTED_FORMAT;
+            }
+            if (fmt->nChannels != 1 && fmt->nChannels != 2) {
+                FIXME("Unsupported channels %u for LAW\n", fmt->nChannels);
+                return AUDCLNT_E_UNSUPPORTED_FORMAT;
+            }
+            This->ss.format = fmt->wFormatTag == WAVE_FORMAT_MULAW ? PA_SAMPLE_ULAW : PA_SAMPLE_ALAW;
+            pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+            break;
+        default:
+            WARN("Unhandled tag %x\n", fmt->wFormatTag);
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+    }
+    This->ss.channels = This->map.channels;
+    if (!pa_channel_map_valid(&This->map) || This->ss.format == PA_SAMPLE_INVALID) {
+        ERR("Invalid format! Channel spec valid: %i, format: %i\n", pa_channel_map_valid(&This->map), This->ss.format);
+        dump_fmt(fmt);
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+    }
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    UINT period_bytes;
+
+    TRACE("(%p)->(%x, %x, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if (!fmt)
+        return E_POINTER;
+
+    if (mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return AUDCLNT_E_NOT_INITIALIZED;
+    if (mode == AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
+
+    if (flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED)) {
+        TRACE("Unknown flags: %08x\n", flags);
+        return E_INVALIDARG;
+    }
+
+    pthread_mutex_lock(&pulse_lock);
+    if (This->stream) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    hr = pulse_spec_from_waveformat(This, fmt);
+    if (FAILED(hr))
+        goto exit;
+
+    if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        REFERENCE_TIME def = pulse_def_period[This->dataflow == eCapture];
+        REFERENCE_TIME min = pulse_min_period[This->dataflow == eCapture];
+
+        /* Switch to low latency mode if below 2 default periods,
+         * which is 20 ms by default, this will increase the amount
+         * of interrupts but allows very low latency. In dsound I
+         * managed to get a total latency of ~8ms, which is well below
+         * default
+         */
+        if (duration < 2 * def)
+            period = min;
+        else
+            period = def;
+        if (duration < 2 * period)
+            duration = 2 * period;
+
+        /* Uh oh, really low latency requested.. */
+        if (duration <= 2 * period)
+            period /= 2;
+    }
+    period_bytes = pa_frame_size(&This->ss) * MulDiv(period, This->ss.rate, 10000000);
+
+    if (duration < 20000000)
+        This->bufsize_frames = ceil((duration / 10000000.) * fmt->nSamplesPerSec);
+    else
+        This->bufsize_frames = 2 * fmt->nSamplesPerSec;
+    This->bufsize_bytes = This->bufsize_frames * pa_frame_size(&This->ss);
+
+    This->share = mode;
+    This->flags = flags;
+    hr = pulse_stream_connect(This, period_bytes);
+    if (SUCCEEDED(hr)) {
+        UINT32 unalign;
+        const pa_buffer_attr *attr = pa_stream_get_buffer_attr(This->stream);
+        /* Update frames according to new size */
+        dump_attr(attr);
+        if (This->dataflow == eRender)
+            This->bufsize_bytes = attr->tlength;
+        else {
+            This->capture_period = period_bytes = attr->fragsize;
+            if ((unalign = This->bufsize_bytes % period_bytes))
+                This->bufsize_bytes += period_bytes - unalign;
+        }
+        This->bufsize_frames = This->bufsize_bytes / pa_frame_size(&This->ss);
+    }
+    if (SUCCEEDED(hr)) {
+        UINT32 i, capture_packets = This->capture_period ? This->bufsize_bytes / This->capture_period : 0;
+        This->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, This->bufsize_bytes + capture_packets * sizeof(ACPacket));
+        if (!This->tmp_buffer)
+            hr = E_OUTOFMEMORY;
+        else {
+            ACPacket *cur_packet = (ACPacket*)((char*)This->tmp_buffer + This->bufsize_bytes);
+            BYTE *data = This->tmp_buffer;
+            memset(This->tmp_buffer, This->ss.format == PA_SAMPLE_U8 ? 0x80 : 0, This->bufsize_bytes);
+            list_init(&This->packet_free_head);
+            list_init(&This->packet_filled_head);
+            for (i = 0; i < capture_packets; ++i, ++cur_packet) {
+                list_add_tail(&This->packet_free_head, &cur_packet->entry);
+                cur_packet->data = data;
+                data += This->capture_period;
+            }
+            assert(!This->capture_period || This->bufsize_bytes == This->capture_period * capture_packets);
+            assert(!capture_packets || data - This->bufsize_bytes == This->tmp_buffer);
+        }
+    }
+    if (SUCCEEDED(hr))
+        hr = get_audio_session(sessionguid, This->parent, fmt->nChannels, &This->session);
+    if (SUCCEEDED(hr))
+        list_add_tail(&This->session->clients, &This->entry);
+
+exit:
+    if (FAILED(hr)) {
+        HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+        This->tmp_buffer = NULL;
+        if (This->stream) {
+            pa_stream_disconnect(This->stream);
+            pa_stream_unref(This->stream);
+            This->stream = NULL;
+        }
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (SUCCEEDED(hr))
+        *out = This->bufsize_frames;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    const pa_buffer_attr *attr;
+    REFERENCE_TIME lat;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if (!latency)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+    attr = pa_stream_get_buffer_attr(This->stream);
+    if (This->dataflow == eRender)
+        lat = attr->minreq / pa_frame_size(&This->ss);
+    else
+        lat = attr->fragsize / pa_frame_size(&This->ss);
+    *latency = 10000000;
+    *latency *= lat;
+    *latency /= This->ss.rate;
+    pthread_mutex_unlock(&pulse_lock);
+    TRACE("Latency: %u ms\n", (DWORD)(*latency / 10000));
+    return S_OK;
+}
+
+static void ACImpl_GetRenderPad(ACImpl *This, UINT32 *out)
+{
+    *out = This->pad / pa_frame_size(&This->ss);
+}
+
+static void ACImpl_GetCapturePad(ACImpl *This, UINT32 *out)
+{
+    ACPacket *packet = This->locked_ptr;
+    if (!packet && !list_empty(&This->packet_filled_head)) {
+        packet = (ACPacket*)list_head(&This->packet_filled_head);
+        This->locked_ptr = packet;
+        list_remove(&packet->entry);
+    }
+    if (out)
+        *out = This->pad / pa_frame_size(&This->ss);
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->dataflow == eRender)
+        ACImpl_GetRenderPad(This, out);
+    else
+        ACImpl_GetCapturePad(This, out);
+    pthread_mutex_unlock(&pulse_lock);
+
+    TRACE("%p Pad: %u ms (%u)\n", This, MulDiv(*out, 1000, This->ss.rate), *out);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *fmt,
+        WAVEFORMATEX **out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    WAVEFORMATEX *closest = NULL;
+    BOOL exclusive;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
+
+    if (!fmt)
+        return E_POINTER;
+
+    if (out)
+        *out = NULL;
+
+    if (mode == AUDCLNT_SHAREMODE_EXCLUSIVE) {
+        exclusive = 1;
+        out = NULL;
+    } else if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        exclusive = 0;
+        if (!out)
+            return E_POINTER;
+    } else
+        return E_INVALIDARG;
+
+    if (fmt->nChannels == 0)
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+
+    closest = clone_format(fmt);
+    if (!closest)
+        return E_OUTOFMEMORY;
+
+    dump_fmt(fmt);
+
+    switch (fmt->wFormatTag) {
+    case WAVE_FORMAT_EXTENSIBLE: {
+        WAVEFORMATEXTENSIBLE *ext = (WAVEFORMATEXTENSIBLE*)closest;
+
+        if ((fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX) &&
+             fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE)) ||
+            fmt->nBlockAlign != fmt->wBitsPerSample / 8 * fmt->nChannels ||
+            ext->Samples.wValidBitsPerSample > fmt->wBitsPerSample ||
+            fmt->nAvgBytesPerSec != fmt->nBlockAlign * fmt->nSamplesPerSec) {
+            hr = E_INVALIDARG;
+            break;
+        }
+
+        if (exclusive) {
+            UINT32 mask = 0, i, channels = 0;
+
+            if (!(ext->dwChannelMask & (SPEAKER_ALL | SPEAKER_RESERVED))) {
+                for (i = 1; !(i & SPEAKER_RESERVED); i <<= 1) {
+                    if (i & ext->dwChannelMask) {
+                        mask |= i;
+                        channels++;
+                    }
+                }
+
+                if (channels != fmt->nChannels || (ext->dwChannelMask & ~mask)) {
+                    hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+                    break;
+                }
+            } else {
+                hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+                break;
+            }
+        }
+
+        if (IsEqualGUID(&ext->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
+            if (fmt->wBitsPerSample != 32) {
+                hr = E_INVALIDARG;
+                break;
+            }
+
+            if (ext->Samples.wValidBitsPerSample != fmt->wBitsPerSample) {
+                hr = S_FALSE;
+                ext->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
+            }
+        } else if (IsEqualGUID(&ext->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
+            if (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8) {
+                hr = E_INVALIDARG;
+                break;
+            }
+
+            if (ext->Samples.wValidBitsPerSample != fmt->wBitsPerSample &&
+                !(fmt->wBitsPerSample == 32 &&
+                  ext->Samples.wValidBitsPerSample == 24)) {
+                hr = S_FALSE;
+                ext->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
+                break;
+            }
+        } else {
+            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            break;
+        }
+
+        break;
+    }
+
+    case WAVE_FORMAT_ALAW:
+    case WAVE_FORMAT_MULAW:
+        if (fmt->wBitsPerSample != 8) {
+            hr = E_INVALIDARG;
+            break;
+        }
+        /* Fall-through */
+    case WAVE_FORMAT_IEEE_FLOAT:
+        if (fmt->wFormatTag == WAVE_FORMAT_IEEE_FLOAT && fmt->wBitsPerSample != 32) {
+            hr = E_INVALIDARG;
+            break;
+        }
+        /* Fall-through */
+    case WAVE_FORMAT_PCM:
+        if (fmt->wFormatTag == WAVE_FORMAT_PCM &&
+            (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8)) {
+            hr = E_INVALIDARG;
+            break;
+        }
+
+        if (fmt->nChannels > 2) {
+            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            break;
+        }
+        /*
+         * fmt->cbSize, fmt->nBlockAlign and fmt->nAvgBytesPerSec seem to be 
+         * ignored, invalid values are happily accepted.
+         */
+        break;
+    default:
+        hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+        break;
+    }
+
+    if (exclusive && hr != S_OK) {
+        hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+        CoTaskMemFree(closest);
+    } else if (hr != S_FALSE)
+        CoTaskMemFree(closest);
+    else
+        *out = closest;
+
+    /* Winepulse does not currently support exclusive mode, if you know of an
+     * application that uses it, I will correct this..
+     */
+    if (hr == S_OK && exclusive)
+        return This->dataflow == eCapture ? AUDCLNT_E_UNSUPPORTED_FORMAT : AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
+
+    TRACE("returning: %08x %p\n", hr, out ? *out : NULL);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    WAVEFORMATEXTENSIBLE *fmt = &pulse_fmt[This->dataflow == eCapture];
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if (!pwfx)
+        return E_POINTER;
+
+    *pwfx = clone_format(&fmt->Format);
+    if (!*pwfx)
+        return E_OUTOFMEMORY;
+    dump_fmt(*pwfx);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if (!defperiod && !minperiod)
+        return E_POINTER;
+
+    if (defperiod)
+        *defperiod = pulse_def_period[This->dataflow == eCapture];
+    if (minperiod)
+        *minperiod = pulse_min_period[This->dataflow == eCapture];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    int success;
+    pa_operation *o;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if ((This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !This->event) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_EVENTHANDLE_NOT_SET;
+    }
+
+    if (This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if (pa_stream_is_corked(This->stream)) {
+        o = pa_stream_cork(This->stream, 0, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        } else
+            success = 0;
+        if (!success)
+            hr = E_FAIL;
+    }
+    if (SUCCEEDED(hr)) {
+        This->started = TRUE;
+        if (This->dataflow == eRender && This->event)
+            pa_stream_set_latency_update_callback(This->stream, pulse_latency_callback, This);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    pa_operation *o;
+    int success;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (!This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return S_FALSE;
+    }
+
+    if (This->dataflow == eRender) {
+        o = pa_stream_cork(This->stream, 1, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        } else
+            success = 0;
+        if (!success)
+            hr = E_FAIL;
+    }
+    if (SUCCEEDED(hr)) {
+        This->started = FALSE;
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if (This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_BUFFER_OPERATION_PENDING;
+    }
+
+    if (This->dataflow == eRender) {
+        /* If there is still data in the render buffer it needs to be removed from the server */
+        int success = 0;
+        if (This->pad) {
+            pa_operation *o = pa_stream_flush(This->stream, pulse_op_cb, &success);
+            if (o) {
+                while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                    pthread_cond_wait(&pulse_cond, &pulse_lock);
+                pa_operation_unref(o);
+            }
+        }
+        if (success || !This->pad)
+            This->clock_lastpos = This->clock_written = This->pad = 0;
+    } else {
+        ACPacket *p;
+        This->clock_written += This->pad;
+        This->pad = 0;
+
+        if ((p = This->locked_ptr)) {
+            This->locked_ptr = NULL;
+            list_add_tail(&This->packet_free_head, &p->entry);
+        }
+        list_move_tail(&This->packet_free_head, &This->packet_filled_head);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if (!event)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (!(This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK))
+        hr = AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
+    else if (This->event)
+        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
+    else
+        This->event = event;
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+
+    if (IsEqualIID(riid, &IID_IAudioRenderClient)) {
+        if (This->dataflow != eRender)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioRenderClient_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioCaptureClient)) {
+        if (This->dataflow != eCapture)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioCaptureClient_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioClock)) {
+        *ppv = &This->IAudioClock_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioStreamVolume)) {
+        *ppv = &This->IAudioStreamVolume_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioSessionControl) ||
+               IsEqualIID(riid, &IID_IChannelAudioVolume) ||
+               IsEqualIID(riid, &IID_ISimpleAudioVolume)) {
+        if (!This->session_wrapper) {
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if (!This->session_wrapper)
+                return E_OUTOFMEMORY;
+        }
+        if (IsEqualIID(riid, &IID_IAudioSessionControl))
+            *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+        else if (IsEqualIID(riid, &IID_IChannelAudioVolume))
+            *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+        else if (IsEqualIID(riid, &IID_ISimpleAudioVolume))
+            *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static const IAudioClientVtbl AudioClient_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    size_t avail, req, bytes = frames * pa_frame_size(&This->ss);
+    UINT32 pad;
+    HRESULT hr = S_OK;
+    int ret = -1;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if (!data)
+        return E_POINTER;
+    *data = NULL;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr) || This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+    if (!frames) {
+        pthread_mutex_unlock(&pulse_lock);
+        return S_OK;
+    }
+
+    ACImpl_GetRenderPad(This, &pad);
+    avail = This->bufsize_frames - pad;
+    if (avail < frames || bytes > This->bufsize_bytes) {
+        pthread_mutex_unlock(&pulse_lock);
+        WARN("Wanted to write %u, but only %zu available\n", frames, avail);
+        return AUDCLNT_E_BUFFER_TOO_LARGE;
+    }
+
+    This->locked = frames;
+    req = bytes;
+    ret = pa_stream_begin_write(This->stream, &This->locked_ptr, &req);
+    if (ret < 0 || req < bytes) {
+        FIXME("%p Not using pulse locked data: %i %zu/%u %u/%u\n", This, ret, req/pa_frame_size(&This->ss), frames, pad, This->bufsize_frames);
+        if (ret >= 0)
+            pa_stream_cancel_write(This->stream);
+        *data = This->tmp_buffer;
+        This->locked_ptr = NULL;
+    } else
+        *data = This->locked_ptr;
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static void pulse_free_noop(void *buf)
+{
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    UINT32 written_bytes = written_frames * pa_frame_size(&This->ss);
+//    UINT32 period;
+
+    TRACE("(%p)->(%u, %x)\n", This, written_frames, flags);
+
+    pthread_mutex_lock(&pulse_lock);
+    if (!This->locked || !written_frames) {
+        if (This->locked_ptr)
+            pa_stream_cancel_write(This->stream);
+        This->locked = 0;
+        This->locked_ptr = NULL;
+        pthread_mutex_unlock(&pulse_lock);
+        return written_frames ? AUDCLNT_E_OUT_OF_ORDER : S_OK;
+    }
+
+    if (This->locked < written_frames) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+
+    if (flags & AUDCLNT_BUFFERFLAGS_SILENT) {
+        if (This->ss.format == PA_SAMPLE_U8)
+            memset(This->tmp_buffer, 128, written_bytes);
+        else
+            memset(This->tmp_buffer, 0, written_bytes);
+    }
+
+    This->locked = 0;
+    if (This->locked_ptr)
+        pa_stream_write(This->stream, This->locked_ptr, written_bytes, NULL, 0, PA_SEEK_RELATIVE);
+    else
+        pa_stream_write(This->stream, This->tmp_buffer, written_bytes, pulse_free_noop, 0, PA_SEEK_RELATIVE);
+    This->pad += written_bytes;
+    This->locked_ptr = NULL;
+    TRACE("Released %u, pad %zu\n", written_frames, This->pad / pa_frame_size(&This->ss));
+    assert(This->pad <= This->bufsize_bytes);
+
+//    period = pa_stream_get_buffer_attr(This->stream)->minreq;
+    /* Require a minimum of 3 periods filled, if possible */
+//    if (This->event && This->pad + period <= This->bufsize_bytes && This->pad < period * 3)
+//        SetEvent(This->event);
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    HRESULT hr;
+    ACPacket *packet;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if (!data || !frames || !flags)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr) || This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    ACImpl_GetCapturePad(This, NULL);
+    if ((packet = This->locked_ptr)) {
+        *frames = This->capture_period / pa_frame_size(&This->ss);
+        *flags = 0;
+        if (packet->discont)
+            *flags |= AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY;
+        if (devpos) {
+            if (packet->discont)
+                *devpos = (This->clock_written + This->capture_period) / pa_frame_size(&This->ss);
+            else
+                *devpos = This->clock_written / pa_frame_size(&This->ss);
+        }
+        if (qpcpos)
+            *qpcpos = packet->qpcpos;
+        *data = packet->data;
+    }
+    else
+        *frames = 0;
+    This->locked = *frames;
+    pthread_mutex_unlock(&pulse_lock);
+    return *frames ? S_OK : AUDCLNT_S_BUFFER_EMPTY;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    pthread_mutex_lock(&pulse_lock);
+    if (!This->locked && done) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_OUT_OF_ORDER;
+    }
+    if (done && This->locked != done) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+    if (done) {
+        ACPacket *packet = This->locked_ptr;
+        This->locked_ptr = NULL;
+        This->pad -= This->capture_period;
+        if (packet->discont)
+            This->clock_written += 2 * This->capture_period;
+        else
+            This->clock_written += This->capture_period;
+        list_add_tail(&This->packet_free_head, &packet->entry);
+    }
+    This->locked = 0;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    ACPacket *p;
+
+    TRACE("(%p)->(%p)\n", This, frames);
+    if (!frames)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    ACImpl_GetCapturePad(This, NULL);
+    p = This->locked_ptr;
+    if (p)
+        *frames = This->capture_period / pa_frame_size(&This->ss);
+    else
+        *frames = 0;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if (IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (SUCCEEDED(hr))
+        *freq = This->ss.rate * pa_frame_size(&This->ss);
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if (!pos)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    *pos = This->clock_written;
+
+    /* Make time never go backwards */
+    if (*pos < This->clock_lastpos)
+        *pos = This->clock_lastpos;
+    else
+        This->clock_lastpos = *pos;
+    pthread_mutex_unlock(&pulse_lock);
+
+    TRACE("%p Position: %u\n", This, (unsigned)*pos);
+
+    if (qpctime) {
+        LARGE_INTEGER stamp, freq;
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        *qpctime = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if (!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    HRESULT hr = AudioClock_GetPosition(&This->IAudioClock_iface, pos, qpctime);
+    if (SUCCEEDED(hr))
+        *pos /= pa_frame_size(&This->ss);
+    return hr;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    *out = This->ss.channels;
+
+    return S_OK;
+}
+
+struct pulse_info_cb_data {
+    UINT32 n;
+    float *levels;
+};
+
+static void pulse_sink_input_info_cb(pa_context *c, const pa_sink_input_info *info, int eol, void *data)
+{
+    struct pulse_info_cb_data *d = data;
+    int i;
+    if (eol)
+        return;
+    for (i = 0; i < d->n; ++i)
+        d->levels[i] = (float)info->volume.values[i] / (float)PA_VOLUME_NORM;
+    pthread_cond_signal(&pulse_cond);
+}
+
+static void pulse_source_info_cb(pa_context *c, const pa_source_info *info, int eol, void *data)
+{
+    struct pulse_info_cb_data *d = data;
+    int i;
+    if (eol)
+        return;
+    for (i = 0; i < d->n; ++i)
+        d->levels[i] = (float)info->volume.values[i] / (float)PA_VOLUME_NORM;
+    pthread_cond_signal(&pulse_cond);
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    pa_operation *o;
+    HRESULT hr;
+    int success = 0, i;
+    pa_cvolume cv;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if (!levels)
+        return E_POINTER;
+
+    if (count != This->ss.channels)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr))
+        goto out;
+
+    if (pulse_stream_volume) {
+        cv.channels = count;
+        for (i = 0; i < cv.channels; ++i)
+            cv.values[i] = levels[i] * (float)PA_VOLUME_NORM;
+        if (This->dataflow == eRender)
+            o = pa_context_set_sink_input_volume(pulse_ctx, pa_stream_get_index(This->stream), &cv, pulse_ctx_op_cb, &success);
+        else
+            o = pa_context_set_source_volume_by_index(pulse_ctx, pa_stream_get_device_index(This->stream), &cv, pulse_ctx_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        }
+        if (!success)
+            hr = AUDCLNT_E_BUFFER_ERROR;
+    } else {
+        int i;
+        for (i = 0; i < count; ++i)
+            This->vol[i] = levels[i];
+    }
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    pa_operation *o;
+    HRESULT hr;
+    struct pulse_info_cb_data info;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if (!levels)
+        return E_POINTER;
+
+    if (count != This->ss.channels)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr))
+        goto out;
+
+    if (pulse_stream_volume) {
+        info.n = count;
+        info.levels = levels;
+        if (This->dataflow == eRender)
+            o = pa_context_get_sink_input_info(pulse_ctx, pa_stream_get_index(This->stream), pulse_sink_input_info_cb, &info);
+        else
+            o = pa_context_get_source_info_by_index(pulse_ctx, pa_stream_get_device_index(This->stream), pulse_source_info_cb, &info);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        } else
+            hr = AUDCLNT_E_BUFFER_ERROR;
+    } else {
+        int i;
+        for (i = 0; i < count; ++i)
+            levels[i] = This->vol[i];
+    }
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    HRESULT hr;
+    float volumes[PA_CHANNELS_MAX];
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (index >= This->ss.channels)
+        return E_INVALIDARG;
+
+    hr = AudioStreamVolume_GetAllVolumes(iface, This->ss.channels, volumes);
+    volumes[index] = level;
+    if (SUCCEEDED(hr))
+        hr = AudioStreamVolume_SetAllVolumes(iface, This->ss.channels, volumes);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    float volumes[PA_CHANNELS_MAX];
+    HRESULT hr;
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if (!level)
+        return E_POINTER;
+
+    if (index >= This->ss.channels)
+        return E_INVALIDARG;
+
+    hr = AudioStreamVolume_GetAllVolumes(iface, This->ss.channels, volumes);
+    if (SUCCEEDED(hr))
+        *level = volumes[index];
+    return hr;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if (!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = !client;
+
+    ret->client = client;
+    if (client) {
+        ret->session = client->session;
+        AudioClient_AddRef(&client->IAudioClient_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioSessionControl) ||
+        IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref) {
+        if (This->client) {
+            This->client->session_wrapper = NULL;
+            AudioClient_Release(&This->client->IAudioClient_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if (!state)
+        return NULL_PTR_ERR;
+
+    pthread_mutex_lock(&pulse_lock);
+    if (list_empty(&This->session->clients)) {
+        *state = AudioSessionStateExpired;
+        goto out;
+    }
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry) {
+        if (client->started) {
+            *state = AudioSessionStateActive;
+            goto out;
+        }
+    }
+    *state = AudioSessionStateInactive;
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if (!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioSessionManager) ||
+        IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if (FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if (!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if (FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if (!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("Pulseaudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    session->master_vol = level;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if (!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%u, %p)\n", session, mute, context);
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    session->mute = mute;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if (!mute)
+        return NULL_PTR_ERR;
+
+    *mute = session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if (!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("Pulseaudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    session->channel_vols[index] = level;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if (!level)
+        return NULL_PTR_ERR;
+
+    if (index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if (!levels)
+        return NULL_PTR_ERR;
+
+    if (count != session->channel_count)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("Pulseaudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if (!levels)
+        return NULL_PTR_ERR;
+
+    if (count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    *out = NULL;
+    if (!This)
+        return E_OUTOFMEMORY;
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+    *out = &This->IAudioSessionManager2_iface;
+    return S_OK;
+}
diff -urN wine-1.5.30/dlls/winepulse.drv/winepulse.drv.spec wine-multimedia/dlls/winepulse.drv/winepulse.drv.spec
--- wine-1.5.30/dlls/winepulse.drv/winepulse.drv.spec	1970-01-01 03:00:00.000000000 +0300
+++ wine-multimedia/dlls/winepulse.drv/winepulse.drv.spec	2013-05-17 10:44:21.566222774 +0300
@@ -0,0 +1,5 @@
+# MMDevAPI driver functions
+@ stdcall -private GetPriority() AUDDRV_GetPriority
+@ stdcall -private GetEndpointIDs(long ptr ptr ptr ptr) AUDDRV_GetEndpointIDs
+@ stdcall -private GetAudioEndpoint(ptr ptr ptr) AUDDRV_GetAudioEndpoint
+@ stdcall -private GetAudioSessionManager(ptr ptr) AUDDRV_GetAudioSessionManager
diff -urN wine-1.5.30/dlls/winex11.drv/xrandr.c wine-multimedia/dlls/winex11.drv/xrandr.c
--- wine-1.5.30/dlls/winex11.drv/xrandr.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/winex11.drv/xrandr.c	2013-05-17 10:44:21.581222587 +0300
@@ -68,6 +68,7 @@
 static struct x11drv_mode_info *dd_modes;
 static SizeID *xrandr10_modes;
 static unsigned int xrandr_mode_count;
+static int xrandr_current_mode = -1;
 
 static int load_xrandr(void)
 {
@@ -125,6 +126,9 @@
     unsigned int i;
     int res = -1;
 
+    if (xrandr_current_mode != -1)
+        return xrandr_current_mode;
+
     sc = pXRRGetScreenInfo (gdi_display, DefaultRootWindow( gdi_display ));
     size = pXRRConfigCurrentConfiguration (sc, &rot);
     rate = pXRRConfigCurrentRate (sc);
@@ -141,8 +145,10 @@
     if (res == -1)
     {
         ERR("In unknown mode, returning default\n");
-        res = 0;
+        return 0;
     }
+
+    xrandr_current_mode = res;
     return res;
 }
 
@@ -177,6 +183,7 @@
 
     if (stat == RRSetConfigSuccess)
     {
+        xrandr_current_mode = mode;
         X11DRV_resize_desktop( dd_modes[mode].width, dd_modes[mode].height );
         return DISP_CHANGE_SUCCESSFUL;
     }
@@ -271,6 +278,9 @@
     XRRCrtcInfo *crtc_info;
     int i, ret = -1;
 
+    if (xrandr_current_mode != -1)
+        return xrandr_current_mode;
+
     if (!(resources = pXRRGetScreenResourcesCurrent( gdi_display, root_window )))
     {
         ERR("Failed to get screen resources.\n");
@@ -303,9 +313,10 @@
     if (ret == -1)
     {
         ERR("Unknown mode, returning default.\n");
-        ret = 0;
+        return 0;
     }
 
+    xrandr_current_mode = ret;
     return ret;
 }
 
@@ -347,6 +358,7 @@
         return DISP_CHANGE_FAILED;
     }
 
+    xrandr_current_mode = mode;
     X11DRV_resize_desktop( dd_modes[mode].width, dd_modes[mode].height );
     return DISP_CHANGE_SUCCESSFUL;
 }
diff -urN wine-1.5.30/dlls/winhttp/request.c wine-multimedia/dlls/winhttp/request.c
--- wine-1.5.30/dlls/winhttp/request.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/winhttp/request.c	2013-05-17 10:44:21.586222524 +0300
@@ -1582,6 +1582,8 @@
         {
             ERR("authentication scheme changed from %s to %s\n",
                 debugstr_w(auth_schemes[authinfo->scheme].str), debugstr_w(auth_value));
+            destroy_authinfo( authinfo );
+            *auth_ptr = NULL;
             return FALSE;
         }
         in.BufferType = SECBUFFER_TOKEN;
diff -urN wine-1.5.30/dlls/wininet/internet.c wine-multimedia/dlls/wininet/internet.c
--- wine-1.5.30/dlls/wininet/internet.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wininet/internet.c	2013-05-17 10:44:21.594222424 +0300
@@ -313,6 +313,7 @@
             break;
 
         case DLL_PROCESS_DETACH:
+            if (lpvReserved) break;
             collect_connections(COLLECT_CLEANUP);
             NETCON_unload();
             free_urlcache();
diff -urN wine-1.5.30/dlls/winmm/lolvldrv.c wine-multimedia/dlls/winmm/lolvldrv.c
--- wine-1.5.30/dlls/winmm/lolvldrv.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/winmm/lolvldrv.c	2013-05-17 10:44:21.602222324 +0300
@@ -543,7 +543,10 @@
     drvA = HeapAlloc(GetProcessHeap(), 0, size);
     WideCharToMultiByte(CP_ACP, 0, pv.u.pwszVal, -1, drvA, size, NULL, NULL);
 
-    MMDRV_Install(drvA, drvA, FALSE);
+    if (!strcasecmp(drvA, "winepulse.drv"))
+        MMDRV_Install("winealsa.drv", "winealsa.drv", 0);
+    else
+        MMDRV_Install(drvA, drvA, FALSE);
 
     HeapFree(GetProcessHeap(), 0, drvA);
     PropVariantClear(&pv);
diff -urN wine-1.5.30/dlls/wintab32/wintab32.c wine-multimedia/dlls/wintab32/wintab32.c
--- wine-1.5.30/dlls/wintab32/wintab32.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wintab32/wintab32.c	2013-05-17 10:44:21.618222124 +0300
@@ -99,12 +99,9 @@
                 return FALSE;
             break;
         case DLL_PROCESS_DETACH:
+            if (lpReserved) break;
             TRACE("Detaching\n");
-            if (hwndDefault)
-            {
-                DestroyWindow(hwndDefault);
-                hwndDefault = 0;
-            }
+            if (hwndDefault) DestroyWindow(hwndDefault);
             TABLET_Unregister();
             DeleteCriticalSection(&csTablet);
             break;
diff -urN wine-1.5.30/dlls/wmiutils/path.c wine-multimedia/dlls/wmiutils/path.c
--- wine-1.5.30/dlls/wmiutils/path.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wmiutils/path.c	2013-05-17 10:44:21.626222024 +0300
@@ -420,6 +420,11 @@
         path->flags |= WBEMPATH_INFO_PATH_HAD_SERVER;
     }
     p = q;
+    if (*q && *q != '\\' && *q != '/' && *q != ':')
+    {
+        path->num_namespaces = 1;
+        q++;
+    }
     while (*q && *q != ':')
     {
         if (*q == '\\' || *q == '/') path->num_namespaces++;
@@ -432,6 +437,18 @@
 
         i = 0;
         q = p;
+        if (*q && *q != '\\' && *q != '/' && *q != ':')
+        {
+            p = q;
+            while (*p && *p != '\\' && *p != '/' && *p != ':') p++;
+            len = p - q;
+            if (!(path->namespaces[i] = heap_alloc( (len + 1) * sizeof(WCHAR) ))) goto done;
+            memcpy( path->namespaces[i], q, len * sizeof(WCHAR) );
+            path->namespaces[i][len] = 0;
+            path->len_namespaces[i] = len;
+            q = p;
+            i++;
+        }
         while (*q && *q != ':')
         {
             if (*q == '\\' || *q == '/')
diff -urN wine-1.5.30/dlls/wmiutils/tests/path.c wine-multimedia/dlls/wmiutils/tests/path.c
--- wine-1.5.30/dlls/wmiutils/tests/path.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wmiutils/tests/path.c	2013-05-17 10:44:21.627222012 +0300
@@ -122,7 +122,8 @@
         { path8, WBEMPATH_TREAT_SINGLE_IDENT_AS_NS + 1, S_OK },
         { path9, WBEMPATH_CREATE_ACCEPT_ABSOLUTE, S_OK },
         { path10, WBEMPATH_CREATE_ACCEPT_ABSOLUTE, WBEM_E_INVALID_PARAMETER, 1 },
-        { path11, WBEMPATH_CREATE_ACCEPT_ABSOLUTE, S_OK }
+        { path11, WBEMPATH_CREATE_ACCEPT_ABSOLUTE, S_OK },
+        { path15, WBEMPATH_CREATE_ACCEPT_ALL, S_OK }
     };
     IWbemPath *path;
     HRESULT hr;
@@ -167,6 +168,8 @@
     static const WCHAR expected2W[] =
         {'W','i','n','3','2','_','L','o','g','i','c','a','l','D','i','s','k','.',
          'D','e','v','i','c','e','I','d','=','"','C',':','"',0};
+    static const WCHAR expected3W[] =
+        {'\\','\\','.','\\','r','o','o','t','\\','c','i','m','v','2',0};
     WCHAR buf[128];
     ULONG len, count;
     IWbemPath *path;
@@ -306,6 +309,16 @@
     ok( !lstrcmpW( buf, expected2W ), "unexpected buffer contents %s\n", wine_dbgstr_w(buf) );
     ok( len == lstrlenW( expected2W ) + 1, "unexpected length %u\n", len );
 
+    hr = IWbemPath_SetText( path, WBEMPATH_CREATE_ACCEPT_ALL, path15 );
+    ok( hr == S_OK, "got %08x\n", hr );
+
+    len = sizeof(buf)/sizeof(buf[0]);
+    memset( buf, 0x55, sizeof(buf) );
+    hr = IWbemPath_GetText( path, WBEMPATH_GET_SERVER_TOO, &len, buf );
+    ok( hr == S_OK, "got %08x\n", hr );
+    ok( !lstrcmpW( buf, expected3W ), "unexpected buffer contents %s\n", wine_dbgstr_w(buf) );
+    ok( len == lstrlenW( expected3W ) + 1, "unexpected length %u\n", len );
+
     hr = IWbemPath_SetText( path, WBEMPATH_CREATE_ACCEPT_ALL, path18 );
     ok( hr == S_OK, "got %08x\n", hr );
 
diff -urN wine-1.5.30/dlls/ws2_32/socket.c wine-multimedia/dlls/ws2_32/socket.c
--- wine-1.5.30/dlls/ws2_32/socket.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/ws2_32/socket.c	2013-05-17 10:44:21.632221949 +0300
@@ -897,9 +897,9 @@
     case DLL_PROCESS_ATTACH:
         break;
     case DLL_PROCESS_DETACH:
+        if (fImpLoad) break;
         free_per_thread_data();
         DeleteCriticalSection(&csWSgetXXXbyYYY);
-        num_startup = 0;
         break;
     case DLL_THREAD_DETACH:
         free_per_thread_data();
diff -urN wine-1.5.30/dlls/wshom.ocx/wshom_main.c wine-multimedia/dlls/wshom.ocx/wshom_main.c
--- wine-1.5.30/dlls/wshom.ocx/wshom_main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/dlls/wshom.ocx/wshom_main.c	2013-05-17 10:44:21.635221912 +0300
@@ -161,6 +161,7 @@
         DisableThreadLibraryCalls(wshom_instance);
         break;
     case DLL_PROCESS_DETACH:
+        if (lpv) break;
         release_typelib();
         break;
     }
diff -urN wine-1.5.30/include/wbemcli.idl wine-multimedia/include/wbemcli.idl
--- wine-1.5.30/include/wbemcli.idl	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/include/wbemcli.idl	2013-05-17 10:44:21.832219449 +0300
@@ -290,6 +290,24 @@
         [out] BSTR *MessageText);
 };
 
+[
+    object,
+    restricted,
+    uuid(7c857801-7381-11cf-884d-00aa004b2e24)
+]
+interface IWbemObjectSink : IUnknown
+{
+    HRESULT Indicate(
+        [in] long lObjectCount,
+        [in, size_is(lObjectCount)] IWbemClassObject **apObjArray);
+
+    HRESULT SetStatus(
+        [in] long lFlags,
+        [in] HRESULT hResult,
+        [in] BSTR strParam,
+        [in] IWbemClassObject *pObjParam);
+};
+
 typedef [v1_enum] enum tag_WBEM_GENERIC_FLAG_TYPE
 {
     WBEM_FLAG_RETURN_WBEM_COMPLETE      = 0,
diff -urN wine-1.5.30/libs/wine/loader.c wine-multimedia/libs/wine/loader.c
--- wine-1.5.30/libs/wine/loader.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/libs/wine/loader.c	2013-05-17 10:44:21.906218524 +0300
@@ -59,6 +59,10 @@
 #include "winbase.h"
 #include "wine/library.h"
 
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
 /* argc/argv for the Windows application */
 int __wine_main_argc = 0;
 char **__wine_main_argv = NULL;
@@ -644,7 +648,6 @@
     return ret;
 }
 
-
 /***********************************************************************
  *           set_max_limit
  *
@@ -655,6 +658,11 @@
 #ifdef HAVE_SETRLIMIT
     struct rlimit rlimit;
 
+#if defined(RLIMIT_NOFILE) && defined(RUNNING_ON_VALGRIND)
+    if (limit == RLIMIT_NOFILE && RUNNING_ON_VALGRIND)
+        return;
+#endif
+
     if (!getrlimit( limit, &rlimit ))
     {
         rlimit.rlim_cur = rlimit.rlim_max;
@@ -802,6 +810,34 @@
 
 
 /***********************************************************************
+ *           set_rttime_limit
+ *
+ * set a limit on the cpu time used
+ */
+static void set_rttime_limit(void)
+{
+#if defined(HAVE_SETRLIMIT) && defined(__linux__)
+#ifndef RLIMIT_RTTIME
+#define RLIMIT_RTTIME 15
+#endif
+    struct rlimit rlimit;
+
+    if (!getrlimit( RLIMIT_RTTIME, &rlimit ))
+    {
+        /* 1000 ms maximum realtime before the first SIGXCPU, this will drop
+         * all realtime threads to normal priority.
+         */
+        if (rlimit.rlim_max > 5000000)
+            rlimit.rlim_max = 5000000;
+        rlimit.rlim_cur = 1000000;
+
+        setrlimit( RLIMIT_RTTIME, &rlimit );
+    }
+#endif
+}
+
+
+/***********************************************************************
  *           wine_init
  *
  * Main Wine initialisation.
@@ -820,6 +856,7 @@
 #ifdef RLIMIT_AS
     set_max_limit( RLIMIT_AS );
 #endif
+    set_rttime_limit();
 
     wine_init_argv0_path( argv[0] );
     build_dll_path();
diff -urN wine-1.5.30/libs/wine/Makefile.in wine-multimedia/libs/wine/Makefile.in
--- wine-1.5.30/libs/wine/Makefile.in	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/libs/wine/Makefile.in	2013-05-17 10:44:21.869218986 +0300
@@ -111,4 +111,8 @@
 $(RELPATH):
 	@cd $(TOOLSDIR)/tools && $(MAKE) relpath$(TOOLSEXT)
 
+# Make sure that make_makefiles sees the install rules
+install install-lib::
+install install-dev::
+
 @LIBWINE_RULES@
diff -urN wine-1.5.30/po/de.po wine-multimedia/po/de.po
--- wine-1.5.30/po/de.po	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/po/de.po	2013-05-17 10:44:21.927218261 +0300
@@ -10502,7 +10502,7 @@
 
 #: netstat.rc:41
 msgid "TCP Statistics for IPv4"
-msgstr "TCP-Statisktik für IPv4"
+msgstr "TCP-Statistik für IPv4"
 
 #: netstat.rc:42
 msgid "Active Opens"
diff -urN wine-1.5.30/programs/explorer/explorer.c wine-multimedia/programs/explorer/explorer.c
--- wine-1.5.30/programs/explorer/explorer.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/programs/explorer/explorer.c	2013-05-17 10:44:22.010217224 +0300
@@ -643,7 +643,7 @@
     }
     else
     {
-        while (*source && !isspaceW(*source)) target[i++] = *source++;
+        while (*source && *source != ',') target[i++] = *source++;
         target[i] = 0;
     }
     return i;
diff -urN wine-1.5.30/programs/winemenubuilder/winemenubuilder.c wine-multimedia/programs/winemenubuilder/winemenubuilder.c
--- wine-1.5.30/programs/winemenubuilder/winemenubuilder.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/programs/winemenubuilder/winemenubuilder.c	2013-05-17 10:44:22.070216474 +0300
@@ -2536,7 +2536,7 @@
         fclose(desktop);
     }
     else
-        WINE_ERR("error writing association file %s\n", wine_dbgstr_a(desktopPath));
+        WINE_WARN("error writing association file %s\n", wine_dbgstr_a(desktopPath));
     return ret;
 }
 
diff -urN wine-1.5.30/server/main.c wine-multimedia/server/main.c
--- wine-1.5.30/server/main.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/server/main.c	2013-05-17 10:44:22.093216186 +0300
@@ -28,6 +28,7 @@
 #include <stdlib.h>
 #include <sys/time.h>
 #include <unistd.h>
+#include <sys/syscall.h>
 #ifdef HAVE_GETOPT_H
 # include <getopt.h>
 #endif
@@ -38,6 +39,8 @@
 #include "request.h"
 #include "wine/library.h"
 
+extern int rtkit_make_realtime(struct thread *thread, pid_t tid, int priority);
+
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
@@ -145,6 +148,7 @@
     init_signals();
     init_directories();
     init_registry();
+    rtkit_make_realtime(NULL, syscall( SYS_gettid ), 3);
     main_loop();
     return 0;
 }
diff -urN wine-1.5.30/server/Makefile.in wine-multimedia/server/Makefile.in
--- wine-1.5.30/server/Makefile.in	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/server/Makefile.in	2013-05-17 10:44:22.088216249 +0300
@@ -1,5 +1,6 @@
 DEFS      = -D__WINESRC__
 EXTRALIBS = @LIBPOLL@ @LIBRT@
+EXTRAINCL = @DBUS_CFLAGS@
 
 C_SRCS = \
 	async.c \
@@ -31,6 +32,7 @@
 	region.c \
 	registry.c \
 	request.c \
+	rtkit.c \
 	semaphore.c \
 	serial.c \
 	signal.c \
diff -urN wine-1.5.30/server/rtkit.c wine-multimedia/server/rtkit.c
--- wine-1.5.30/server/rtkit.c	1970-01-01 03:00:00.000000000 +0300
+++ wine-multimedia/server/rtkit.c	2013-05-17 10:44:22.099216111 +0300
@@ -0,0 +1,292 @@
+/*
+ * Rtkit dbus calls
+ * Copyright 2010 Maarten Lankhorst for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+#include "wine/library.h"
+
+#include <errno.h>
+#include <sys/types.h>
+#ifdef HAVE_SYS_SCHED_H
+#include <sys/sched.h>
+#endif
+#include <sys/resource.h>
+
+#if defined(HAVE_SETRLIMIT) && defined(__linux__) && defined(SONAME_LIBDBUS_1) && defined(HAVE_SCHED_H)
+
+#include <sched.h>
+#include <string.h>
+#include <unistd.h>
+#include <dbus/dbus.h>
+#include <stdio.h>
+#include <signal.h>
+#include <limits.h>
+#include <syscall.h>
+#include "object.h"
+#include "thread.h"
+
+#ifndef RLIMIT_RTTIME
+#define RLIMIT_RTTIME 15
+#endif
+
+#define FUNCPTR(fn) static typeof(fn) *p ##fn
+
+FUNCPTR(dbus_error_init);
+FUNCPTR(dbus_error_free);
+FUNCPTR(dbus_bus_get);
+FUNCPTR(dbus_message_new_method_call);
+FUNCPTR(dbus_message_append_args);
+FUNCPTR(dbus_connection_send_with_reply_and_block);
+FUNCPTR(dbus_message_unref);
+FUNCPTR(dbus_set_error_from_message);
+#undef FUNCPTR
+
+static struct list rt_thread_list = LIST_INIT(rt_thread_list);
+
+static int translate_error( unsigned tid, const char *name )
+{
+    if (!strcmp( name, DBUS_ERROR_NO_MEMORY ))
+        return -ENOMEM;
+    if (!strcmp( name, DBUS_ERROR_SERVICE_UNKNOWN ) ||
+        !strcmp( name, DBUS_ERROR_NAME_HAS_NO_OWNER ))
+        return -ENOENT;
+    if (!strcmp( name, DBUS_ERROR_ACCESS_DENIED ) ||
+        !strcmp( name, DBUS_ERROR_AUTH_FAILED ))
+        return -EACCES;
+
+    if (debug_level)
+        fprintf( stderr, "%04x: Could not map error \"%s\"\n", tid, name );
+    return -EIO;
+}
+
+static void init_dbus(void)
+{
+#define FUNCPTR(fn) p ##fn = wine_dlsym( libdbus, #fn, NULL, 0 );
+    char error[512];
+    void *libdbus = wine_dlopen( SONAME_LIBDBUS_1, RTLD_NOW, error, sizeof( error ) );
+    FUNCPTR(dbus_error_init);
+    FUNCPTR(dbus_error_free);
+    FUNCPTR(dbus_bus_get);
+    FUNCPTR(dbus_message_new_method_call);
+    FUNCPTR(dbus_message_append_args);
+    FUNCPTR(dbus_connection_send_with_reply_and_block);
+    FUNCPTR(dbus_message_unref);
+    FUNCPTR(dbus_set_error_from_message);
+#undef FUNCPTR
+}
+
+#define MSG_SIGXCPU "wineserver: SIGXCPU called on wineserver from kernel, realtime priority removed!\n"
+
+static int sched_normal(struct thread *cur)
+{
+    int ret = 0;
+
+    if (cur->unix_tid != -1) {
+        struct sched_param parm;
+        memset( &parm, 0, sizeof( parm ) );
+        ret = sched_setscheduler(cur->unix_tid, SCHED_OTHER | SCHED_RESET_ON_FORK, &parm);
+        if (ret < 0)
+            ret = -errno;
+    }
+
+    list_remove(&cur->rt_entry);
+    list_init(&cur->rt_entry);
+    cur->rt_prio = 0;
+    cur->priority = 0;
+    return ret;
+}
+
+static void sigxcpu_handler(int sig, siginfo_t *si, void *ucontext)
+{
+    struct thread *cur, *tmp;
+    int found = 0;
+    int old_errno = errno;
+
+    if (si->si_code & SI_KERNEL) {
+        struct sched_param parm;
+        memset( &parm, 0, sizeof( parm ) );
+
+        sched_setscheduler(syscall( SYS_gettid ), SCHED_OTHER | SCHED_RESET_ON_FORK, &parm);
+
+        write(2, MSG_SIGXCPU, sizeof(MSG_SIGXCPU)-1);
+        goto restore_errno;
+    }
+
+    LIST_FOR_EACH_ENTRY_SAFE(cur, tmp, &rt_thread_list, struct thread, rt_entry)
+    {
+        if (si->si_pid == cur->unix_pid && cur->rt_prio == 1) {
+            found = 1;
+            sched_normal(cur);
+        }
+    }
+
+    if (!found) {
+        LIST_FOR_EACH_ENTRY_SAFE(cur, tmp, &rt_thread_list, struct thread, rt_entry)
+        {
+            if (si->si_pid == cur->unix_pid)
+                sched_normal(cur);
+        }
+    }
+
+restore_errno:
+    errno = old_errno;
+}
+
+static void setup_rt(void)
+{
+    struct sigaction sa;
+    struct rlimit rlimit;
+
+    sa.sa_sigaction = sigxcpu_handler;
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = SA_SIGINFO;
+    sigaction(SIGXCPU, &sa, NULL);
+
+    if (!getrlimit( RLIMIT_RTTIME, &rlimit ))
+    {
+        /* wineserver can run for 1.5 seconds continuously at realtime before
+         * it gets throttled down. At this point we probably hit a bug
+         * somewhere.
+         */
+        if (rlimit.rlim_max > 2000000)
+            rlimit.rlim_max = 2000000;
+        if (rlimit.rlim_cur > 1500000)
+            rlimit.rlim_cur = 1500000;
+
+        setrlimit( RLIMIT_RTTIME, &rlimit );
+    }
+}
+
+static DBusConnection *get_dbus(void)
+{
+    static DBusConnection *bus;
+    DBusError error;
+
+    if (bus)
+        return bus;
+    init_dbus();
+    pdbus_error_init( &error );
+
+    bus = pdbus_bus_get( DBUS_BUS_SYSTEM, &error );
+    setup_rt();
+    return bus;
+}
+
+int rtkit_make_realtime( struct thread *thread, pid_t unix_tid, int priority )
+{
+    DBusConnection *bus;
+    DBusMessage *m = NULL, *r = NULL;
+    dbus_uint64_t pid = thread ? thread->unix_pid : getpid();
+    dbus_uint64_t tid = unix_tid;
+    dbus_uint32_t rtprio = priority;
+    sigset_t sigset;
+    DBusError error;
+    int ret;
+
+    bus = get_dbus();
+    if (!bus)
+        return -ENOTSUP;
+
+    pdbus_error_init( &error );
+    m = pdbus_message_new_method_call( "org.freedesktop.RealtimeKit1",
+                                       "/org/freedesktop/RealtimeKit1",
+                                       "org.freedesktop.RealtimeKit1",
+                                       "MakeThreadRealtimeWithPID" );
+    if (!m)
+    {
+        ret = -ENOMEM;
+        goto out;
+    }
+
+    ret = pdbus_message_append_args( m, DBUS_TYPE_UINT64, &pid,
+                                     DBUS_TYPE_UINT64, &tid,
+                                     DBUS_TYPE_UINT32, &rtprio,
+                                     DBUS_TYPE_INVALID );
+    if (!ret)
+    {
+        ret = -ENOMEM;
+        goto out;
+    }
+
+    sigemptyset( &sigset );
+    sigaddset( &sigset, SIGXCPU );
+    sigprocmask( SIG_BLOCK, &sigset, NULL );
+
+    r = pdbus_connection_send_with_reply_and_block( bus, m, -1, &error );
+    if (!r)
+    {
+        ret = translate_error( tid, error.name );
+        goto out_unblock;
+    }
+    if (pdbus_set_error_from_message( &error, r ))
+        ret = translate_error( tid, error.name );
+    else {
+        ret = 0;
+        if (thread) {
+            if (list_empty(&thread->rt_entry))
+                list_add_tail( &rt_thread_list, &thread->rt_entry );
+            thread->rt_prio = rtprio;
+        }
+    }
+out_unblock:
+    sigprocmask( SIG_UNBLOCK, &sigset, NULL );
+out:
+    if (m)
+        pdbus_message_unref( m );
+    if (r)
+        pdbus_message_unref( r );
+    pdbus_error_free( &error );
+    if (debug_level)
+        fprintf( stderr, "%04x: Setting realtime priority of %u returns %i %m\n", (int)tid, rtprio, ret );
+    return ret;
+}
+
+int rtkit_undo_realtime( struct thread *thread )
+{
+    sigset_t sigset;
+    int ret = 0;
+
+    sigemptyset( &sigset );
+    sigaddset( &sigset, SIGXCPU );
+    sigprocmask( SIG_BLOCK, &sigset, NULL );
+
+    if (!list_empty(&thread->rt_entry))
+        ret = sched_normal(thread);
+
+    if (debug_level)
+        fprintf( stderr, "%04x: Removing realtime priority of %u returns %i %m\n",
+                 (int)thread->unix_tid, thread->rt_prio, ret );
+
+    sigprocmask( SIG_UNBLOCK, &sigset, NULL );
+    return ret < 0 ? -errno : 0;
+}
+
+#else
+
+int rtkit_make_realtime( struct thread *thread, pid_t unix_tid, int priority )
+{
+    return -ENOTSUP;
+}
+
+int rtkit_undo_realtime( struct thread *thread )
+{
+    return -ENOTSUP;
+}
+
+#endif
diff -urN wine-1.5.30/server/thread.c wine-multimedia/server/thread.c
--- wine-1.5.30/server/thread.c	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/server/thread.c	2013-05-17 10:44:22.101216086 +0300
@@ -52,6 +52,8 @@
 #include "user.h"
 #include "security.h"
 
+extern int rtkit_make_realtime(struct thread *thread, pid_t tid, int priority);
+extern int rtkit_undo_realtime(struct thread *thread);
 
 #ifdef __i386__
 static const unsigned int supported_cpus = CPU_FLAG(CPU_x86);
@@ -198,6 +200,8 @@
     list_init( &thread->mutex_list );
     list_init( &thread->system_apc );
     list_init( &thread->user_apc );
+    list_init( &thread->rt_entry );
+    thread->rt_prio = 0;
 
     for (i = 0; i < MAX_INFLIGHT_FDS; i++)
         thread->inflight[i].server = thread->inflight[i].client = -1;
@@ -266,6 +270,9 @@
 {
     int i;
 
+    thread->unix_tid = -1;
+    if (!list_empty(&thread->rt_entry))
+        rtkit_undo_realtime(thread);
     clear_apc_queue( &thread->system_apc );
     clear_apc_queue( &thread->user_apc );
     free( thread->req_data );
@@ -456,6 +463,15 @@
 #define THREAD_PRIORITY_REALTIME_HIGHEST 6
 #define THREAD_PRIORITY_REALTIME_LOWEST -7
 
+static int rtprio(int ntprio)
+{
+    if (ntprio == THREAD_PRIORITY_TIME_CRITICAL - 1)
+        return 1;
+    else if (ntprio == THREAD_PRIORITY_TIME_CRITICAL)
+        return 2;
+    return 0;
+}
+
 /* set all information about a thread */
 static void set_thread_info( struct thread *thread,
                              const struct set_thread_info_request *req )
@@ -471,8 +487,22 @@
         }
         if ((req->priority >= min && req->priority <= max) ||
             req->priority == THREAD_PRIORITY_IDLE ||
+            req->priority == THREAD_PRIORITY_TIME_CRITICAL - 1 ||
             req->priority == THREAD_PRIORITY_TIME_CRITICAL)
-            thread->priority = req->priority;
+        {
+            int newprio = rtprio(req->priority);
+            if (thread->unix_tid == -1)
+                thread->rt_prio = newprio;
+            else if (thread->priority == THREAD_PRIORITY_TIME_CRITICAL && !newprio)
+                rtkit_undo_realtime(thread);
+            else if (thread->rt_prio != newprio)
+                rtkit_make_realtime(thread, thread->unix_tid, newprio);
+
+            if (newprio)
+                thread->priority = THREAD_PRIORITY_TIME_CRITICAL;
+            else
+                thread->priority = req->priority;
+        }
         else
             set_error( STATUS_INVALID_PARAMETER );
     }
@@ -481,7 +511,7 @@
         if ((req->affinity & thread->process->affinity) != req->affinity)
             set_error( STATUS_INVALID_PARAMETER );
         else if (thread->state == TERMINATED)
-            set_error( STATUS_ACCESS_DENIED );
+            set_error( STATUS_THREAD_IS_TERMINATING );
         else if (set_thread_affinity( thread, req->affinity ))
             file_set_error();
     }
@@ -1200,6 +1230,10 @@
     }
     debug_level = max( debug_level, req->debug_level );
 
+    /* Raced with SetThreadPriority */
+    if (current->priority == THREAD_PRIORITY_TIME_CRITICAL)
+        rtkit_make_realtime(current, current->unix_tid, current->rt_prio);
+
     reply->pid     = get_process_id( process );
     reply->tid     = get_thread_id( current );
     reply->version = SERVER_PROTOCOL_VERSION;
diff -urN wine-1.5.30/server/thread.h wine-multimedia/server/thread.h
--- wine-1.5.30/server/thread.h	2013-05-10 21:30:10.000000000 +0300
+++ wine-multimedia/server/thread.h	2013-05-17 10:44:22.101216086 +0300
@@ -87,6 +87,8 @@
     timeout_t              creation_time; /* Thread creation time */
     timeout_t              exit_time;     /* Thread exit time */
     struct token          *token;         /* security token associated with this thread */
+    struct list            rt_entry;      /* entry for member in linked realtime list */
+    int                    rt_prio;       /* current realtime thread priority */
 };
 
 struct thread_snapshot
