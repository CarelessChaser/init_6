diff --git a/dlls/mswsock/mswsock.spec b/dlls/mswsock/mswsock.spec
index 521b3a4..3da67b4 100644
--- a/dlls/mswsock/mswsock.spec
+++ b/dlls/mswsock/mswsock.spec
@@ -1,7 +1,7 @@
-@ stdcall AcceptEx(long long ptr long long long ptr ptr)
+@ stdcall AcceptEx(long long ptr long long long ptr ptr) ws2_32.AcceptEx
 @ stdcall EnumProtocolsA(ptr ptr ptr) ws2_32.WSAEnumProtocolsA
 @ stdcall EnumProtocolsW(ptr ptr ptr) ws2_32.WSAEnumProtocolsW
-@ stdcall GetAcceptExSockaddrs(ptr long long long ptr ptr ptr ptr)
+@ stdcall GetAcceptExSockaddrs(ptr long long long ptr ptr ptr ptr) ws2_32.AcceptEx
 @ stub GetAddressByNameA
 @ stub GetAddressByNameW
 @ stub GetNameByTypeA
diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 24a4a76..c8ac5d2 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -195,6 +195,15 @@ typedef struct ws2_async
     {
         int val;     /* for send operations */
         int *ptr;    /* for recv operations */
+        struct       /* for accept operation */
+        {
+            SOCKET s_accept; /* socket to use as connection socket */
+            PVOID  buf;      /* buffer to write data to */
+            DWORD  data_len;
+            DWORD local_len;
+            DWORD remote_len;
+            int   *recvd;
+        } acpt;
     }                                   addrlen;
     DWORD                               flags;
 } ws2_async;
@@ -1336,6 +1345,158 @@ static int WS2_register_async_shutdown( SOCKET s, int type )
     return 0;
 }

+
+static NTSTATUS WS2_async_accept(void* user, IO_STATUS_BLOCK* iosb, NTSTATUS status)
+{
+    ws2_async* wsa = user;
+    int result = 0;
+    SOCKET as;
+
+    switch (status)
+    {
+    case STATUS_ALERTED:
+        SERVER_START_REQ( accept_socket )
+        {
+            req->lhandle    = wsa->hSocket;
+            req->ahandle    = SOCKET2HANDLE(wsa->addrlen.acpt.s_accept);
+            req->access     = GENERIC_READ|GENERIC_WRITE|SYNCHRONIZE;
+            req->attributes = OBJ_INHERIT;
+            set_error( wine_server_call( req ) );
+            as = HANDLE2SOCKET( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if (as)
+        {
+            if (wsa->addrlen.acpt.buf)
+            {
+                char *buf = wsa->addrlen.acpt.buf;
+                buf += wsa->addrlen.acpt.data_len;
+                if (wsa->addrlen.acpt.local_len>16)
+                {
+                    WS_getpeername(as, buf+sizeof(int), &wsa->addrlen.acpt.local_len);
+                    *(int*)buf = wsa->addrlen.acpt.local_len;
+                }
+                buf += wsa->addrlen.acpt.local_len+sizeof(int);
+                if (wsa->addrlen.acpt.remote_len>16)
+                {
+                    WS_getsockname(as, buf+sizeof(int), &wsa->addrlen.acpt.remote_len);
+                    *(int*)buf = wsa->addrlen.acpt.local_len;
+                }
+            }
+
+            if (wsa->addrlen.acpt.buf && wsa->addrlen.acpt.data_len)
+            {
+                int flags = 0;
+                WSABUF buf;
+                buf.buf = wsa->addrlen.acpt.buf;
+                buf.len = wsa->addrlen.acpt.data_len;
+                status = WSARecvFrom(as, &buf, 1, wsa->addrlen.acpt.recvd, &flags, NULL, NULL, wsa->user_overlapped, NULL);
+            }
+            else
+                status = STATUS_SUCCESS;
+        }
+        else
+        {
+            if (errno == EINTR || errno == EAGAIN)
+            {
+                status = STATUS_PENDING;
+            }
+            else
+            {
+                /* We set the status to a winsock error code and check for that
+                   later in NtStatusToWSAError () */
+                status = wsaErrno();
+                result = 0;
+            }
+        }
+        _enable_event( wsa->hSocket, FD_READ, 0, 0 );
+        break;
+    }
+    if (status != STATUS_PENDING)
+    {
+        iosb->u.Status = status;
+        iosb->Information = result;
+    }
+    return status;
+}
+
+BOOL WINAPI AcceptEx(SOCKET s, SOCKET s_accept, PVOID buf, DWORD data_len, DWORD local_addr_len, DWORD remote_addr_len, LPDWORD recvd, LPOVERLAPPED lpOverlapped)
+{
+    IO_STATUS_BLOCK *iosb;
+    struct ws2_async *wsa = HeapAlloc( GetProcessHeap(), 0, sizeof(*wsa) );
+    int err;
+
+    TRACE("socket %04lx, accept=%04lx, overlapped=%p\n", s, s_accept, lpOverlapped );
+
+    if ( !wsa )
+    {
+        WSASetLastError( WSAEFAULT );
+        return INVALID_SOCKET;
+    }
+
+    wsa->hSocket         = SOCKET2HANDLE(s);
+    wsa->flags           = 0;
+    wsa->user_overlapped = lpOverlapped;
+    wsa->addrlen.acpt.s_accept   = s_accept;
+    wsa->addrlen.acpt.buf        = buf;
+    wsa->addrlen.acpt.data_len   = data_len;
+    wsa->addrlen.acpt.local_len  = local_addr_len;
+    wsa->addrlen.acpt.remote_len = remote_addr_len;
+    wsa->addrlen.acpt.recvd      = recvd;
+
+    if (buf && data_len)
+        lpOverlapped = NULL; /* do not send completion events for accept because it will be done by WSASendTo */
+                             /* FIXME would not send completion in case of accept error (e.g. closed socket) */
+    iosb = lpOverlapped ? (IO_STATUS_BLOCK *)lpOverlapped : &wsa->local_iosb;
+    iosb->u.Status = STATUS_PENDING;
+    iosb->Information = 0;
+
+    SERVER_START_REQ( register_async )
+    {
+        req->handle         = wsa->hSocket;
+        req->type           = ASYNC_TYPE_READ;
+        req->async.callback = WS2_async_accept;
+        req->async.iosb     = iosb;
+        req->async.arg      = wsa;
+        req->async.apc      = NULL;
+        req->async.event    = lpOverlapped ? lpOverlapped->hEvent : NULL;
+        req->async.cvalue   = (lpOverlapped && ((ULONG_PTR)lpOverlapped->hEvent & 1) == 0) ? (ULONG_PTR)lpOverlapped : 0;
+        err = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (err != STATUS_PENDING) HeapFree( GetProcessHeap(), 0, wsa );
+    SetLastError( NtStatusToWSAError( err ));
+
+    return FALSE;
+}
+
+VOID WINAPI GetAcceptExSockaddrs( PVOID _buf, DWORD data_size, DWORD local_size, DWORD remote_size,
+                  struct sockaddr ** local_addr, LPINT local_addr_len, struct sockaddr ** remote_addr, LPINT remote_data_len)
+{
+    int len;
+    char *buf = _buf;
+
+    TRACE("\n");
+
+    buf += data_size;
+    if (local_size)
+    {
+        len = *(int*)buf;
+        *local_addr_len = len;
+        memcpy(local_addr, buf+sizeof(int), len);
+        buf += local_size;
+    }
+    if (remote_size)
+    {
+        len = *(int*)buf;
+        memcpy(remote_addr, buf+sizeof(int), len);
+        buf += remote_size;
+    }
+}
+
+
 /***********************************************************************
  *             accept          (WS2_32.1)
  */
@@ -2572,6 +2733,21 @@ int WINAPI WS_select(int nfds, WS_fd_set *ws_readfds,
     return ret;
 }

+static void WS_FireCompletion( SOCKET sock, ULONG_PTR CompletionValue, NTSTATUS CompletionStatus, ULONG_PTR Information )
+{
+    NTSTATUS status;
+
+    SERVER_START_REQ( fire_completion )
+    {
+        req->handle      = SOCKET2HANDLE(sock);
+        req->cvalue      = CompletionValue;
+        req->status      = CompletionStatus;
+        req->information = Information;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+

 /***********************************************************************
  *             send                    (WS2_32.19)
@@ -2623,6 +2799,7 @@ INT WINAPI WSASendTo( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
     unsigned int i, options;
     int n, fd, err;
     struct iovec iovec[WS_MSG_MAXIOVLEN];
+    ULONG_PTR cvalue = (lpOverlapped && ((ULONG_PTR)lpOverlapped->hEvent & 1) == 0) ? (ULONG_PTR)lpOverlapped : 0;

     TRACE("socket %04lx, wsabuf %p, nbufs %d, flags %d, to %p, tolen %d, ovl %p, func %p\n",
           s, lpBuffers, dwBufferCount, dwFlags,
@@ -2699,6 +2876,7 @@ INT WINAPI WSASendTo( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
                 req->async.arg      = wsa;
                 req->async.apc      = ws2_async_apc;
                 req->async.event    = lpCompletionRoutine ? 0 : lpOverlapped->hEvent;
+                req->async.cvalue   = cvalue;
                 err = wine_server_call( req );
             }
             SERVER_END_REQ;
@@ -2713,6 +2891,7 @@ INT WINAPI WSASendTo( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
         *lpNumberOfBytesSent = n;
         if (!wsa->completion_func)
         {
+            if (cvalue) WS_FireCompletion( s, cvalue, STATUS_SUCCESS, n );
             SetEvent( lpOverlapped->hEvent );
             HeapFree( GetProcessHeap(), 0, wsa );
         }
@@ -4132,6 +4311,7 @@ INT WINAPI WSARecvFrom( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
     int n, fd, err;
     DWORD timeout_start = GetTickCount();
     struct iovec iovec[WS_MSG_MAXIOVLEN];
+    ULONG_PTR cvalue = (lpOverlapped && ((ULONG_PTR)lpOverlapped->hEvent & 1) == 0) ? (ULONG_PTR)lpOverlapped : 0;

     TRACE("socket %04lx, wsabuf %p, nbufs %d, flags %d, from %p, fromlen %d, ovl %p, func %p\n",
           s, lpBuffers, dwBufferCount, *lpFlags, lpFrom,
@@ -4167,7 +4347,7 @@ INT WINAPI WSARecvFrom( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
                 goto error;
             }
         }
-        else
+        else if (lpNumberOfBytesRecvd)
             *lpNumberOfBytesRecvd = n;

         if ((lpOverlapped || lpCompletionRoutine) &&
@@ -4208,6 +4388,7 @@ INT WINAPI WSARecvFrom( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
                     req->async.arg      = wsa;
                     req->async.apc      = ws2_async_apc;
                     req->async.event    = lpCompletionRoutine ? 0 : lpOverlapped->hEvent;
+                    req->async.cvalue   = cvalue;
                     err = wine_server_call( req );
                 }
                 SERVER_END_REQ;
@@ -4221,6 +4402,7 @@ INT WINAPI WSARecvFrom( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
             iosb->Information = n;
             if (!wsa->completion_func)
             {
+                if (cvalue) WS_FireCompletion( s, cvalue, STATUS_SUCCESS, n );
                 SetEvent( lpOverlapped->hEvent );
                 HeapFree( GetProcessHeap(), 0, wsa );
             }
diff --git a/dlls/ws2_32/ws2_32.spec b/dlls/ws2_32/ws2_32.spec
index bbcafc0..902c811 100644
--- a/dlls/ws2_32/ws2_32.spec
+++ b/dlls/ws2_32/ws2_32.spec
@@ -117,3 +117,6 @@
 @ stdcall freeaddrinfo(ptr) WS_freeaddrinfo
 @ stdcall getaddrinfo(str str ptr ptr) WS_getaddrinfo
 @ stdcall getnameinfo(ptr long ptr long ptr long long) WS_getnameinfo
+
+@ stdcall AcceptEx(long long ptr long long long ptr ptr)
+@ stdcall GetAcceptExSockaddrs(ptr long long long ptr ptr ptr ptr)
diff --git a/server/protocol.def b/server/protocol.def
index c3ae5ba..c5d9402 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -942,6 +942,7 @@ enum server_fd_type
 /* Accept a socket */
 @REQ(accept_socket)
     obj_handle_t lhandle;       /* handle to the listening socket */
+    obj_handle_t ahandle;       /* handle to the accepting socket */
     unsigned int access;        /* wanted access rights */
     unsigned int attributes;    /* object attributes */
 @REPLY
diff --git a/server/sock.c b/server/sock.c
index 66ab0d1..856e53e 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -513,7 +513,7 @@ static void sock_queue_async( struct fd *fd, const async_data_t *data, int type,
         return;
     }

-    if ( ( !( sock->state & FD_READ ) && type == ASYNC_TYPE_READ  ) ||
+    if ( ( !( sock->state & FD_READ ) && !( sock->state & FD_WINE_LISTENING ) && type == ASYNC_TYPE_READ  ) ||
          ( !( sock->state & FD_WRITE ) && type == ASYNC_TYPE_WRITE ) )
     {
         set_error( STATUS_PIPE_DISCONNECTED );
@@ -620,9 +620,9 @@ static struct object *create_socket( int family, int type, int protocol, unsigne
 }

 /* accept a socket (creates a new fd) */
-static struct sock *accept_socket( obj_handle_t handle )
+static struct sock *accept_socket( obj_handle_t handle, obj_handle_t ahandle )
 {
-    struct sock *acceptsock;
+    struct sock *acceptsock = NULL;
     struct sock *sock;
     int        acceptfd;
     struct sockaddr    saddr;
@@ -651,7 +651,19 @@ static struct sock *accept_socket( obj_handle_t handle )
             release_object( sock );
             return NULL;
         }
-        if (!(acceptsock = alloc_object( &sock_ops )))
+
+        if (ahandle)
+        {
+            acceptsock = (struct sock *)get_handle_obj( current->process, ahandle, FILE_READ_DATA | FILE_WRITE_DATA, &sock_ops );
+            if (acceptsock)
+            {
+                if (acceptsock->event)
+                    release_object( acceptsock->event );
+                release_object( acceptsock->fd );
+            }
+        } else
+            acceptsock = alloc_object( &sock_ops );
+        if (!acceptsock)
         {
             close( acceptfd );
             release_object( sock );
@@ -786,11 +798,16 @@ DECL_HANDLER(accept_socket)
     struct sock *sock;

     reply->handle = 0;
-    if ((sock = accept_socket( req->lhandle )) != NULL)
+    if ((sock = accept_socket( req->lhandle, req->ahandle )) != NULL)
     {
-        reply->handle = alloc_handle( current->process, &sock->obj, req->access, req->attributes );
-        sock->wparam = reply->handle;  /* wparam for message is the socket handle */
-        sock_reselect( sock );
+        if (req->ahandle)
+            reply->handle = req->ahandle;
+        else
+        {
+            reply->handle = alloc_handle( current->process, &sock->obj, req->access, req->attributes );
+            sock->wparam = reply->handle;  /* wparam for message is the socket handle */
+            sock_reselect( sock );
+        }
         release_object( &sock->obj );
     }
 }
