--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@ -315,69 +315,70 @@ out_free_link:
 	return err;
 }
 
-int ovl_copy_up(struct dentry *dentry)
+/* Optimize by not copying up the file first and truncating later */
+int ovl_copy_up_truncate(struct dentry *dentry, loff_t size)
 {
 	int err;
+	struct dentry *next;
+	struct dentry *parent;
+	struct path lowerpath;
+	struct kstat stat;
+	enum ovl_path_type type;
+	struct dentry **adentry;
+	struct dentry **adentryr;
+	int sc, st, i;
 
 	err = 0;
-	while (!err) {
-		struct dentry *next;
-		struct dentry *parent;
-		struct path lowerpath;
-		struct kstat stat;
-		enum ovl_path_type type = ovl_path_type(dentry);
-
-		if (type != OVL_PATH_LOWER)
-			break;
 
-		next = dget(dentry);
-		/* find the topmost dentry not yet copied up */
-		for (;;) {
-			parent = dget_parent(next);
-
-			type = ovl_path_type(parent);
-			if (type != OVL_PATH_LOWER)
+	/* look for dentries that are pending to copy */
+	st = 5;
+	adentry = kmalloc(st * sizeof(struct dentry *), GFP_KERNEL);
+	if (!adentry)
+		return -ENOMEM;
+
+	next = dentry;
+	for (sc = 0; ; sc++) {
+		if (sc >= st) {
+			st += 5;
+			adentryr = krealloc(adentry, st * sizeof(struct dentry *), GFP_KERNEL);
+			if (!adentryr) {
+				err = -ENOMEM;
 				break;
-
-			dput(next);
-			next = parent;
+			}
+			adentry = adentryr;
 		}
 
-		ovl_path_lower(next, &lowerpath);
-		err = vfs_getattr(lowerpath.mnt, lowerpath.dentry, &stat);
-		if (!err)
-			err = ovl_copy_up_one(parent, next, &lowerpath, &stat);
+		adentry[sc] = dget(next);
+		type = ovl_path_type(adentry[sc]);
+		if (type != OVL_PATH_LOWER) {
+			dput(adentry[sc]);
+			break;
+		}
+		next = adentry[sc]->d_parent;
+	}
 
-		dput(parent);
-		dput(next);
+	/* copy the dentries */
+	for (i = sc - 1; i >= 0; i--) {
+		if (!err) {
+			parent = dget_parent(adentry[i]);
+			ovl_path_lower(adentry[i], &lowerpath);
+			err = vfs_getattr(lowerpath.mnt, lowerpath.dentry, &stat);
+			if (!err) {
+				if (i == 0 && size >= 0 && size < stat.size)
+					stat.size = size;
+				err = ovl_copy_up_one(parent, adentry[i], &lowerpath, &stat);
+			}
+			dput(parent);
+		}
+		dput(adentry[i]);
 	}
 
+	kfree(adentry);
+
 	return err;
 }
 
-/* Optimize by not copying up the file first and truncating later */
-int ovl_copy_up_truncate(struct dentry *dentry, loff_t size)
+int ovl_copy_up(struct dentry *dentry)
 {
-	int err;
-	struct kstat stat;
-	struct path lowerpath;
-	struct dentry *parent = dget_parent(dentry);
-
-	err = ovl_copy_up(parent);
-	if (err)
-		goto out_dput_parent;
-
-	ovl_path_lower(dentry, &lowerpath);
-	err = vfs_getattr(lowerpath.mnt, lowerpath.dentry, &stat);
-	if (err)
-		goto out_dput_parent;
-
-	if (size < stat.size)
-		stat.size = size;
-
-	err = ovl_copy_up_one(parent, dentry, &lowerpath, &stat);
-
-out_dput_parent:
-	dput(parent);
-	return err;
+	return ovl_copy_up_truncate(dentry, -1LL);
 }
